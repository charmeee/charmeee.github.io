<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><parsererror xmlns="http://www.w3.org/1999/xhtml" style="display: block; white-space: pre; border: 2px solid #c77; padding: 0 1em 0 1em; margin: 1em; background-color: #fdd; color: black"><h3>This page contains the following errors:</h3><div style="font-family:monospace;font-size:12px">error on line 130 at column 440: Invalid bytes in character encoding
</div><h3>Below is a rendering of the page up to the first error.</h3></parsererror><channel><title><![CDATA[Mj's Brain]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>Mj's Brain</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Thu, 13 Nov 2025 13:57:30 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Thu, 13 Nov 2025 13:57:15 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[전정프 - 13장 스프링]]></title><description><![CDATA[스프링 프레임워크 특징
스프링 부트
IoC, DI, AOP
실습 13.2, 13.3
경량 컨테이너 생명주기를 관리 제어의 역행지원 제어권이 프레임워크에 있음, 필요에 따라 사용자 코드 호출 의존성 주입 지원
관점지향 프로그래밍 지원 기존 프로그램 시작되는곳 필요한 객체 생성
생성된 객체의 메서드 호출 스프링 컨테이너가 객체를 관리 제공
코드에서 객체 생성 ㄴㄴ 객체 생성 선택에 관여하지 않고 어떻게 사용되는 지 알 수없음
제어권한을 위임받은 객체(=컨테이너)에 의해 만들어지고 사용됨
IOC구현 방법으로 DI 와 DL이 있음
DI : 의존 관계를 Bean설정에 기반에 컨테이너가 자동으로 연결해줌 @Autowired 이용해서 빈주입 DL : 컨테이너에서 제공하는 API를 이용하여 직접 Bean을 찾음 의존성 커지고 코드 많아져서 ㄴㄴ 횡단 관심사 분리를 허용함으로써 모듈성을 증가시키는 것이 목적
Advise로 정의 : 반복되는 추가 동작을 정의
Pointcut : 어떤위치에 수행할 것인지 정의 스프링을 빠르고 간편하게 실행할 수있게해줌
별도 설치없이 웹어플리케이션 구동 가능
<img alt="../../daily/assets/스크린샷 2023-12-19 오전 10.31.45.png" src="daily/assets/스크린샷-2023-12-19-오전-10.31.45.png" target="_self">
리액티브 스택 비동기 논블로킹 I/O 구조 사용
리액티브 프로그래밍 비동기 I/O 기반
데이터 흐름과 변화 전파에 중점을 둔 프로그래밍 서블릿 스택 동기 블로킹 I/O 구조 사용 하나의 요청 하나의 스레드. 모델과 뷰는 코드 그대로 사용가능할 정도로 유연한 구조 모델은 Spring Data JPA 사용하면 편함
뷰는 JSP에 대한 종속 없음. MVC 기반 웹개발과 구조적으로 동일
컨트롤러 직접구현 ㄴㄴ 특정 요청에 대한 처리 메서드만 작성하면 됨
@Controller : 동작할 클래스 의미
@RequetMapping : 요청 매핑
get /web/hello에 동작하는 메서드<br>
<img alt="../../daily/assets/스크린샷 2023-12-19 오전 10.54.00.png" src="daily/assets/스크린샷-2023-12-19-오전-10.54.00.png" target="_self"> REST API 구현하기 위해 사용하는 모듈
JAX-RS 보다 간결함
리턴 타입으로 사용하면 자동으로 json변환(JAX-RX도 같음)
hello( ) 메서드: /api/hello?msg=Welcome
hello2( ) 메서드: /api/hello/Welcome<br>
<img alt="../../daily/assets/스크린샷 2023-12-19 오전 10.58.47.png" src="daily/assets/스크린샷-2023-12-19-오전-10.58.47.png" target="_self"> 컨트롤러
@ResponseBody : 별도의 뷰가 아닌 리턴값을 직접 HTTP 응답 보디에 출력함<br>
<img alt="../../daily/assets/스크린샷 2023-12-19 오전 11.03.34.png" src="daily/assets/스크린샷-2023-12-19-오전-11.03.34.png" target="_self">
데이터를 포함한뷰 포워딩을 위해 Model객체추가<br>
<img alt="../../daily/assets/스크린샷 2023-12-19 오전 11.05.22.png" src="daily/assets/스크린샷-2023-12-19-오전-11.05.22.png" target="_self">
뷰<br>
<img alt="../../daily/assets/스크린샷 2023-12-19 오전 11.06.22.png" src="daily/assets/스크린샷-2023-12-19-오전-11.06.22.png" target="_self">
<br><img alt="../../daily/assets/스크린샷 2023-12-19 오전 11.06.59.png" src="daily/assets/스크린샷-2023-12-19-오전-11.06.59.png" target="_self"><br>
<img alt="../../daily/assets/스크린샷 2023-12-19 오전 11.07.30.png" src="daily/assets/스크린샷-2023-12-19-오전-11.07.30.png" target="_self">]]></description><link>300-백엔드개발/전정프-13장-스프링.html</link><guid isPermaLink="false">300-백엔드개발/전정프 - 13장 스프링.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Thu, 13 Nov 2025 13:55:08 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[전정프 - 12장 restapi]]></title><description><![CDATA[하나의 자원을 여러형태의 표현으로 전달 가능할 수 잇다는 개념
rest클라이언트 : restapi를 사용하는프로그램
클라-서버 프로그램 구조의 문제점 등장 : 프로토콜 자체적으로 정의해야함
그래서 웹사용
근데 웹은 화면 중심시스템임
확장성 좋고 경량구조인 json주목
restful 개념 조명 -&gt; 프런트엔드 중심개발 동사대신명사 사용(자원사용)
상태 변경시 get,쿼리파라미터 사용 ㄴㄴ
복수명사사용(집합형 데이터를 다루는 경우)
관계형태의 표현에 하위리소스 사용
에러 정보 제공( 머에러메세지나..그런것들..) Rest 형태를 개발할 수 있는 자바에서 만든 표준 규격(API)
개발 단순화하는 인터페이스 java 애너테이션의 집합체
스프링의 경우 RestController 사용 서비스 등록
@ApplicationPath 이용 어떤 url을 사용할지 지정해야함
해당 요청에대한 구현 클래스를 패키지로 등록해야함.<img alt="../../daily/assets/스크린샷 2023-12-19 오전 10.27.13.png" src="daily/assets/스크린샷-2023-12-19-오전-10.27.13.png" target="_self">
API 클래스 구현
별도의 클래스 상속 ㄴㄴ
@메서드
@PATH 로 시작경로 선택<br>
@콘텐츠 응답타입 <img alt="../../daily/assets/스크린샷 2023-12-19 오전 10.25.22.png" src="daily/assets/스크린샷-2023-12-19-오전-10.25.22.png" target="_self">
]]></description><link>300-백엔드개발/전정프-12장-restapi.html</link><guid isPermaLink="false">300-백엔드개발/전정프 - 12장 restapi.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Thu, 13 Nov 2025 13:55:04 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[전정프 - 11장 특수 서블릿]]></title><description><![CDATA[
컨테이너에서 발생하는 이벤트를 "모니터링"하다가 발생시 실행되는 특수 서플릿
실행에 필요한 정보 제공 특정 상황에 자동으로 동작하는 프로그램을 구현할 때 사용(톰캣 시작종료 같이..)
애너테이션 @WebListener 를 이용해 리스너임을 명시.
생명주기 변화와 해당 스코프의 속성의 변화를 관찰함.
-&gt; 이벤트 발생 -&gt; 리스너실행<img alt="../../daily/assets/Pasted image 20231219094330.png" src="daily/assets/pasted-image-20231219094330.png" target="_self" style="width: 400px; max-width: 100%;">
초기화 매개변수와 연동 톰캣이 시작시, 초기화 매개변수를 읽어 특정 개체를 초기화한 후 서블릿이나 jsp에 제공 예제프로그램 등 배포시 샘플데이터 제공 DB가 필요한 경우 , 미리 DB와의 연결을 만들어두거나 테이블을 작성하는 등의 작업을자동으로 수행해서 추가적인 작업없이 프로그램 실행할 수 있음 복잡한 환경 설정 제공 프로그램에 필요한 여러 정보(외부서 주입하는 형태)가 고정되어있지않고 환경에 따라 변경되야하는 경우 이를 파일로부터 읽어와 JSP, 서블릿 등에 제공 특정 이벤트에 동작하는 기능 구현 애플리케이션 실행시 함께 동작해야하는 외부프로그램이나 서비스 동작유무를 확인하고 자동 실행 가능 ServletContext javax.servlet.ServletContextListener : 생명주기변화
javax.servlet.ServletContextAttributeListener : 속성 변화 Session
- javax.servlet.http.HttpSessionListener : 생명주기 변화
- javax.servlet.http.HttpSessionAttributeListener : 속성<br>
<img alt="../../daily/assets/Pasted image 20231219095311.png" src="daily/assets/pasted-image-20231219095311.png" target="_self" style="width: 400px; max-width: 100%;"> "사용자 요청"에 따라 서블릿이나 Jsp가 "실행전"에 response,request 객체의 조작이나 추가적인 처리가능
보통 특정 요청에만 동작, 정해진 순서에 따라 동작
@WebFilter("url 매핑정보")
여러개 필터를 순서대로 적용하기 'web.xml'에 필터 등록해야함
이경우에는 @WebFilter(filterName="filterOne")<br>
<img alt="../../daily/assets/Pasted image 20231219101229.png" src="daily/assets/pasted-image-20231219101229.png" target="_self" style="width: 400px; max-width: 100%;"> <br><img alt="../../daily/assets/Pasted image 20231219100911.png" src="daily/assets/pasted-image-20231219100911.png" target="_self" style="width: 400px; max-width: 100%;">
init : 초기화 작업
doFilter : 해당 필터가 적용되었을 때의
ServletRequest나 ServletResponse을 가로채 필요한 작업을 수행
destory : 필터가 종료될 때의 작업
인증
로깅
국제화
한글 인코딩 처리
]]></description><link>300-백엔드개발/전정프-11장-특수-서블릿.html</link><guid isPermaLink="false">300-백엔드개발/전정프 - 11장 특수 서블릿.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Thu, 13 Nov 2025 13:55:01 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[전정프 - 9장 DB 와 JDBC]]></title><description><![CDATA[DDL, DML
JDBC
실습 9.2여러사람이 공유할 목적으로 체계화하여 통합 관리하는 데이터 집합
DBMS : 데이터를 효과적으로 관리하고 운영하는 기능을 제공 (캐싱인덱싱 백업 권한관리등)
관계형 데이터페이스 장점 다양한 용도로 사용 가능 높은성능
일관성 보장
정규화 ,구조화 되어잇음. 단점 데이터 구조변경 어려움
빠른 속도 요구하는 단순처리 대응어려움 NoSQL 테이블 형태의 구조가 아님
sql과 다를 수 있지만 별도의 쿼리언어나 구조는 존재
장점 대용량처리 유리
분산처리유리
빠름
유연함 단점 복잡한 데이터 관계표현시 중복데이터 발생가능 관계형데이터베이스 표준언어데이터 정의어
테이블을 생성 삭제 구조변경
생성 CREATE
CREATE TABLE 이름 ( 컬럼이름 자료형(크기) 제약조건|속성) 수정 Alter
ALTER TABLE 이름 [ ADD | ALTER | DROP] 칼럼명 자료형 제약조건 alter : 자료형, 제약조건을 바꿀 수있음 삭제 Drop
DROP TABLE 이름 [RESTRICT | CASCADE] 테이블정보조회 SHOW 데이터 조작어
SELECT
<img alt="../../daily/assets/Pasted image 20231219023443.png" src="daily/assets/pasted-image-20231219023443.png" target="_self">
INSERT INSERT INTO 테_이(칼럼이름) VALUES(칼럼데이터)
컬럼에 데이터 추가
auto increment 거나 not null 은 안체워도 ㄱㅊ UPDATE
DELETE
JOIN 문자관련 ASCII(아스키코드값), LENGTH(길이), CONCAT(문자열 결합), TRIM(양쪽 공백 제거), LOWER(소문자 변환), UPPER(대문자 변환), SUBSTRING(부분 선택) 날짜 기간함수 NOW(현재 날짜 시간), CURRENT_TIMESTAMP(현재 날짜 시간), DAYNAME(요일), PARSEDATETIME(문자열 포맷을 날짜 시간 정보로 변환) 집계함수 COUNT(레코드 수), SUM(칼럼값 더하기), AVG(칼럼값 평균). MAX(칼럼 최댓값), MIN(칼럼 최솟값) 자바 애플리케이션에서 다양한 데이터베이스와 표준화된 방법으로 연결하여 개발을 위해 설계된 인터페이스
JDBC API이용해 SQL문으로 데이터 조작API : 개발자가 사용해서 코드를 작성하는거
드라이버 : 회사제공<br>
<img alt="../../daily/assets/Pasted image 20231219024244.png" src="daily/assets/pasted-image-20231219024244.png" target="_self" style="width: 300px; max-width: 100%;">
JDBC 드라이버 로드 System.setProperty() jdbc.drivers라는 시스템환경변수에 등록된 내용으로 하는법 Class.forName 드라이버 이름으로 드라이버를 로드 데이터베이스 연결 java.sql.Connection DriverManager.getConnection( url,"아이디","비번") : 레퍼런스 가져옴 Statement 생성 java.sql.Statement
java.sql.preparedStatement 이친구가 더조음
Statement 상속받기 때문에 Statement메서드 모두사용가능
SQL문을 미리 만들어두고 변수를 따로 입력<br>
<img alt="../../daily/assets/Pasted image 20231219025219.png" src="daily/assets/pasted-image-20231219025219.png" target="_self"> SQL문 전송 java.sql.Statement executeQuery() SELECT 수행시 사용
반환값은 ResultSet클래스, 결과 데이터 접근 방법을 제공 executeUpdate() UPDATE,DELETE
반환값은 INT, 처리된 데이터 수를 반환 결과 받기 java.sql.ResultSet 순차적으로 접근할 수 있는 커서를 다룰 수 있게 함. 연결 해제 java.sql.Connection close()
커넥션 뿐만 아니라 Statement나 ResultSet함께 종료해주는 것이 좋음. &lt;form method="post" action=" / jwbook / studentControl?action=insert"&gt; &lt;label&gt; 이름&lt;/ label&gt; &lt;input type="text" name="username" &gt;&lt;br&gt; &lt;label&gt;대학&lt;/label&gt; &lt;input type="text" name="univ" &gt;&lt;br&gt; &lt;label&gt; 생일&lt;/label&gt; &lt;input type="text" name="birth"&gt;&lt;br&gt; &lt;label&gt; 이메일&lt;/label&gt; &lt; input type="text" name="email" &gt; &lt;br&gt; &lt;button type="submit" &gt; 등록&lt; /button&gt;
&lt;/ form&gt;
/*Student.java - DO클래스*/
public class Student { private int id; private String username; private String univ; private Date birth; private String email;
//생성자
//getter, setter
} /*StudentDAO.java - DAO 클래스*/
public class StudentDAO { Connection conn = null; PreparedStatement pstmt; final String JDBC_DRIVER = "org,h2.Driver"; final String JDBC_URL = "jdbc:h2:tcp://localhost/~/jwbookdb"; public void open(){ try{ Class.forName(JDBC_DRIVER); conn = DriverManager.getConnection(JDBC_URL,"id","pw"); }catch(Exception e){ e.printStactTrace(); } } public void close() { try{ pstmt.close(); conn.close(); } catch (SQLException e) { e.printStackTrace(); } ｝ public void insert(Student s) { open (); String sql ="INSERT INTO student(username, univ, birth, email) values(?,?,?,?)"; try { pstmt = conn.prepareStatement(sq1); pstmt.setString(1, s.getUsername()); pstmt.setString(2, s.getUniv()); pstmt.setDate(3, s.getBirth()); pstmt.setString(4, s.getEmail()); pstmt.executeUpdate(); } catch( Exception e ) { e.printStackTrace(); } finally { close(); } } public List‹Student&gt; getA11() { open(); List‹Student&gt; students = new ArrayList(); try { pstmt = conn.prepareStatement("select * from student"); ResultSet rs = pstmt.executeQuery(); while(rs.next()) { Student s = new Student); s.setId(rs.getInt("id")); s.setUsername(rs.getString("username")); s.setUniv(rs.getString("univ")); s.setBirth(rs.getDate("birth")); s.setEmail(rs.getString("email")); students.add(s); } } catch (Exception e) { e.printStackTrace(); } finally { close(); } return students; ｝
}
package ch09;
import java.io.I0Exception;
import org.apache.commons.beanutils.BeanUtils; @WebServlet ("/studentControl")
public class StudentController extends HttpServlet { private static final long serialVersionUID = 1L; StudentDAO dao; public void init(ServletConfig config) throws ServletException { super.init(config); dao = new StudentDAO(); ｝ protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, I0Exception { request.setCharacterEncoding("utf-8"); String action = request.getParameter("action"); String view = ''; if(action == null) { getServletContext().getRequestDispatcher("/studentControl?action=list").forward (request, response); } else { switch(action) { case "list": view = list(request, response); break; case "insert": view = insert(request, response); break; } getServletContext().getRequestDispatcher("/ch09/"+view) .forward(request, response); } } public String list(HttpServletRequest request, HttpServletResponse response){ request setAttribute("students", dao.getAll()); return "studentInfo.jsp"; } public String insert(HttpServletRequest request, HttpServletResponse response) { Student s = new Student(); try { //맵을 bin객체로 BeanUtils.populate(s, request.getParameterMap()); } catch (Exception e) {e.printStackTrace(); } dao.insert(s); return list (request, response); }
}
]]></description><link>300-백엔드개발/전정프-9장-db-와-jdbc.html</link><guid isPermaLink="false">300-백엔드개발/전정프 - 9장 DB 와 JDBC.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Thu, 13 Nov 2025 13:54:57 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[전정프 - 8장 MVC]]></title><description/></item><item><title><![CDATA[빅분기 3유형_이론]]></title><description><![CDATA[np.log()p-value가 작을수록(예:&nbsp;0.05보다 작을 때) "이런 결과가 단순히 우연히 일어날 가능성은 매우 낮다"고 해석합니다. 그래서 보통 p-value가 0.05(5%)보다 작으면, 기존의 가정(귀무가설)을 기각하고, 연구자가 주장하는 대립가설을 채택합니
귀무 : 일반적으로 ㅇㅈ하는가설
대립: 연구자가 주장하는 가설
p-value : 끝범위0.05 미만이면 대립가설채택
검정할땐 같다! 가귀무
모델에선 영향이없다! 가.귀무
두집단사이의 분산이 같은지 확인하는 통계적 방법
F &gt;= 1이 되도록 즉 더큰 놈을 분자로 두셈
그룹1분산/그룹2분산
양측검정 : 양쪽으로 극한값이 잇냐없냐
<img alt="assets/빅분기 3유형-1750346821520.png" src="900-자격증/assets/빅분기-3유형-1750346821520.png" target="_self">
먼저꺼 대립가설 채택
귀무가설채택 <br>두집단의 평균이 통계적으로 유의하게 다른지 검정<img alt="assets/빅분기 3유형-1750347514162.png" src="900-자격증/assets/빅분기-3유형-1750347514162.png" target="_self">
종류: 단일 표본 t-검정: 한 집단의 평균이 특정 값과 다른지 검정 t_statistic, p_value = stats.ttest_1samp(df['weights'], 120)
독립표본 t-검정: 두 집단의 평균이 서로 다른지 검정 (다른약) stats.ttest_ind(data1, data2) 대응표본 t-검정: 동일 집단의 사전/사후 평균 차이 검정 (복용전후) stats.ttest_rel(before, after) 가설 방향 <br><img alt="assets/빅분기 3유형-1750347365035.png" src="900-자격증/assets/빅분기-3유형-1750347365035.png" target="_self">
<br><img alt="assets/빅분기 3유형-1750347440411.png" src="900-자격증/assets/빅분기-3유형-1750347440411.png" target="_self"> 가정:&nbsp;정규분포, 등분산성 등이 필요합니다<br>
<img alt="assets/빅분기 3유형-1750347608648.png" src="900-자격증/assets/빅분기-3유형-1750347608648.png" target="_self"> 두집단의 분산이 같다는 가정하에 두집단정보를 하나로 합처서 공통된 분산을 추정하는 것
T-검정 계산할때 필요함(애도 등분산성을 가정함)
두집단을 합처서 하나로묶어서 분산계산한다는말
<br>공식<img alt="assets/빅분기 3유형-1750347244630.png" src="900-자격증/assets/빅분기-3유형-1750347244630.png" target="_self">
]]></description><link>900-자격증/빅분기-3유형_이론.html</link><guid isPermaLink="false">900-자격증/빅분기 3유형_이론.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Thu, 13 Nov 2025 13:30:23 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[빅분기 3유형]]></title><description><![CDATA[
가설검정, 분산 분석, 카이제곱, 회귀, 로지스틱 회귀
np exp &lt; -&gt; np log
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@imymemineyay/%EB%B9%85%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B6%84%EC%84%9D-%EA%B8%B0%EC%82%AC-%EC%8B%A4%EA%B8%B0-%ED%86%B5%EA%B3%84" target="_self">https://velog.io/@imymemineyay/%EB%B9%85%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B6%84%EC%84%9D-%EA%B8%B0%EC%82%AC-%EC%8B%A4%EA%B8%B0-%ED%86%B5%EA%B3%84</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://doitforus.tistory.com/132#%EB%8C%80%EC%9D%91%20%ED%91%9C%EB%B3%B8%20%EA%B2%80%EC%A0%95-1" target="_self">https://doitforus.tistory.com/132#%EB%8C%80%EC%9D%91%20%ED%91%9C%EB%B3%B8%20%EA%B2%80%EC%A0%95-1</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://wikidocs.net/265436" target="_self">https://wikidocs.net/265436</a>import pandas as pd
import numpy as np
from scipy import stats
import statsmodels.api as sm상관분석 : stats.pearsonr(simple['weight'],simple['height'])
단일 표본 검정 (모집단 1개) 예) 과자의 무게는 200g과 다른지 검정
① 정규성 검정 : shapiro(data)
② 정규성 NO ) 비모수 검정 : wilcoxon(data - 기대값)
② 정규성 YES ) 단일 표본 검정 : ttest_1samp(data, 기대값) 대응 표본 검정 (모집단-같은 집단 2개) 예) 신약 효과 (전후) 검정
①&nbsp;정규성 검정 : shapiro(data1 - data2)
② 정규성 NO ) 비모수 검정 : wilcoxon(data1, data2)
② 정규성 YES ) 단일 표본 검정 : ttest_rel(data1, data2) 독립 표본 검정 (모집단) 예) 1반과 2반의 성적 차이 검정
① &nbsp;정규성 검정 : shapiro(data1), shapiro(data2) → 둘다 만족해야함
② 정규성 NO ) 비모수 검정 : mannwhitneyu(data1, data2)
② 정규성 YES ) 등분산 검정 : levene(data1, data2)
③ 등분산 NO ) 독립 표본 검정 : ttest_ind(data1, data2, equal_var = False)
③ 등분산 YES ) 독립표본 검정 : ttest_ind(data1, data2) # 기본 : 양측검정 : 평균이 같냐다르냐
# alternative # 1) two-sided: 대립가설의 내용이 서로 틀리다라고 주장할 때 사용. 양측 검정
# 2) less: 대립가설의 내용이, a &lt; b 라고 주장할 때 사용. 단측 검정
# 3) greater: 대립가설의 내용이 a &gt; b 라고 주장할 때 사용. 단측 검정 # 검정통계량, p-value
## t-검정
# 단일
t_stat, p_value = stats.ttest_1samp(df['weights'], 120)
# p_value &lt; 0.05 : 평균이 120이랑다름
# 독립
t_stat, p_value = stats.ttest_ind(data1, data2)
# p_value &lt; 0.05 : 평균이 둘이다름
# 대응
st, pv = stats.ttest_rel(a, b)
# p_value &lt; 0.05 : 평균이 둘이다름 ## f- 검정
f_stat, p_value = stats.f_oneway(group1, group2, group3)
# p_value &lt; 0.05 : 평균 분산차이 유의미 ## 비모수검정
stats.wilcoxon(df['before'], df['after'], alternative = "less") 변수 선택, 회귀계수 해석, 예측값 산출, 성능평가(R², 오분류율 등)
COEF(회귀계수, regression coefficient)은 회귀분석에서 각 독립변수가 종속변수에 미치는 영향의 크기를 나타내는 값 coefficients = result.params[1:] # 상수항 제외
odds_ratios = np.exp(coefficients) odds_ratio = np.exp(coef_high)
statsmodels.api 에서 param인자로 알수잇음
z-score : 어떤 데이터가 전체 평균에서 얼마나 떨어져 있는지를 "표준편차 단위"로 나타내는 값 절댓값이 클수록(0에서 멀수록) 좋다
P&gt;|t| : p-value임 0.05 미만 : 변수가 종속변수에 통계적으로 유의미한 영향을줌 std err= 표준 오차 작을수록 굳
misclassification rate (오분류 샘플 수) / (전체 샘플 수) <br><img alt="assets/빅분기 3유형-1750458321998.png" src="900-자격증/assets/빅분기-3유형-1750458321998.png" target="_self">from statsmodels.formula.api import logit
model = logit('disease ~ age + bmi', data=df).fit()
print(model.summary()) import statsmodels.api as sm X = sm.add_constant(df[['age', 'bmi']]) # 상수항 직접 추가 y = df['disease'] model = sm.Logit(y, X).fit() print(model.summary()) result = np. exp(coef1)
print(round(result, 1))
# 방법2) Statsmodels 라이브러리의 Logit 함수 적용
import statsmodels.api as sm
train_x_const = sm. add_constant(train_x)
model = sm. Logit(train_y, train_x_const) .fit(
# 상수항 추가
# disp=0 옵션 사용 시 모델 학습 결과
coef1 = model params [ income ']
import numpy as np
result = np. exp(coef1)
print(round (result, 1))
# 방법3) statsmodels 라이브러리의 GLM 함수 적용
import statsmodels.api as sm
# train_x_const = sm.add_constant(train_x)
# 상수항 추가
model = sm.GLM(train_y, train_x_const, family=sm.families.Binomial)).fit()
Log-Likelihood = llf
로그우도(모델 적합도), 절대값이 작을수록 적합도가 높음
Df Residuals:&nbsp;997
잔차 자유도(1000 - 3, Intercept 포함)
높을수록조음용
LLR p-value:&nbsp;1.984e-15
전체 모델의 유의성 검정, p&lt;0.05이므로 모델이 통계적으로 유의함
Pseudo R-squ.:&nbsp;0.04996
의사결정계수(로지스틱 회귀의 설명력, 0.05로 낮은 편) 회귀분석(다중, 로지스틱): 까지 연습 필요.
import statsmodels.api as sm
glm_binom = sm.GLM(y, X, family=sm.families.Binomial())
result = glm_binom.fit()
print(result.summary()) 잔차 이탈도, deviance 등 GLM에서만 제공되는 지표를 물을 때 예: "잔차 이탈도를 구하시오", "모델의 deviance 값을 해석하시오" 시험 문제에서 "일반화 선형모형" 또는 "GLM"이라는 단어가 직접적으로 언급될 때
정확하진 않지만 제가 강의 들었을 때는 logit은 summary에 잔차이탈도가 안나오는데 glm은 나와서 잔차이탈도 구할때만 glm을 썼어요!
즉,&nbsp;Deviance:: ㅌ잔차이탈도 = 각 관측치의 실제값과 예측값이 얼마나 다른지, 이탈도 관점에서 측정한 값입니다.
chi
카이제곱 검정: 교차표, 기대빈도, 카이제곱 통계량, p-value 해석 등 실전 계산 연습 필요.
두변수가 독립인지import numpy as np
from scipy.stats import chi2_contingency # 교차표(관측 빈도)
# 흡연 비흡연
# 남자 30 20
# 여자 10 40
data = np.array([[30, 20], [10, 40]]) # 카이제곱 검정 실행
chi2_stat, p_value, dof, expected = chi2_contingency(data) print(f"카이제곱 통계량: {chi2_stat:.4f}")
print(f"p-value: {p_value:.4f}")
print(f"자유도: {dof}")
print("기대빈도표:")
print(expected) # 해석
alpha = 0.05
if p_value &lt; alpha: print("귀무가설 기각: 두 변수는 독립이 아님(연관 있음)")
else: print("귀무가설 채택: 두 변수는 독립임(연관 없음)") 이론적 분포와의 비교from scipy.stats import chisquare # 관측 빈도 (예: 6면 주사위 60번 던짐)
observed = [8, 9, 10, 11, 12, 10]
# 기대 빈도 (공정하다면 각 면이 10번씩 나와야 함)
expected = [10, 10, 10, 10, 10, 10] chi2_stat, p_value = chisquare(f_obs=observed, f_exp=expected) print(f"카이제곱 통계량: {chi2_stat:.4f}")
print(f"p-value: {p_value:.4f}") if p_value &lt; 0.05: print("귀무가설 기각: 주사위는 공정하지 않음")
else: print("귀무가설 채택: 주사위는 공정함") import pandas as pd
from scipy import stats
import statsmodels.api as sm
import numpy as np
# Index(['Resistin', 'Classification'], dtype='object')
df = pd.read_csv("data/bcc.csv") group1 = df[df['Classification']==1]['Resistin']
group2 = df[df['Classification']==2]['Resistin'] g1 = np.log(group1)
g2 = np.log(group2) n1 = len(g1) - 1
n2 = len(g2) - 1 print(stats.f_oneway(g1,g2))
print(stats.ttest_ind(g1,g2)) sum_var = (np.var(g1)*n1 + np.var(g2)*n2)/(n1+n2)
print(sum_var)
# print(dir(stats)) # 해당 화면에서는 제출하지 않으며, 문제 풀이 후 답안제출에서 결괏값 제출 &gt; F_onewayResult(statistic=9.172465158846453, pvalue=0.003039226943143336)
TtestResult(statistic=-3.0286077921788537, pvalue=0.0030392269431433142, df=114.0)
0.4413710541719135 <br><img alt="assets/빅분기 3유형-1750450078055.png" src="900-자격증/assets/빅분기-3유형-1750450078055.png" target="_self"># 데이터 불러오기
# 독립변수: satisfaction, salary_level, project_count, working_hours # 종속변수: left_company (퇴사 여부: 0 = 재직, 1 = 퇴사) # salary_level은 범주형 변수이며, 기준 수준(reference level)은 low로 설정합니다.
import pandas as pd
import numpy as np
import pandas as pd
import statsmodels.api as sm
df = pd.read_csv('/kaggle/input/bigdatacertificationkr/employee_attrition.csv')
df.head()
y= df['left_company']
x= df.drop(columns = ['left_company'])
x['salary_level'] = pd.Categorical( x['salary_level'], categories=['low', 'medium', 'high'], # **첫 번째 요소('low')를 참조 수준**으로 자동 설정 ordered=False
)
x = pd.get_dummies(x,drop_first=True, dtype=int) # print(help(sm.Logit))
x_const = sm.add_constant(x)
print(x_const.head())
model = sm.Logit(y,x_const).fit()
model.summary() # 문제 2-1: satisfaction 회귀계수
coef_satisfaction = model.params['satisfaction']
rounded_coef = round(coef_satisfaction, 3)
print(f"문제 2-1: satisfaction 회귀계수 = {rounded_coef}") # 문제 2-2: salary_level=high 오즈비
coef_high = model.params['salary_level_high']
odds_ratio = np.exp(coef_high)
rounded_odds = round(odds_ratio, 3)
print(f"문제 2-2: high vs low 오즈비 = {rounded_odds}") # 문제 2-3: 정밀도 계산
y_pred_prob = model.predict(x_const)
y_pred = (y_pred_prob &gt;= 0.5).astype(int)
precision = precision_score(y, y_pred)
rounded_precision = round(precision, 3)
print(f"문제 2-3: 정밀도 = {rounded_precision}")
# satisfaction
# 1. -2.8436 문제 2-1: satisfaction 회귀계수 = -2.844
문제 2-2: high vs low 오즈비 = 0.099
문제 2-3: 정밀도 = 0.622from scipy.stats import chi2_contingency ## 교차표가 필요함
table = pd.crosstab(df['Gender'],df['Survived'])
chi2_contingency(table)
stat , p ,df ,expect = chi_contingency(table)
print(round(stat,3)) # 2번 from statsmodels.api import Logit
from sklearn.preprocessing import LabelEncoder
import statsmodels.api as sm encoder = LabelEncoder
df[ 'Gender'] = encoder.fit_transform(df[ 'Gender' ]) X = df[['Gender', 'SibSp', 'Parch', 'Fare']] X = sm.add_constant (X) y = df[ 'Survived' ] model = Logit (y, X) results = model. fit() print(results.summary))
import numpy as np print(round(p. exp(-0.3539))
]]></description><link>900-자격증/빅분기-3유형.html</link><guid isPermaLink="false">900-자격증/빅분기 3유형.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Thu, 13 Nov 2025 13:30:23 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[빅분기 2유형]]></title><description><![CDATA[
이진분류, 다중분류, 회귀, 평가지표\
import pandas as pd train = pd.read_csv("data/customer_train.csv")
test = pd.read_csv("data/customer_test.csv") # 일단회귀임
## 1. 데이터확인
# print(train.head())
# print(test.head())
# ['회원ID', '총구매액', '최대구매액', '환불금액', '주구매상품', '주구매지점', '방문일수', '방문당구매건수', '주말방문비율', '구매주기']
# print(train.info()) ## 2. y값 분리
train_y = train["총구매액"]
train_x = train.drop(['총구매액', '회원ID'], axis=1)
test_x = test.drop(['회원ID'], axis=1) ## 3. 결측치 처리
# 내생각엔 2가지방법 결측치가많으니깐 1. 환불이 없다, 환불컬럼을아예지운다정도
train_x['환불금액'] = train_x['환불금액'].fillna(0)
test_x['환불금액'] = test_x['환불금액'].fillna(0) ## 4. 수치형데이터,범주형데이터 인코딩
from sklearn.preprocessing import LabelEncoder
# 수치형은 MinMaxScaler보통쓰면됨 랜덤포래스트쓴다면안해두됨
le = LabelEncoder()
object_cols = train_x.select_dtypes(include="object").columns
# test데이터에 예외값이잇는지확인
# 만약예외값이있다면 기타항목을 넣어야함
for col in object_cols: # print(set(test_x[col])-set(train_x[col])) train_x[col] = le.fit_transform(train_x[col]) test_x[col] = le.transform(test_x[col]) ## 5. 데이터 분류
from sklearn.model_selection import train_test_split
x_tra,x_val,y_tra,y_val = train_test_split(train_x,train_y,test_size=0.2)
print(x_tra.shape,x_val.shape,y_tra.shape,y_val.shape) ## 6. 모델학습
from sklearn.ensemble import RandomForestRegressor
model = RandomForestRegressor()
model.fit(x_tra,y_tra)
# 검증데이터 예측
y_val_pre = model.predict(x_val) ## 7. 검증데이터의 예측값과 실제값으로 모델성능확인
# 분류면 f1스코어보겟쥬?
from sklearn.metrics import root_mean_squared_error,r2_score
# print(help(root_mean_squared_error))
rmse = root_mean_squared_error(y_val,y_val_pre)
r2 = r2_score(y_val,y_val_pre)
print(rmse,r2) ## 8. 문제서 요구하는 test데이터값예측 후 결과저장
y_test_pre=model.predict(test_x)
print(y_test_pre) # 1차원 numpy
y_test_pre = pd.DataFrame(y_test_pre,columns=['pred'])
print(y_test_pre.head())
y_test_pre.to_csv('result.csv',index=False) ## 9. 확인
print(pd.read_csv('result.csv').head()) 기본적으로 이부분 사용
<a class="internal-link" data-href="ASSO 대비.md" href="900-자격증/asso-대비.html" target="_self" rel="noopener nofollow">ASSO 대비</a>from sklearn.processing import LabelEncoder,StandardScaler,MinMaxScaler,RobustScaler from sklearn.model_selection import train_test_split
asso때는 y,x(타겟과 특성을 먼저 분리햇는데)
애넨 테스트셋부터분리를 하네??import pandas as pd # 예시 데이터프레임
df1 = pd.DataFrame({'key': ['A', 'B', 'C'], 'value1': [1, 2, 3]})
df2 = pd.DataFrame({'key': ['B', 'C', 'D'], 'value2': [4, 5, 6]}) # key 컬럼을 기준으로 가로로 합치기 (inner join)
merged = pd.merge(df1, df2, on='key', how='inner')
print(merged) 분류모델쓸때 (하위 함수,속성은 sklearn의 분류모델의 인스턴스에 잇는것임)
predict_proba():&nbsp;각 클래스별 확률 반환 (분류 모델에서만 사용)
predict:&nbsp;가장 확률 높은 클래스(최종 예측값) 반환
classes_ : 인식한&nbsp;고유((한 클래스(레이블) 값들의 리스트
from sklearn.metrics import 어쩌고들
roc_auc_score 용도: 주로 이진분류에서&nbsp;모델의 클래스 구분 능력을 0~1 사이 점수로 평가. 다중분류에서 쓰려면 따로 설정 필요 계산: ROC 곡선(TPR vs FPR) 아래 면적. 1: 완벽한 분류, 0.5: 랜덤 추측 수준. 특징 predict_proba()로 얻은 확률값 사용.
불균형 데이터셋에서도 신뢰성 있음.\ confusion_matrix 주로히트멥이랑같이사용
sns.heatmap(
cm,
annot =True # 각 셀에 값 표시
fmt = 'd', # 정수형으로 표시
cmap = 'Blues' # 색상
) accuracy_score : 정확도 용도: 전체 예측 중 올바른 예측 비율 계산. 계산: 주의: 클래스 불균형 시 신뢰도 떨어짐 (예: 99% Negative 데이터에서 전부 Negative로 예측 → 99% 정확도). f1_score 정밀도(Precision)와 재현율(Recall)의 조화 평균
0-1 사이, 1일수록 성능 좋음
불균형 데이터도 어느정도 ㄱㅊ classification_report precision recall f1-score support
support : 해당 클래스의 실제 데이터 개수
accuracy: 전체 데이터 중 맞춘 비율 (전체 정확도)
macro avg: 각 클래스의 지표(precision, recall, f1)를&nbsp;단순 평균 클래스 불균형이 심할 때 소수 클래스도 동등하게 반영 weighted avg: 각 클래스의&nbsp;샘플 수로 가중 평균 전체 데이터 비율을 반영, 클래스가 많은 쪽이 더 큰 영향 precision_score : 정밀도 mean_squared_error 용도: 예측값과 실제값의 평균 제곱 오차 측정.
계산: 특징: 큰 오차에 높은 패널티 (제곱 효과). 단위가 실제값과 다름 RMSE 사용 권장. rmse = mse ** 0.5 mean_absolute_error 용도 : 예측값과 실제값의 평균 절대 오차 측정. 계산: 특징 : - 이상치 영향을 덜 받음. - 단위가 실제값과 동일해 해석 용이. r2_score : "결정계수" 또는 "설명력" 용도: 모델이 데이터 분산을 얼마나 설명하는지 평가. 계산: 범위: - 1: 완벽 예측, 0: 평균 예측 수준, 음수: 모델이 평균보다 나쁨. mean_squared_log_error MSLE, 평균 제곱 로그 오차
이상치(outlier)에 덜 민감
음수 값이 있으면 사용 불가
이것도 보통 루트해서 사용 <br><img alt="assets/빅분기 2유형-1750431767097.png" src="900-자격증/assets/빅분기-2유형-1750431767097.png" target="_self">rf = RandomForestClassifier(random_state=0) f1_scores = cross_val_score(rf, train, target, cv=3, scoring='f1_macro') print(f1_scores.mean()) scoring 기본값 분류(Classification) : accuracy (정확도)
회귀(Regression) 모델 : r2 (결정계수, R-squared) pred = model.predict(test)
submit = pd.DataFrame({'pred':pred})
submit.to_csv("result.csv", index=False)
]]></description><link>900-자격증/빅분기-2유형.html</link><guid isPermaLink="false">900-자격증/빅분기 2유형.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Thu, 13 Nov 2025 13:30:22 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[빅분기 1유형]]></title><description><![CDATA[
파이썬, 판다스
# 함수기억안날때
print(help(df.dropna))
print(dir(df)) # 이게가지고잇는 속성과 함수를 볼수잇음
# 상관관계(피처간의)
df.corr(numeric_only=True) # 시리즈를 데이터프레임으로 .to_frame()
# 멀티인덱스의 시리즈접근
value = s[('US', 'Pinot Noir')] # 값 종류, 종류수
.unique() .nunique() df.drop("시즌", axis=0, inplace=True) # axis는 0이 기본이고 이건 가로를 의미함
df.to_csv('cafe2.csv', index=False) # 인덱스포함하지않겟다 # 인덱스 기준 (기본값 ascending=True)
df.sort_index(ascending=False) # 값기준 정렬 걍 컬럼이름만 잇어도됨
df.sort_values(['가격', '메뉴'],ascending=[False, True], inplace=True) # 인덱스 새로 만들기 drop=True
df.reset_index(drop=True) # [] 안에조건이 나오면 그냥이조건이 만족하는 행을구하는것임
df[df['칼로리'] &lt; 50] # 조건만족하는 행
df['A'] # 컬럼만 선택
# 조건연산자도 가능
df[cond1 &amp; cond2]
df[cond1 | cond2]
cond = df['메뉴'].isin(['녹차'])
df[cond] # 값변경
change = {'룽고':'아메리카노', '그린티':'녹차'} # {이전값:새값}
df.replace(change, inplace=True) # 값이 완전히 일치해여험
df['A'] = df['A'].str.replace('분석', '시각화') # string에서 값교체하는것과같음(부분교체가능)
# str붙는순간 널문자열로대하겟다
df['A'].str.split()
df['A'].str.contains('기본')
str.lower() str.upper() # 시리즈값확인
menu = pd.Series(['맛난버거 세트', '매운 치킨버거', '더블 치즈버거'])
menu.isin(['맛난버거 세트', '더블 치즈버거']) # 통계
print("최대값: ",df['가격'].max())
print("최소값: ",df['가격'].min())
print("평균값: ",df['가격'].mean())
print("중앙값: ",df['가격'].median())
print("합계: ",df['가격'].sum())
print("표준편차: ",df['가격'].std())
print("분산: ",df['가격'].var())
print("최빈값: ",df['원산지'].mode()[0]) #최빈값이 여러개일 수도 있으니까!!
print("최빈값의 인덱스: ",df['가격'].idxmax()) # 분위수
print("분위수 25% 값", df['가격'].quantile(.25))
print("분위수 75% 값", df['가격'].quantile(.75))
cond = df['가격'].quantile(.25) &gt; df['가격']
df[cond] # melt 여러개칼람을하나의 칼람으로 합침
# id_vars : 유지될 칼럼, value_vars 합처질 칼럼
# 기본값은 각각 'variable', 'value'입니다.
# 원래 컬럼이 name, math, eng, kor가 잇으면
pd.melt(df, id_vars=['Name'])
# 이러면 variable의 값으로(math,eng,kor)가 생김 # 그루핑 (sql생각하면될듯)
# 원두와 할인율 기준, 평균
df.groupby(['원산지']).mean(numeric_only=True) # 사진확인
ndf = df.groupby(['원산지', '메뉴']).agg(['mean', 'sum']) # 이렇게 되면 멀티인덱스됨
# groupby , agg안에꺼가 다 인덱스됨
# agg여러집계함수동시적용 # 시계열데이터
df['DateTime2'] = pd.to_datetime(df['DateTime2'], format='%Y-%m-%d %H-%M-%S')
df['year'] = df['DateTime1'].dt.year # month, day, hour, minute, second
df['DateTime1'].dt.dayofweek # 요일 0: 월요일'
df['DateTime1'].dt.to_period('Y') # Y : 연도, Q : 분기(yyyyQn) , M : yyyy-mm , D : yyyy-mm-dd ,H: 2024-06-16 13:00
# 시간차이로 계싼가능 뒤에다 s붙여야함
day = pd.Timedelta(days=99)
df['100day'] = df['DateTime4'] + day # 병합
full_menu = pd.concat([appetizer, main], axis=1) # 수평
full_menu = pd.concat([appetizer, main], ignore_index=True) # 기본 0(수직으로 병합)
# 두 데이터프레임을 'Menu'를 기준으로 병합 (innerjoin)
menu_info = pd.merge(price, cal, on='Menu') # count, size (행개수새는거)
# count &lt; 결측치 제외 , size &lt; 결측치포함 # groupby
reviews.groupby(['price']).max(numeric_only=True)
reviews.groupby('price')['points'].max().sort_index()
# 애는 point기준으로 집계 # apply
def func(row): # row는 Series, 행 전체 정보 사용 가능 return row['A'] + row['B'] df['new_col'] = df.apply(func, axis=1) # map
import pandas as pd df = pd.DataFrame({'col': ['A', 'B', 'C', 'A']}) mapping = {'A': 2, 'B': 0, 'C': 1} df['col_encoded'] = df['col'].map(mapping) print(df)
group
<img alt="assets/빅분기 1유형-1750076194068.png" src="900-자격증/assets/빅분기-1유형-1750076194068.png" target="_self">]]></description><link>900-자격증/빅분기-1유형.html</link><guid isPermaLink="false">900-자격증/빅분기 1유형.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Thu, 13 Nov 2025 13:30:22 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🏷️ 학교]]></title><description><![CDATA[학교 수업, 과제, 시험, 학업 관련 내용
<a class="internal-link" data-href="../../700-컴퓨터과학/OS-1" href=".html" target="_self" rel="noopener nofollow">OS-1)컴퓨터 시스템</a>컴퓨터%20시스템.md)
<br><a class="internal-link" data-href="../../700-컴퓨터과학/OS-2" href=".html" target="_self" rel="noopener nofollow">OS-2) 운영체제 기본과 구조</a>%20운영체제%20기본과%20구조.md)
<br><a class="internal-link" data-href="../../700-컴퓨터과학/OS-3" href=".html" target="_self" rel="noopener nofollow">OS-3) 운영체제 연산</a>%20운영체제%20연산.md)
<br><a class="internal-link" data-href="../../700-컴퓨터과학/OS-4" href=".html" target="_self" rel="noopener nofollow">OS-4) 운영체제 자원 관리</a>%20운영체제%20자원%20관리.md)
<br><a class="internal-link" data-href="../../700-컴퓨터과학/OS-5" href=".html" target="_self" rel="noopener nofollow">OS-5) 프로세스</a>%20프로세스.md)
<br><a class="internal-link" data-href="../../700-컴퓨터과학/OS-6" href=".html" target="_self" rel="noopener nofollow">OS-6) 프로세스 스케줄링</a>%20프로세스%20스케줄링.md)
<br><a class="internal-link" data-href="../../700-컴퓨터과학/OS-7" href=".html" target="_self" rel="noopener nofollow">OS-7) 프로세스 동기화</a>%20프로세스%20동기화.md)
<br><a class="internal-link" data-href="../../700-컴퓨터과학/OS-8" href=".html" target="_self" rel="noopener nofollow">OS-8) 프로세스 교착상태</a>%20프로세스%20교착상태.md)
<br><a class="internal-link" data-href="../../700-컴퓨터과학/OS-9" href=".html" target="_self" rel="noopener nofollow">OS-9) 메인 메모리 할당</a>%20메인%20메모리%20할당.md)
<br><a class="internal-link" data-href="../../700-컴퓨터과학/OS-10" href=".html" target="_self" rel="noopener nofollow">OS-10) 가상 메모리</a>%20가상%20메모리.md)
<br><a class="internal-link" data-href="../../700-컴퓨터과학/OS-11" href=".html" target="_self" rel="noopener nofollow">OS-11) 보조 저장 장치</a>%20보조%20저장%20장치.md)
<br><a class="internal-link" data-href="../../700-컴퓨터과학/OS-12" href=".html" target="_self" rel="noopener nofollow">OS-12) 파일 시스템</a>%20파일%20시스템.md) <br><a class="internal-link" data-href="../../700-컴퓨터과학/DB1 - SQL.md" href="700-컴퓨터과학/db1-sql.html" target="_self" rel="noopener nofollow">DB1 - SQL</a>
<br><a class="internal-link" data-href="../../700-컴퓨터과학/DB1 - DW&amp;DM.md" href="700-컴퓨터과학/db1-dw&amp;dm.html" target="_self" rel="noopener nofollow">DB1 - DW&amp;DM</a>
<br><a class="internal-link" data-href="../../700-컴퓨터과학/DB1 - 관계 연산.md" href="700-컴퓨터과학/db1-관계-연산.html" target="_self" rel="noopener nofollow">DB1 - 관계 연산</a>
<br><a class="internal-link" data-href="../../700-컴퓨터과학/DB1 - 종속성과 정규화.md" href="700-컴퓨터과학/db1-종속성과-정규화.html" target="_self" rel="noopener nofollow">DB1 - 종속성과 정규화</a>
<br><a class="internal-link" data-href="../../700-컴퓨터과학/DB1 - 데이터 모델링(DB 설계).md" href="700-컴퓨터과학/db1-데이터-모델링(db-설계).html" target="_self" rel="noopener nofollow">DB1 - 데이터 모델링(DB 설계)</a>
<br><a class="internal-link" data-href="../../700-컴퓨터과학/DB2 - 1(설계전 이론).md" href="700-컴퓨터과학/db2-1(설계전-이론).html" target="_self" rel="noopener nofollow">DB2 - 1(설계전 이론)</a>
<br><a class="internal-link" data-href="../../700-컴퓨터과학/DB2 - 2(설계절차).md" href="700-컴퓨터과학/db2-2(설계절차).html" target="_self" rel="noopener nofollow">DB2 - 2(설계절차)</a>
<br><a class="internal-link" data-href="../../700-컴퓨터과학/DB2 -3.md" href="700-컴퓨터과학/db2-3.html" target="_self" rel="noopener nofollow">DB2 -3</a> <br><a class="internal-link" data-href="../../700-컴퓨터과학/정보보안 - 암호화.md" href="700-컴퓨터과학/정보보안-암호화.html" target="_self" rel="noopener nofollow">정보보안 - 암호화</a>
<br><a class="internal-link" data-href="../../700-컴퓨터과학/정보보안 - 접근제어.md" href="700-컴퓨터과학/정보보안-접근제어.html" target="_self" rel="noopener nofollow">정보보안 - 접근제어</a>
<br><a class="internal-link" data-href="../../700-컴퓨터과학/정보보안 - 보안프로토콜.md" href="700-컴퓨터과학/정보보안-보안프로토콜.html" target="_self" rel="noopener nofollow">정보보안 - 보안프로토콜</a>
<br><a class="internal-link" data-href="../../700-컴퓨터과학/정보보안 - 해쉬와 기타.md" href="700-컴퓨터과학/정보보안-해쉬와-기타.html" target="_self" rel="noopener nofollow">정보보안 - 해쉬와 기타</a> <br><a class="internal-link" data-href="../../300-백엔드개발/전정프 - 7장 기초.md" href="300-백엔드개발/전정프-7장-기초.html" target="_self" rel="noopener nofollow">전정프 - 7장 기초</a>
<br><a class="internal-link" data-href="../../300-백엔드개발/전정프 - 8장 MVC.md" href="300-백엔드개발/전정프-8장-mvc.html" target="_self" rel="noopener nofollow">전정프 - 8장 MVC</a>
<br><a class="internal-link" data-href="../../300-백엔드개발/전정프 - 9장 DB 와 JDBC.md" href="300-백엔드개발/전정프-9장-db-와-jdbc.html" target="_self" rel="noopener nofollow">전정프 - 9장 DB 와 JDBC</a>
<br><a class="internal-link" data-href="../../300-백엔드개발/전정프 - 11장 특수 서블릿.md" href="300-백엔드개발/전정프-11장-특수-서블릿.html" target="_self" rel="noopener nofollow">전정프 - 11장 특수 서블릿</a>
<br><a class="internal-link" data-href="../../300-백엔드개발/전정프 - 12장 restapi.md" href="300-백엔드개발/전정프-12장-restapi.html" target="_self" rel="noopener nofollow">전정프 - 12장 restapi</a>
<br><a class="internal-link" data-href="../../300-백엔드개발/전정프 - 12장 restapi.md" href="300-백엔드개발/전정프-12장-restapi.html" target="_self" rel="noopener nofollow">전정프 - 12장 restapi</a>
]]></description><link>99-settings/2-index/🏷️-학교.html</link><guid isPermaLink="false">99-Settings/2-Index/🏷️ 학교.md</guid><pubDate>Sun, 12 Oct 2025 12:20:30 GMT</pubDate></item><item><title><![CDATA[home]]></title><description><![CDATA[MJ's Brain
지식을 체계화하기 위해 정리해 나가고 있습니다.
큰 토픽별로 분류 각 폴더로 분류 되어있습니다. 학교 수업 내용 정리 <a class="internal-link" data-href="99-Settings/2-Index/🏷️ 학교.md" href="99-settings/2-index/🏷️-학교.html" target="_self" rel="noopener nofollow">🏷️ 학교</a> 프로젝트 별 분류 <br><a class="internal-link" data-href="99-Settings/1-Topics/📖 800 프로젝트.md" href="99-settings/1-topics/📖-800-프로젝트.html" target="_self" rel="noopener nofollow">📖 800 프로젝트</a> <br>이 이전에 썼던 blog : <a rel="noopener nofollow" class="external-link is-unresolved" href="https://mj-hope.tistory.com/?page=4" target="_self">https://mj-hope.tistory.com/?page=4</a>]]></description><link>home.html</link><guid isPermaLink="false">home.md</guid><pubDate>Sun, 12 Oct 2025 12:18:02 GMT</pubDate></item><item><title><![CDATA[b_틱택톡_7682]]></title><link>600-알고리즘-&amp;-코딩테스트/problem/b_틱택톡_7682.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/b_틱택톡_7682.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Fri, 10 Oct 2025 14:46:10 GMT</pubDate></item><item><title><![CDATA[이벤트브로커 메세지브로커, 무엇이 다를까]]></title><description><![CDATA[이벤트와 메세지 브로커를 이해하기전에 브로커가 멀까? 왜 생겨났을까브로커는 한국말로 중개인이다. 즉 통신 사이에 하나의 중개자를 둬서 처리한다는 것이다.
이렇게 처리하면 각 시스템의 결합도를 낮추고 비동기적으로 실행가능하다이미지 출처 : 얄팍한 코딩사전
<img alt="이벤트브로커 메세지브로커-1758572666903.png" src="700-컴퓨터과학/assets/이벤트브로커-메세지브로커-1758572666903.png" target="_self">이벤트와 메세지의 차이를 그림으로 표현해 보았다.<br>
<img alt="이벤트브로커 메세지브로커, 무엇이 다를까-1758593841643.png" src="700-컴퓨터과학/assets/이벤트브로커-메세지브로커,-무엇이-다를까-1758593841643.png" target="_self">
메세지 어떠한 특정 데이터를 요청하거나 다른시스템에 지시 이벤트 어떤 일이 일어났다고 상태를 알림 메세지 발신자는 소비자에 대해 알고 있음
메세지 하나당 소비하는 사람이 정해져잇음 이벤트 이벤트는 특정 상태에 대한 신호
소비자가 특정되지않음
특정 채널을 구독하면 그 이벤트를보고 다른 주체가 특정일을 하는.. 위의 단어의 정의를 통해 이벤트브로커와 메세지브로커들을 정의 할 수 있다.
대표적인 메세지,이벤트 브로커인 RabbitMQ와 kafka를 기반으로 각 브로커의 차이를 설명한다.<br><img alt="이벤트브로커 메세지브로커, 무엇이 다를까-1758596642812.png" height="138" src="700-컴퓨터과학/assets/이벤트브로커-메세지브로커,-무엇이-다를까-1758596642812.png" target="_self" style="width: 483px; max-width: 100%;">
큐로 구현됨
큐에서 하나씩 빼서 소비자가 소비하게 됨 설정에 따라 유지 시킬순있음 주로 메모리에 저장됨, 유실의 위험성도 있음 설정에 따라 큐 에러처리, 메세지 삭제등 메세지에 대한 처리가 주로 브로커에서 함
<br><img alt="이벤트브로커 메세지브로커, 무엇이 다를까-1758597235016.png" height="147" src="700-컴퓨터과학/assets/이벤트브로커-메세지브로커,-무엇이-다를까-1758597235016.png" target="_self" style="width: 488px; max-width: 100%;">
디스크에 로그형태로 저장 <br>파티션단위로<a class="internal-link" data-href="../400-인프라 &amp; 아키텍처/kafka.md" href="400-인프라-&amp;-아키텍처/kafka.html" target="_self" rel="noopener nofollow">kafka</a> 각 메세지는 오프셋을 가짐
각 메세지는 소비되어도 지워지지 않음
소비자들은 채널별로 브로커의 부담이 줄어 대용량 처리에 용이함
그런데 찾다보면 같은 서비스에대해서 이벤트브로커라고도고하고 메세지브로커 라고도한다.
akka 공식문서에서 단서를 찾을 수 있었다. &nbsp;'메시지 기반'이라는 용어는 시스템의 빌딩 블록을 의미하고 '이벤트 기반'이라는 용어는 시스템의 상위 수준 속성을 의미합니다.&nbsp;그래서 메시지 기반 도구를 사용하여 이벤트 기반 시스템을 구축할 수 있습니다. <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://medium.com/riskified-technology/message-broker-vs-event-broker-when-to-use-each-one-of-them-15597320a8ba" target="_self">https://medium.com/riskified-technology/message-broker-vs-event-broker-when-to-use-each-one-of-them-15597320a8ba</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://doc.akka.io/libraries/guide/concepts/message-driven-event-driven.html" target="_self">https://doc.akka.io/libraries/guide/concepts/message-driven-event-driven.html</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://medium.com/@sukantasaha/difference-between-a-message-and-an-event-in-pub-sub-and-event-driven-architectures-c5b4975dafd6" target="_self">https://medium.com/@sukantasaha/difference-between-a-message-and-an-event-in-pub-sub-and-event-driven-architectures-c5b4975dafd6</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://happy-coding-day.tistory.com/197" target="_self">https://happy-coding-day.tistory.com/197</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://f-lab.kr/insight/message-broker-event-broker" target="_self">https://f-lab.kr/insight/message-broker-event-broker</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://medium.com/riskified-technology/message-broker-vs-event-broker-when-to-use-each-one-of-them-15597320a8ba" target="_self">https://medium.com/riskified-technology/message-broker-vs-event-broker-when-to-use-each-one-of-them-15597320a8ba</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://mycup.tistory.com/429" target="_self">https://mycup.tistory.com/429</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@beberiche/Architecture-%EB%A9%94%EC%8B%9C%EC%A7%80-%EB%B8%8C%EB%A1%9C%EC%BB%A4%EC%99%80-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%B8%8C%EB%A1%9C%EC%BB%A4-%EB%A9%94%EC%8B%9C%EC%A7%80%EC%99%80-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EA%B7%B8%EB%A6%AC%EA%B3%A0-RabbitMQ-%EC%99%80-Kafka#%EB%A9%94%EC%8B%9C%EC%A7%80-%EB%B8%8C%EB%A1%9C%EC%BB%A4%EC%99%80-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%B8%8C%EB%A1%9C%EC%BB%A4%EC%9D%98-%EC%B0%A8%EC%9D%B4" target="_self">https://velog.io/@beberiche/Architecture-%EB%A9%94%EC%8B%9C%EC%A7%80-%EB%B8%8C%EB%A1%9C%EC%BB%A4%EC%99%80-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%B8%8C%EB%A1%9C%EC%BB%A4-%EB%A9%94%EC%8B%9C%EC%A7%80%EC%99%80-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EA%B7%B8%EB%A6%AC%EA%B3%A0-RabbitMQ-%EC%99%80-Kafka#%EB%A9%94%EC%8B%9C%EC%A7%80-%EB%B8%8C%EB%A1%9C%EC%BB%A4%EC%99%80-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%B8%8C%EB%A1%9C%EC%BB%A4%EC%9D%98-%EC%B0%A8%EC%9D%B4</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.youtube.com/watch?v=0lyrd5FlETQ" target="_self">https://www.youtube.com/watch?v=0lyrd5FlETQ</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.youtube.com/watch?v=7_VdIFH6M6Q" target="_self">https://www.youtube.com/watch?v=7_VdIFH6M6Q</a>]]></description><link>700-컴퓨터과학/이벤트브로커-메세지브로커,-무엇이-다를까.html</link><guid isPermaLink="false">700-컴퓨터과학/이벤트브로커 메세지브로커, 무엇이 다를까.md</guid><pubDate>Tue, 23 Sep 2025 03:22:55 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[kafka]]></title><description><![CDATA[ 대규모 실시간 데이터를 처리하는 데 사용되는 오픈소스 분산형 이벤트 스트리밍 플랫폼
확장 ( Distributed ), 유연 ( Resilient ), 장애에 강한 ( fault tolerant ) 아키텍처를 가지고 있음
높은 처리량 컨슈머/프로듀서가 브로커와 통신할 때 데이터를 묶어서(배치) 전송
파티션 개수만큼 컨슈머를 늘려서 병렬 처리량을 늘릴 수 있음
높은 퍼포먼스 ( 10ms 미만의 지연 )– real time 확장성 데이터 양이 많아지거나 줄어짐에 따라 무중단 스케일인/아웃 가능(수평 확장)
100 개의 Broker 까지 확장
- 1초에 100만개의 메세지
- 무중단 확장 가능 영속성 파일 시스템에 데이터를 저장
브로커에 이슈가 발생하여 종료되더라도 데이터 재사용 가능 고가용성
- 일부 브로커에 이슈가 생기더라도 데이터를 지속해서 처리 가능
- 온 프레미스/퍼블릭 클라우드에 적합한 브로커 옵션 선택 가능
- 수평 확장 가능
- 100 개의 Broker 까지 확장
- 1초에 100만개의 메세지
- 무중단 확장 가능
높은 퍼포먼스 ( 10ms 미만의 지연 )– real time
<img alt="kafka-1758597611508.png" src="400-인프라-&amp;-아키텍처/assets/kafka-1758597611508.png" target="_self">
포함 관계 : 브로커 ⊃ 토픽 ⊃ 파티션
메시지를 분류하고 저장하는 기본 단위
특정 데이터 스트림, 즉 메시지를 구분 하는 통로 단톡방개념(요청들을 묶어서 분류하는 단위같은 느뀜..) 토픽으로 구분하여 원하는 메시지를 찾는 방식 pub,sub 이 토픽단위로 되는듯 이름으로 구분됨 if 회사 공용, 토픽의 오너십(ownership)을 가진 팀의 이름을 토픽 이름에 추가
개발환경 / 애플리케이션 / 데이터 타입 유추을 고려해서 지음 토픽당 데이터를 분산 처리하는 단위
메시지는 파티션에 순서대로 저장(파티션 내에선 순서가 보장된다는 것) 각각의 파티션은 0부터 1, 2, … 의 Index를 가짐
이 인덱스를 offset이라캄(파티션 내에서만 의미잇음)
FIFO 파티션 내 데이터는 변경불가
Key 를 주지 않으면 어느 파티션에 데이터가 들어갈지 모름 Kafka 클러스터를 구성하는 핵심 서버 단위(노드) 서버하나하나를 브로커라고 부른다는 뜻 각 브로커는 토픽과 파티션을 가짐
3개로 시작해서 100개까지 늘릴수 있음 브로커 관리함 브로커와 주키퍼는 DB와 DBMS관계와 같은듯 주키퍼 클러스터는 홀수로 동작 왜? 중요한 결정할때 과반수를 따름 중요한결정 aka 리더선출, 데이터쓰기 등 리더선출 노드의 리더를 선출함, 나머지는 Follower
노드에서 Leader 는 write, Follower 는 read 작업을 함
파티션의 리더선출도 도와줌 파티션의리더만 읽고쓰기가능
나머진 ISR(In Sync Replica)역할 &nbsp;리더의 데이터를 체크하여 복제하고, 리더가 장애시 리더 역할함 분산락(유노? 프로세스 데이터접근할때 햇던 그거임) 다아 일관성이랑 무결성을 유지하기위한~ 서비스 디스커버리 서비스가 어디서 실행 중인지 중앙에서 관리
상태관리를한다는거임 상태가 변경되면 알림을 줌 like ( 토픽 생성, 브로커 die, 브로커 up, 토픽 삭제 ) 주요 설정 Topic Replication factor 토픽을 몇개 복제해놓을건데를 정하는
리소스량은 증가 &lt;-&gt; 안정성도 증가 말그대로 메세지를 만들어 토픽으로 보내는 것들 애플리케이션, 서버등 주요 설정 key : 설정해 메세지를 특정 파티션에 보낼 수 있음 약간순서 보장필요할때 이거쓰면될듯?
키옵션 ㄴㄴ일땐 라운드로빈방식으로 균등하게 ack : 메세지 저장 확인 응답관련설정 0 : 응답기다리지 않음 &gt; 빠르지만 안정성구림
1 : 프로듀서는 리더의 응답만 체크 &gt; 적당함
all / -1 : 모든 파티션의 응답 확인 메세지를 쓰는 것들
&nbsp;Kafka는 Consumer Group 단위로 데이터를 처리 Consumer Group 은 당연히 컨슈머를 묶은거 Message Lagging이 높을 경우, 컨슈머를 증가시킴 데이터베이스의 변경 사항(삽입, 수정, 삭제)을 실시간으로 감지해서 다른 시스템으로 전달하는 기술
실시간 스트리밍 데이터 파이프라인을 구축하는 데 사용
MSA에서 이벤트 중심 메시징 시스템의 구현을 위해 사용
실시간 로그 수집에사용
실시간 스트리밍서비스에서 사용
Spark, Storm, Flink, Hadoop 등 많은 빅데이터 기술과 통합하여 사용
&nbsp;kafka-topics --bootstrap-server http://localhost:9092 --topic example --describe kafka-topics --bootstrap-server http://localhost:9092 --list --exclude-internal kafka-topics --bootstrap-server http://localhost:9092 --topic aivle --create --partitions 1 --replication-factor 1
]]></description><link>400-인프라-&amp;-아키텍처/kafka.html</link><guid isPermaLink="false">400-인프라 &amp; 아키텍처/kafka.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Tue, 23 Sep 2025 03:20:12 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[kafka-1758597611508]]></title><description><![CDATA[<img src="400-인프라-&amp;-아키텍처/assets/kafka-1758597611508.png" target="_self">]]></description><link>400-인프라-&amp;-아키텍처/assets/kafka-1758597611508.html</link><guid isPermaLink="false">400-인프라 &amp; 아키텍처/assets/kafka-1758597611508.png</guid><pubDate>Tue, 23 Sep 2025 03:20:11 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[kafka-1758597598591]]></title><description><![CDATA[<img src="400-인프라-&amp;-아키텍처/assets/kafka-1758597598591.png" target="_self">]]></description><link>400-인프라-&amp;-아키텍처/assets/kafka-1758597598591.html</link><guid isPermaLink="false">400-인프라 &amp; 아키텍처/assets/kafka-1758597598591.png</guid><pubDate>Tue, 23 Sep 2025 03:19:58 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[이벤트브로커 메세지브로커, 무엇이 다를까-1758597235016]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/이벤트브로커-메세지브로커,-무엇이-다를까-1758597235016.png" target="_self">]]></description><link>700-컴퓨터과학/assets/이벤트브로커-메세지브로커,-무엇이-다를까-1758597235016.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/이벤트브로커 메세지브로커, 무엇이 다를까-1758597235016.png</guid><pubDate>Tue, 23 Sep 2025 03:13:55 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[이벤트브로커 메세지브로커, 무엇이 다를까-1758597217598]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/이벤트브로커-메세지브로커,-무엇이-다를까-1758597217598.png" target="_self">]]></description><link>700-컴퓨터과학/assets/이벤트브로커-메세지브로커,-무엇이-다를까-1758597217598.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/이벤트브로커 메세지브로커, 무엇이 다를까-1758597217598.png</guid><pubDate>Tue, 23 Sep 2025 03:13:37 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[이벤트브로커 메세지브로커, 무엇이 다를까-1758596642812]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/이벤트브로커-메세지브로커,-무엇이-다를까-1758596642812.png" target="_self">]]></description><link>700-컴퓨터과학/assets/이벤트브로커-메세지브로커,-무엇이-다를까-1758596642812.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/이벤트브로커 메세지브로커, 무엇이 다를까-1758596642812.png</guid><pubDate>Tue, 23 Sep 2025 03:04:02 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[이벤트브로커 메세지브로커, 무엇이 다를까-1758593841643]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/이벤트브로커-메세지브로커,-무엇이-다를까-1758593841643.png" target="_self">]]></description><link>700-컴퓨터과학/assets/이벤트브로커-메세지브로커,-무엇이-다를까-1758593841643.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/이벤트브로커 메세지브로커, 무엇이 다를까-1758593841643.png</guid><pubDate>Tue, 23 Sep 2025 02:17:21 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[이벤트브로커 메세지브로커, 무엇이 다를까-1758593737339]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/이벤트브로커-메세지브로커,-무엇이-다를까-1758593737339.png" target="_self">]]></description><link>700-컴퓨터과학/assets/이벤트브로커-메세지브로커,-무엇이-다를까-1758593737339.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/이벤트브로커 메세지브로커, 무엇이 다를까-1758593737339.png</guid><pubDate>Tue, 23 Sep 2025 02:15:37 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[이벤트브로커 메세지브로커-1758574508326]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/이벤트브로커-메세지브로커-1758574508326.png" target="_self">]]></description><link>700-컴퓨터과학/assets/이벤트브로커-메세지브로커-1758574508326.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/이벤트브로커 메세지브로커-1758574508326.png</guid><pubDate>Mon, 22 Sep 2025 20:55:08 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[이벤트브로커 메세지브로커-1758572666903]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/이벤트브로커-메세지브로커-1758572666903.png" target="_self">]]></description><link>700-컴퓨터과학/assets/이벤트브로커-메세지브로커-1758572666903.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/이벤트브로커 메세지브로커-1758572666903.png</guid><pubDate>Mon, 22 Sep 2025 20:24:26 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[📚 404 마이크로서비스(MSA)]]></title><description><![CDATA[마이크로서비스 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 400 인프라 &amp; 아키텍처" href="99-settings/1-topics/📖-400-인프라-&amp;-아키텍처.html" class="internal-link" target="_self" rel="noopener nofollow">📖 400 인프라 &amp; 아키텍처</a>
]]></description><link>99-settings/1-topics/📚-404-마이크로서비스(msa).html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 404 마이크로서비스(MSA).md</guid><pubDate>Mon, 22 Sep 2025 10:40:07 GMT</pubDate></item><item><title><![CDATA[📖 400 인프라 & 아키텍처]]></title><description><![CDATA[인프라 &amp; 아키텍처 관련 학습 내용을 담는 토픽입니다.
<a data-href="📚 401 Docker &amp; Kubernetes" href="99-settings/1-topics/📚-401-docker-&amp;-kubernetes.html" class="internal-link" target="_self" rel="noopener nofollow">📚 401 Docker &amp; Kubernetes</a>
<br><a data-href="📚 402 AWS &amp; 클라우드" href="99-settings/1-topics/📚-402-aws-&amp;-클라우드.html" class="internal-link" target="_self" rel="noopener nofollow">📚 402 AWS &amp; 클라우드</a>
<br><a data-href="📚 403 시스템 설계" href="99-settings/1-topics/📚-403-시스템-설계.html" class="internal-link" target="_self" rel="noopener nofollow">📚 403 시스템 설계</a>
<br><a data-href="📚 404 마이크로서비스(MSA)" href="99-settings/1-topics/📚-404-마이크로서비스(msa).html" class="internal-link" target="_self" rel="noopener nofollow">📚 404 마이크로서비스(MSA)</a>
<br><a data-href="📚 405 모니터링 &amp; 로깅" href="99-settings/1-topics/📚-405-모니터링-&amp;-로깅.html" class="internal-link" target="_self" rel="noopener nofollow">📚 405 모니터링 &amp; 로깅</a>
<br><a data-href="📚 406 CI/CD" href=".html" class="internal-link" target="_self" rel="noopener nofollow">📚 406 CI/CD</a>
<br><a data-href="📚 407 네트워크 &amp; 보안" href="99-settings/1-topics/📚-407-네트워크-&amp;-보안.html" class="internal-link" target="_self" rel="noopener nofollow">📚 407 네트워크 &amp; 보안</a>
<br><a data-href="📚 408 스케일링" href="99-settings/1-topics/📚-408-스케일링.html" class="internal-link" target="_self" rel="noopener nofollow">📚 408 스케일링</a>
]]></description><link>99-settings/1-topics/📖-400-인프라-&amp;-아키텍처.html</link><guid isPermaLink="false">99-Settings/1-Topics/📖 400 인프라 &amp; 아키텍처.md</guid><pubDate>Mon, 22 Sep 2025 10:40:04 GMT</pubDate></item><item><title><![CDATA[다른 서비스의 데이터가 필요할 때]]></title><description><![CDATA[성과분석 서비스에서 sns에서 성과분석을 하기위한 데이터를 매일 밤11시에 수집하도록 설계했다. 이때 sns서비스의 모든 유저계정,모든 게시물정보가 필요했다.<img alt="다른 서비스의 데이터가 필요할 때-1757923292109.png" src="300-백엔드개발/assets/다른-서비스의-데이터가-필요할-때-1757923292109.png" target="_self">
장점 분석서비스에서 별도의 디비가 필요없음 단점
- 모든 유저와 게시물에 대해 받아야함
- But, 한번에 이벤트 발행해서 모든 데이터값을 얻기힘듬
- 이벤트는 최대 1mb만큼만 전송가능
- Therefore, n개단위로 잘라서 받아야함
- 이벤트 발행 개수 : 올림( total / n) * 2 매일 모든 데이터를 다른서비스에서 가져오는 것은 비효율적이고 이서비스에도 부하를 일으킨다고 생각됨 <br><img alt="다른 서비스의 데이터가 필요할 때-1757923953865.png" src="300-백엔드개발/assets/다른-서비스의-데이터가-필요할-때-1757923953865.png" target="_self">
장점 sns-service에 부하가 준다
이벤트발행횟수가 압도적으로 준다
데이터 얻기까지의 속도가 빠르고 간결하다 단점 sns서비스의 디비와 일관성 있게 유지해야한다 일시적인 불일치 발생
혹은 이를 보완하기 위한 다른 추가 설정이나 로직을 짜야한다. <br><a data-href="../400-인프라 &amp; 아키텍처/MSA 데이터 불일치" href="400-인프라-&amp;-아키텍처/msa-데이터-불일치.html" class="internal-link" target="_self" rel="noopener nofollow">../400-인프라 &amp; 아키텍처/MSA 데이터 불일치</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://curiousjinan.tistory.com/entry/kafka-message-delivery-guarantees" target="_self">https://curiousjinan.tistory.com/entry/kafka-message-delivery-guarantees</a> 분석서비스에 중복디비를 구성하는 방식을 정하였다.
매 성과분석마다 on demand방식으로 요청받아 처리하는 것이 사용자가 많아질 시 등비수열 형태로 크게 늘어날 것이다.
자주 바뀌는 데이터가 아님을 감안하면 중복 디비 만들때와의 부하차이가 매우 크다 현재 user와 게시물관련 id 값, 타입등을 받는다. 즉 update도 일어나지 않는다.(create or delete) 빠르게 적용되어야할 필요도 없다
]]></description><link>300-백엔드개발/다른-서비스의-데이터가-필요할-때.html</link><guid isPermaLink="false">300-백엔드개발/다른 서비스의 데이터가 필요할 때.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 22 Sep 2025 10:40:04 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[MSA 장단점]]></title><link>400-인프라-&amp;-아키텍처/msa-장단점.html</link><guid isPermaLink="false">400-인프라 &amp; 아키텍처/MSA 장단점.md</guid><pubDate>Wed, 17 Sep 2025 15:06:34 GMT</pubDate></item><item><title><![CDATA[MSA 데이터 불일치]]></title><link>400-인프라-&amp;-아키텍처/msa-데이터-불일치.html</link><guid isPermaLink="false">400-인프라 &amp; 아키텍처/MSA 데이터 불일치.md</guid><pubDate>Mon, 15 Sep 2025 08:27:44 GMT</pubDate></item><item><title><![CDATA[DB1 - 종속성과 정규화]]></title><description><![CDATA[데이터베이스 스키마는 데이터베이스의 테이블, 열 및 해당 유형을 정의함
애트리뷰트 엔티티 관계성을 파악, 제약조건(종속성을 수집)
관련 애트리뷰트를 릴레이션으로 분할하고 묶음 = 스키마 변환 애트리뷰트간의관계성: 데이터 종속성
효율적인 데이터 처리
데이터의 일관성 변칙적 성질 예방 - 이상 정보 표현의 무손실
최소의 데이터 중복
분리의 원칙 : 독립된 관계성은 별도로 분리시켜 표현
하나의 개체에 속한 속성간에 존재하는 여러개의 종속관계를 하나의 릴래이션으로 표현하기 때문속성들 간의 여러 종속관계를 분해하여 각각 하나의 릴레이션으로 표현
=&gt; 정규화 : 잘못된 스키마 정의를 바로 잡는 db설계 방법EX) 한 릴레이션에 학번, 과목번호, 성적, 학년이 있을 때! 기본키: 학번,과목연쇄 삭제에 의한 정보 손실
한 학번이 과목 등록을 취소햇을 시 -&gt; 학년의 정보도 삭제됨!원하지 않은 정보 강제 삽입
한 학생이 2학년이라는 사실 만 삽입하고 싶을 때 불가능중복데이타의 일부 갱신으로 정보의 모순성이 발생
한 학생의 학년을 4에서 3으로 변경 -&gt; 해당학생의 투플을 모두 변경해야함.릴레이션 R과 R의 속성중에 하나인 X,Y 가있음
X의 각각 값에 대해 Y 값이 하나만 있을 때가 함수종속이라함.
X에 의해 Y값이 정해진다.
X-&gt;Y로 표현, X: 결정자 Y: 종속자
X,Y는 속성의 집합이 될 수 있음
고로 PK는 그외의 속성 집합에 대해 함수종속ㅋ
근데 X가 키는 아님: X 값 20 이고 Y 값 40 인 튜플이 두개 수 있다는 것임수강(학번, 과목번호, 학년, 성적) : PK{학번,과목번호}
{학번,과목번호} -&gt; 성적
학번 - &gt; 학년
<img alt="assets/스크린샷 2023-12-19 오후 11.38.43.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-19-오후-11.38.43.png" target="_self" style="width: 400px; max-width: 100%;">결정자집합에서 머하나 빼면 함수종속이 아니게되는것
X’ ⊂ X 이고 X’ -&gt; Y 가 성립되는 애트리뷰트 X'이 존재하지 않는 경우결정자 집합 중속성하나 자체도 함수종속이 되는것.
X’ ⊂ X 이고 X’ -&gt; Y 가 성립되는 애트리뷰트 X'이 존재하는 경우
위의 예시로보면 학년은 {학번,과목번호}에 부분종속일련의 제약조건을 만족하는 릴레이션
정규화 과정에서 릴레이션이 만족해야하는 특정한 함수 종속성의 충족 요건
정규화 : 스키마 변환으로 정규형을 만듬
정보 표현의 무손실 같은 의미의 정보 유지
효율적인 구조 최소 데이터 중복
분리의 원칙 독립적인 관계는 별개의 릴레이션으로 표현 3NF이상이면 충분<br>
<img alt="assets/스크린샷 2023-12-20 오전 1.57.07.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-1.57.07.png" target="_self" style="width: 400px; max-width: 100%;"><br>
<img alt="assets/스크린샷 2023-12-20 오전 2.00.20.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-2.00.20.png" target="_self" style="width: 400px; max-width: 100%;">
정규형에 쓸 예시(1NF의 상태임)
수강지도(학번,지도교수,학과,과목번호,성적)
기본키 : {학번, 과목번호}<br>
<img alt="assets/스크린샷 2023-12-20 오전 12.53.09.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-12.53.09.png" target="_self" style="width: 300px; max-width: 100%;"><br>
<img alt="assets/스크린샷 2023-12-20 오전 12.53.01.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-12.53.01.png" target="_self" style="width: 400px; max-width: 100%;">모든 도메인(속성)이 원자값으로만 된 릴레이션
삽입이상 : 500번 학번의 지도교수를 삽입할때 과목과성적을 넣어야만함
삭제이상 : 200번학생이 C123등록 취소하여 튜플 삭제시 지도교수 정보까지삭제
갱신이상 : 400번학생의 지도교수를 변경시 튜플 4개를 다바꿔야함
원인 기본키로 식별되는 개체와 무관한 애트리뷰트가 존재 = 독립적인 속성이 하나의 릴레이션으로 표현
1NF에서 부분함수 종속을 제거 : 프로덱션으로
다이어그램으로 생각하면 사각형에 화살표 뻗어나가는 박스끼리 분리
지도(학번,지도교수,학과) PK:학번
수강(학번, 과목번호, 성적) PK{학번(FK), 과목번호}<br>
<img alt="assets/스크린샷 2023-12-20 오전 1.10.53.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-1.10.53.png" target="_self" style="width: 500px; max-width: 100%;"><br>
<img alt="assets/스크린샷 2023-12-20 오전 1.11.34.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-1.11.34.png" target="_self" style="width: 300px; max-width: 100%;"><br><img alt="assets/스크린샷 2023-12-20 오전 1.06.59.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-1.06.59.png" target="_self" style="width: 300px; max-width: 100%;">
. 조인을통해서 1NF모형을 고대로 얻을 수 있음.
1NF에서 2NF의 정보를 모두 얻을 수 없음(2NF가 더 많을 수 있음)
삽입이상 : 어떤 지도가 특정 학과에 속하는사실이 삽입 불가능
삭제이상 : 300번 학생의 튜플 삭제시 지도교수가 어떤학과에 속한다는 정보상실
갱신이상 : 지도교수 소속을 변경시 학번튜플 여러개를 변경해야함
원인 : 이행적 함수 종속이 존재 X → Y (X가 Y를 결정한다, Y → Z (Y가 Z를 결정한다)
꼬리에 꼬리를 무는 함수 종속 이행적 함수 종속 분리 : 꼬리에 꼬리를 무는 화살표제거<br>
<img alt="assets/스크린샷 2023-12-20 오전 1.24.54.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-1.24.54.png" target="_self" style="width: 500px; max-width: 100%;"><br><img alt="assets/스크린샷 2023-12-20 오전 1.24.21.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-1.24.21.png" target="_self" style="width: 300px; max-width: 100%;">키가 아닌 애트리뷰트 값 갱신시 불필요한 이상은 발생하지 않음
복수의 후보키 가지고 잇음
후보는 두개이상의 속성으로 구성
후보키의 속성이 서로 중첩<br>
<img alt="assets/스크린샷 2023-12-20 오전 1.28.57.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-1.28.57.png" target="_self" style="width: 400px; max-width: 100%;"> 이때의 상태이상 삽입이상 : 교수 어떤 과목을 담당하는 정보를 넣을때 학번이 있어야함
삭제이상 : 학생이 과목취소하면 교수정보까지 날아감
갱신이상 : 교수가 과목을 바꾸면 해당 정보를 담고잇는 모든 튜플을 바꿔야함 원인 : 교수가 결정자지만 후보키가 아님
= 강한 3NF
⊃ 1NF, 2NF ,3NF
한 릴레이션의 결정자가 모두 후보키면 BCNF에 속함<br>
<img alt="assets/스크린샷 2023-12-20 오전 1.49.01.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-1.49.01.png" target="_self" style="width: 500px; max-width: 100%;">
3NF여도 기본키 속성이 기본키 속성이 아닌 일반속성에 종속적일 때 BCNF정규형에 위반
문제풀어보기<br>
<img alt="assets/Pasted image 20231220015605.png" src="700-컴퓨터과학/assets/pasted-image-20231220015605.png" target="_self">
BCNF에 속하고 모든 MVD가 FD다.(MVD가 없어도 됨.)
어떤 릴레이션 R이 4NF이라면 MVD가 없거나, MVD A B|C가 있을 경우 A에 대응되는 B와 C의 값은 하나씩 이어야 하며 이때 A는 후보키라는것을 의미한다.
특정 속성 A가 속성 B의 값의 집합을 결정한다.<br>
<img alt="assets/스크린샷 2023-12-20 오전 2.10.58.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-2.10.58.png" target="_self" style="width: 300px; max-width: 100%;">
모든 FD는 MVD이다.<br>
<img alt="assets/스크린샷 2023-12-20 오전 2.13.44.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-2.13.44.png" target="_self" style="width: 500px; max-width: 100%;">R에 존재하는 모든 조인 종속이 R의 후보키를통해 성립됨
SC, CP ,PS : 어떠한 조인 종속 포함 ㄴㄴ == 5NF
4NF
FD나 MVD가 존재하지 않음
어떤 공급자가 어떤 부붐을 어떤 프로젝트에 공급<br>
<img alt="assets/Pasted image 20231220022054.png" src="700-컴퓨터과학/assets/pasted-image-20231220022054.png" target="_self" style="width: 500px; max-width: 100%;">
이 SN, CP ,PS를 다 각각의 릴레이션으로 만듬
=&gt; 2개의 조인만으로 SCP를 재생성 ㄴㄴ == 3개를 조인해야함 == 3-way순환 제약 조건
n-way 순환 제약 조건을 만족
n개의 프로젝션만으로만 무손실 분해 가능 == n개보다 적으면 무손실 분해 불가능몇 개의 부분 테이블로 분해한 후, 이 부분 테이블들을 다시 조인했을 때 원래의 테이블과 동일하게 복원
MVD ㅣ JD(2 분해)
SCP == 역정규화
분해된릴레이션을 역으로 통합 -&gt; 성능향상
높은 정규형을 만족하는게 최적은아님 정합성과 무결성이 강화되지만
SQL문 복잡, 조인연산 과다 -&gt; 실행시간 오래걸림 중복하여추가
릴레이션의 병합
같은 속성을 중복추가
파생속성 추가
]]></description><link>700-컴퓨터과학/db1-종속성과-정규화.html</link><guid isPermaLink="false">700-컴퓨터과학/DB1 - 종속성과 정규화.md</guid><pubDate>Sun, 21 Sep 2025 18:22:36 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[DB1 - 데이터 모델링(DB 설계)]]></title><description><![CDATA[현실 -&gt; 개념적 구조 -&gt; 논리적(데이터) 구조
<img alt="assets/스크린샷 2023-12-20 오전 2.40.35.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-2.40.35.png" target="_self" style="width: 500px; max-width: 100%;">
개념적 모델링 (개념적 설계)
현실세계를 추상적개념, 개체타입으로 표현
데이터 모델링 (논리적 설계)
개념적 구조를 논리적 개념,레코드타입으로 표현
데이터 구조화 (물리적 설계)
논리적 구조를 물리적 구조로 표현D = &lt; S, O, C&gt;
S : 구조
데이터의 정적 성질
개체 타입과 이들간의 관계를 명세
O : 연산
데이터의 동적 성질
개체 인스턴스를 처리하는 작업에 대한 명세
데이터 조작 기법
C : 제약 조건
인스턴스의 존재 조건
의미상 제약
데이터 조작의 한계를 표현하는 명세속성으로 기술된 개체타입 &amp; 관계 를 이용하여 현실세계 표현
기본 원리 : 추상화 = 집단화(속성)+ 일반화(상위 클래스)
트랜잭션모델링 :트랜잭션( 검색 갱신 혼합)이 필요로하는 정보가 포함되는지 확인
표현력(expressiveness): 개체 타입, 관계성, 제약조건 단순성( simplicity): 이해와 사용이 단순 최소성(minimality): 작은 수의 기본 개념만 사용 다이어그램식 표현: 시각적이고 종합적
공식성(formality): 공식적 명세를 위해 모호하지 않고 정확 독립성(independency): DBMS에 독립적
융통성(flexibility): 변경을 수용 능력 뷰통합방법 (일반화))
속성 합성방법 ( 집단화) 개체 : 특정 존재 하나하나 홍길동 , 디비, 자동차 개체 집합 : 공통 속성을 갖는 개체를 모아 둔것 {홍길동, 홍장미 ,홍미림} 개체 타입 : 같은 속성을 갖는 개체집합의 추상적 표현 학생 관계 : 개체와 개체 사이의 연관성을 의미
관계 집합 : 개체집합 사이에 실제로 맺어지는 모든 관계인스턴스
관계 타입 : 개체타입 사이에 모든 관계를 추상화 하여 포현 (사상)
<br><img alt="assets/스크린샷 2023-12-20 오전 2.53.06.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-2.53.06.png" target="_self">
E-R 모델에서의 개체 = 개체타입 : 속성을 포함하는 추상적 개념
속성 : 개체 또는 관계가 갖는 고유한 특성
값 복수 여부
단일 값 속성 : 한 개체에 대해 속성이 갖는 값 하나
다중 값 속성 : 한 개체에 대해 속성이 갖는 값 여러개<br>
<img alt="assets/스크린샷 2023-12-20 오전 3.00.06.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.00.06.png" target="_self" style="width: 200px; max-width: 100%;">
의미 분해 여부
단순 속성 : 의미적으로 더 이상 분해할 수 없는 속성
복합 속성 : 의미적으로 더 분해 가능한 속성<br>
<img alt="assets/스크린샷 2023-12-20 오전 3.02.11.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.02.11.png" target="_self" style="width: 200px; max-width: 100%;">
값 저장여부
저장속성 : 실제 값을 저장하는 속성
유도속성 : 값을 저장하지 않앗도 다른 속성 값에서 계산되거나 유도될 수 있는 속성<br>
<img alt="assets/스크린샷 2023-12-20 오전 3.04.26.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.04.26.png" target="_self" style="width: 150px; max-width: 100%;">
식별 여부
키속성 : 각 개체를 유일하게 식별할 수 있는 고유한 값을 갖는 속성
일반속성<br>
<img alt="assets/스크린샷 2023-12-20 오전 3.04.44.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.04.44.png" target="_self" style="width: 150px; max-width: 100%;">
관계 : 관계타입을 여기선 관계라함두 개체 집합간의 사상형대를 정의
최대 사상수
1:1
1:n
n:1
m:n
링크에 숫자나 문자 적어서 표시
최소 사상수
최소값이 1(= 전체 참여)<br>
<img alt="assets/스크린샷 2023-12-20 오전 3.12.26.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.12.26.png" target="_self" style="width: 200px; max-width: 100%;">
최소값이 0(=부분 참여)<br>
<img alt="assets/스크린샷 2023-12-20 오전 3.13.00.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.13.00.png" target="_self" style="width: 200px; max-width: 100%;">
1진 관계(= 순환 관계)<br>
<img alt="assets/스크린샷 2023-12-20 오전 3.22.25.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.22.25.png" target="_self" style="width: 200px; max-width: 100%;">
2진 관계<br>
<img alt="assets/스크린샷 2023-12-20 오전 3.22.44.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.22.44.png" target="_self" style="width: 300px; max-width: 100%;">
3진 관계<br>
<img alt="assets/스크린샷 2023-12-20 오전 3.23.03.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.23.03.png" target="_self" style="width: 300px; max-width: 100%;">종속 여부
비식별 관계 : 대등한 관계 맺을 때 (이중 마름모로 표시)
식별 관계 : 종속적인 관계를 맺는 경우<br>
<img alt="assets/스크린샷 2023-12-20 오전 3.27.46.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.27.46.png" target="_self" style="width: 500px; max-width: 100%;">
강계체 : 고유하게 식별할 수 있는 속성 있음(PK)
약개체 : 자신을 고유하게 식별할 수 있는 속성 없음(부분키는 존재)
식별 관계의 종속자 : 약 개체
상하관계 여부
일반화 관계(IS-A 관계)<br>
<img alt="assets/스크린샷 2023-12-20 오전 3.30.04.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.30.04.png" target="_self" style="width: 300px; max-width: 100%;">
상위 개체 : 공통적으로 갖는 속성 표현
하위 개체 : 고유속성만 표현필드 &amp; 레코드 타입
개념과 관계 속성을
릴레이션과 필드로 변환한다.1개체 = 1릴레이션
개체의 키속성 = 릴레이션의 PK
1:n 비식별 관계 : 하나의 외래키로 변환가능(1인곳이 참조됨)<br>
<img alt="assets/스크린샷 2023-12-20 오전 4.09.40.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-4.09.40.png" target="_self" style="width: 400px; max-width: 100%;">
식별관계 : 1쪽에서 외래키 참조, 약개체에서는 외래키+ 부분키 하여 PK를 생성<br>
<img alt="assets/스크린샷 2023-12-20 오전 4.12.11.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-4.12.11.png" target="_self" style="width: 400px; max-width: 100%;">
순환 관계 : 하나의 외래키 속성으로 변환, 실제로 물리적으론 하나임<br>
<img alt="assets/스크린샷 2023-12-20 오전 4.15.52.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-4.15.52.png" target="_self" style="width: 500px; max-width: 100%;"> 1:1 한쪽 개체만 전체 참여 : 전체참여하는곳에 FK 추가<br>
<img alt="assets/스크린샷 2023-12-20 오전 4.39.17.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-4.39.17.png" target="_self" style="width: 500px; max-width: 100%;">
양쪽 개체 모두 부분참여 : 서로 FK로 추가해도되고 어느한쪽만 추가해도됨
양쪽 개체 모두 전체참여 : 양쪽에 FK추가하거나 릴레이션을 합침 m:n 관계를 하나의 릴레이션으로, 관계 릴레이션에 양쪽 개체를 외래키 속성으로 그조합을 새로운 기본키로 다중값 속성이다 하나의 릴레이션으로 분리하여 변환: 분리전 개체를 외래키로 + 속성 = 기본키
속성이름만 다르게 해서 속성리스트를 추가<br>
<img alt="assets/스크린샷 2023-12-20 오전 4.46.41.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-4.46.41.png" target="_self" style="width: 500px; max-width: 100%;"> 복합속성 : 가장하위 속성만 릴레이션 속성으로
유도속성 : 변환에서 제외 상위개체와 하위개체를 모두 다른릴레이션 하위개체 FK로 상위개체의 기본키를 가져옴
모두 기본키 속성이없으면 외래키 속성을 기본키로 3개를 다 상위 개체 해당된는 하나의 릴레이션으로 하위 관계는 속성으로
하위 개체에해당하는 2개의 릴레이션으로 변환 상위 개체 속성은 각각 릴레이션에 모두포함.
모두 기본키 속성이없으면 상위 개체 키를 기본키로 영문 변환
뷰생성
인덱스 생성
내부 자동생성열 생성 요구조건 분석 -&gt; 설계 -&gt; 구현 -&gt; 운영 -&gt; 감시 및 개선 (다시 앞으로)요구사항 분석 -&gt; 개념적 설계 -&gt; 논리적 설계 -&gt; 물리적 설계 -&gt; 구현 (다시앞으로)
요구사항 분석 : 구현범위 사용자 범주결정, 분석후 명세로로데이터중심 DB 설계
처리중심 DB 설계
무결성 : 제약조건
일관성
회복
보안
효율성
db 성장 : 확대
<br><img alt="assets/스크린샷 2023-12-20 오전 3.32.10.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.32.10.png" target="_self">9장함다시봐야함.ㅇ.예시를 직접변환해보샘]]></description><link>700-컴퓨터과학/db1-데이터-모델링(db-설계).html</link><guid isPermaLink="false">700-컴퓨터과학/DB1 - 데이터 모델링(DB 설계).md</guid><pubDate>Sun, 21 Sep 2025 18:21:04 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[DB1 - 관계 연산]]></title><description><![CDATA[
관계형 DB에서 릴레이션을 조작하기 위한 연산 실제 사용할 수 있는 데이터 언어는 아님
SQL 언어나 내부처리의 이론적 기반을 제공 사용자가 필요로 하는 데이터를 획득하는 절차(HOW)
== 연산의 적용 순서를 명세
== 절차적 표현 방법 릴레이션을 내부적으로 처리하기 위한 연산의 집합. SQL의 이론적 토대를 제공 패쇄 성질 피연산자와 연산결과 모두 릴레이션
중첩된 수식표현이 가능 릴레이션을 집합으로 간주하여 이를 처리하는 연산 그룹
합집합 UNION ∪
교집합 INTERSECT ∩
차집합 DIFFERENCE - 카티션 프러덕트 CARTESIAN PRODUCT x 릴레이션 R1과 R2의 각튜플을 서로 연결하여 만들어진 모든 튜플의 조합을 반환
두릴레이션의 모든 튜플을 수평적으로 결합하는 연산 (행렬의 곱과 비슷)
<img alt="assets/스크린샷 2023-12-06 오후 3.19.28.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-06-오후-3.19.28.png" target="_self" style="width: 500px; max-width: 100%;"> ∪, ∩, - : 합병가능 단 차수(속성의 개수)가 같아야함
대응 속성 쌍별로 도메인이 같아야함. ∪, ∩, × : 결합적, 교환적(집합에서 하던 결합법칙 교환법칙과 같음)
릴레이션의 구조적 특성에 기반을 둔 연산을 포함
관계형 데이터 모델을 위해 고안된 연산<br>
<img alt="assets/스크린샷 2023-12-06 오후 8.27.16.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-06-오후-8.27.16.png" target="_self"> 셀렉트 σ 선택 조건을 만족하는 릴레이션의 "수평적" 부분집합
데이터 언어 : R WHERE 조건식
선택도 : select 조건에 의해 검색되는 튜플의 비율 프로젝트 Π 릴레이션의 "수직적" 부분집합
결과에 튜풀이 중복시 제거<br>
<img alt="assets/스크린샷 2023-12-06 오후 8.29.19.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-06-오후-8.29.19.png" target="_self" style="width: 300px; max-width: 100%;"> 조인 ⋈ 두 릴레이션의 공통속성 기준으로 조건을 만족시 수평적으로 결합
<br>동등조인 아닌 세타조인은 조건있는 카디션 프러덕트 느낌 인것같다.<img alt="assets/스크린샷 2023-12-06 오후 8.42.43.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-06-오후-8.42.43.png" target="_self"> 디비전 ÷ 특정 값을 모두 찾고 있는 튜플을 찾는 연산
R1÷R2 일시 R1이 R2의 모든 속성을 포함하고 있어야함 <br>R1 투플중 R2에 속한 속성을 제외한 나머지 속성값을 구성된 릴레이션.<img alt="assets/스크린샷 2023-12-06 오후 9.40.01.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-06-오후-9.40.01.png" target="_self"> 개명연산 ρ 중간처리 결과 이름을 지정하거나 애트리뷰트 이름을 변경할 때 사용 다른 연산으로 대체 불가능
∪(합집합), −(차집합), ×(카티션 프로덕트), σ(셀렉트), Π(프로젝트) 대체 가능
∩(교집합), ⋈(조인), ÷(디비전)
이후 예시를 위한 릴레이션<br>
<img alt="assets/스크린샷 2023-12-07 오후 9.30.22.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-07-오후-9.30.22.png" target="_self" style="width: 400px; max-width: 100%;">
자연 조인 ⋈n<br>
<img alt="assets/스크린샷 2023-12-07 오후 9.31.12.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-07-오후-9.31.12.png" target="_self" style="width: 200px; max-width: 100%;">
세미 조인 ⋉/⋊<br>
<img alt="assets/스크린샷 2023-12-07 오후 9.34.48.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-07-오후-9.34.48.png" target="_self" style="width: 200px; max-width: 100%;"> R⋉S: S 와 자연조인이 가능한 R 투플의 집합. R에 흡수된느뀜
R ⋉ S ≠ S ⋉ R R⋈nS ＝ (R ⋉ S) ⋈n S ＝ (S ⋉ R) ⋈n R 외부 조인 ⋈+/⋉+/⋊+<br>
<img alt="assets/스크린샷 2023-12-07 오후 9.39.37.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-07-오후-9.39.37.png" target="_self" style="width: 200px; max-width: 100%;"> 조인시 대응되는 튜플이 없을 경우에도 null값을 채워 결과 릴레이션에 포함 외부 합집합 ∪+<br>
<img alt="assets/스크린샷 2023-12-07 오후 9.59.35.png" src="700-컴퓨터과학/assets/스크린샷-2023-12-07-오후-9.59.35.png" target="_self" style="width: 300px; max-width: 100%;">
AVG 평균
GROUP 그룹화 사용자가 필요로 하는 연산의 최종 결과만 명세(WHAT)
== 선언적 표현방법
== 비절차적 표현방법 튜플 변수(= 범위 변수) : t 범위 릴레이션이 R일때, 범위식 R(t) 정량자 한정 여부
자유변수
속박변수 한정 애트리뷰트 투플 변수 t가 나타내는 투플의 애트리뷰트 A의 원자식 : t.A 또는 t[A] 구성요소 범위식 R(t)
조건식(한정애트리뷰트 + 비교연산자 +한 정애트리뷰트/상수) 실행결과는 항상 boolean 정형식(WFF) 원자식, 불리언 연산자(∧,∨, ¬ ), 정량자 자 (∀,∃)가 다음규칙에 따라 결합된 불리언 연산자 ∧ : AND ∨ : OR ¬ : NOT 정량자 ∀ : 전체정량자 ∀x : 모든 x에 대해서 ~한 조건을 만족하면 참, 아니면 거짓 ∃ : 존재정량자 ∃x : ~한 조건을 만족하는 것이 하나라도 있다면 참, 없으면 거짓 규칙 원자식 ⊂ 정형식
If F is WFF -&gt; (F) 와 ¬F are WFF
If F 와 G are WFF -&gt; F∧G와 F∨G are WFF
IF t is 자유변수 &amp;&amp; F(t) is WFF -&gt; ∀t(F(t))와 ∃t(F(t)) are WFF ㄹ
]]></description><link>700-컴퓨터과학/db1-관계-연산.html</link><guid isPermaLink="false">700-컴퓨터과학/DB1 - 관계 연산.md</guid><pubDate>Sun, 21 Sep 2025 18:19:32 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[디자인패턴]]></title><description><![CDATA[
프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계등을 이용하여 해결할 수 있도록 하나의 규약 형태로 만들어 놓은것
하나의 클래스에 하나의 인스턴스, 데이터베이스 연결 모듈에 많이 사용//원리 constructor는 암묵적으로 this를 반환.
class SingletonA{ constructor( ) { if(!Singleton.instance){ Singleton.instance = this } return Singleton.instance } getInstance(){ return this.instance }
} class SingletonB { static instance constructor() { if (instance) return instance; instance = this; }
} const singleton1 = new Singleton();
const singleton2 = new Singleton(); const a1 = new Singleton();
const a2 = new Singleton();
console.log(a1===a2) // true
node.js에서 mysql과 mongodb의 라이브러리에서 Connect할때 때 이러한 패턴을 실제로 사용한다.const URL = 'dburl';
const createConnection = url =&gt; ({"url":url}); class DB{ constructor(url){ if(!DB.instance){ DB.instance = createConnection(url); } return DB.instance; } connect(){ return this.instance }
} const a = new DB(URL);
const b = new DB(URL); console.log(a===b);//true 인스턴트 생성 비용이 줄고 자원을 공유함.
데이터베이스 또는 로그 연결 객체와 같이 애플리케이션 전체에서 공통으로 사용되는 리소스에 대해 일관된 접근 방식 제공 가능
애플리케이션 전역에서 객체에 접근할 수 있으므로, 별도의 파라미터 전달이나 의존성 주입과 같은 과정이 필요없다. 의존성이 커짐(=모듈간의 결합을 강하게). -&gt; 단위 테스트에 걸림돌
멀티스레드 환경처럼 다수의 클라이언트가 동시에 접근할 때 발생하는 객체의 상태 변화에 유의해야 함. 이런 환경에서 싱글턴 객체의 동기화가 보장되지 않는다면, 이에 의존하는 코드에 다양한 오류를 발생시킬 수 있음.
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://seongjin.me/woowacourse-three-design-patterns-in-javascript/" target="_self">https://seongjin.me/woowacourse-three-design-patterns-in-javascript/</a>
<br>=&gt; 해결 방법! 의존성주입 <a data-href="의존성 주입" href="700-컴퓨터과학/의존성-주입.html" class="internal-link" target="_self" rel="noopener nofollow">의존성 주입</a>
객체 생성부분을 떼어내 추상화한 패턴
상위 클래스에서 중요한 뼈대를 결정하고 하위클래스에서 객체생성에 대한 구체적인 내용을 결정 상위클래스에서 인스턴스 생성 방식에 알 필요가없음 -&gt; 유연성 Up
유지 보수성이 증가
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://aljjabaegi.tistory.com/617" target="_self">https://aljjabaegi.tistory.com/617</a>const Carfactory = function({name,price}){ this.name = name; this.price = price; this.getInfo = function(){ return this.name+"의 가격은 "+this.price+" 입니다."; }
}
const car1 = new Carfactory({name: "아반떼", price: "1,570 ~ 2,453만원"});
const car2 = new Carfactory({name: "쏘나타", price: "2,386 ~ 3,367만원"});
console.log(car1, car2);
class Car{ constructor(info){ this.name = info.name; this.price = info.price; } getInfo(){ return this.name+"의 가격은 "+this.price+" 입니다."; } static factory(name){ if(name === "Avante"){ return new Avante(); }else if(name === "Sonata"){ return new Sonata(); } }
}
class Sonata extends Car{ constructor(){ super({name: "쏘나타", price: "2,386 ~ 3,367만원"}); }
}
class Avante extends Car{ constructor(){ super({name: "아반테", price: "1,570 ~ 2,453만원"}); }
}
const avante = Car.factory("Avante");
const sonata = Car.factory("Sonata");
console.log(avante, sonata); 객체 지향 디자인 패턴 중 하나로 동일한 문제를 해결하기 위한 여러 알고리즘(전략)을 정의하고, 각각을 캡슐화하여 상호 교환 가능하도록 만드는 패턴 전략 추상화 공통적으로 수행하느 전략을 추상화하여 추상클래스/인터페이스로 정의한다.
되도록이면 하나의 역할만 수행하는 것이 좋다. 전략 구현 추상화된 전략을 상속받아 구체적인 전략을 수립한다. 전략 등록(컨텍스트) 전략을 등록하고 실행하는 메서드를 정의한다. 전략에 맞게 사용 OOP의 집합체다.(SOLID 등..)
oauth나 payment에 주로 사용
동작이 런테임에 실시간으로 교체되어야할때 사용
장점 : 기능 확장에 용이
단점 : 클래스 개수 너무 많아질 수 있음. // 카카오 로그인 전략 등록
passport.use(new KakaoStrategy({ clientID, callbackURL }, async (accessToken, refreshToken, profile, done) =&gt; { // ...
});
// 네이버 로그인 전략 등록
passport.use(new NaverStrategy({ clientID, clientSecret, callbackURL }, async (accessToken, refreshToken, profile, done) =&gt; { // ...
});
참고 링크 :<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-%EC%A0%84%EB%9E%B5Strategy-%ED%8C%A8%ED%84%B4-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EC%9E%90" target="_self">https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-%EC%A0%84%EB%9E%B5Strategy-%ED%8C%A8%ED%84%B4-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EC%9E%90</a>
객체의 상태변화를 관찰하다가 상태변화가 있을때 메서드를 통해서 옵저버 목록에 있는 옵저버들에게 변화를 알려줌
<br><img alt="assets/스크린샷 2023-11-25 오후 7.13.54.png" src="700-컴퓨터과학/assets/스크린샷-2023-11-25-오후-7.13.54.png" target="_self">
주로 이벤트 기반 시스탬과 MVC 패턴에서 사용
interface Subject{ register(obj:Observer):void; unregister(obj:Observer):void; notifyObservers():void; getUpdate(obj:Observer):string;
}
interface Observer{ update():void;
} class Topic implements Subject{ private observers:Observer[] = []; private message:string = ""; register(obj:Observer):void{ this.observers.push(obj); } unregister(obj:Observer):void{ this.observers.splice(this.observers.indexOf(obj), 1); } notifyObservers():void{ this.observers.forEach((observer:Observer) =&gt; observer.update()); } getUpdate(obj:Observer):string|null{ if(this.observers.includes(obj)){ return this.message; } return "can't accept to message"; } postMesssage(msg:string):void{ console.log("msg sended to topic :"+ msg); this.message = msg; this.notifyObservers(); } } class TopicSubscriber implements Observer{ private name:string; private topic:Subject; constructor(name:string, topic:Subject){ this.name = name; this.topic = topic; } update():void{ let msg:string = topic.getUpdate(this); console.log(this.name + ":: got message &gt;&gt; " + msg) }
} let topic = new Topic();
let a = new TopicSubscriber("a", topic);
let b = new TopicSubscriber("b", topic);
topic.register(a);
topic.register(b);
topic.postMesssage("amumu is op champion!!");
<br><img alt="assets/Pasted image 20231129141201.png" src="700-컴퓨터과학/assets/pasted-image-20231129141201.png" target="_self"><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@esthevely/JS-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-Proxy-%EA%B0%9D%EC%B2%B4-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0" target="_self">https://velog.io/@esthevely/JS-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-Proxy-%EA%B0%9D%EC%B2%B4-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0</a>프록시
보안
익명화
접근제어
캐싱
로드밸런싱
포워드 프록시와 리버스 프록시는 두 가지 서로 다른 프록시 서버 유형입니다. 각각의 주요 특징은 다음과 같습니다: 포워드 프록시(Forward Proxy): 클라이언트가 인터넷에 직접 접근하는 것을 막고, 클라이언트의 요청을 대신 받아서 외부 서버로 전달합니다.
클라이언트가 외부 리소스에 접근할 때 프록시 서버를 경유하여 보안, 로깅, 필터링, 캐싱 등의 기능을 수행합니다.
주로 회사나 조직의 내부 네트워크에서 직원들의 인터넷 접근을 제어하고 모니터링하는 데 사용됩니다. 리버스 프록시(Reverse Proxy): 외부에서 내부로 들어오는 클라이언트의 요청을 받아들이고 이를 내부의 서버로 전달합니다.
클라이언트가 웹 서버에 접근할 때, 리버스 프록시 서버가 요청을 받아들이고 요청을 처리할 적절한 내부 서버(예: 웹 서버, 애플리케이션 서버)로 라우팅합니다.
보안, 부하 분산, 성능 향상 등을 위해 사용됩니다. 외부 요청에 대한 내부 시스템의 보호와 안전성을 높이며, 여러 서버 사이의 부하를 균형있게 분산시키는 역할을 합니다. 두 유형의 프록시 서버는 각각의 목적에 따라 구성되며, 네트워크 보안 및 성능 최적화를 위해 중요한 역할을 수행합니다.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.cloudflare.com/ko-kr/learning/cdn/glossary/reverse-proxy/" target="_self">https://www.cloudflare.com/ko-kr/learning/cdn/glossary/reverse-proxy/</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://inpa.tistory.com/entry/NETWORK-%F0%9F%93%A1-Reverse-Proxy-Forward-Proxy-%EC%A0%95%EC%9D%98-%EC%B0%A8%EC%9D%B4-%EC%A0%95%EB%A6%AC" target="_self">https://inpa.tistory.com/entry/NETWORK-%F0%9F%93%A1-Reverse-Proxy-Forward-Proxy-%EC%A0%95%EC%9D%98-%EC%B0%A8%EC%9D%B4-%EC%A0%95%EB%A6%AC</a>]]></description><link>700-컴퓨터과학/디자인패턴.html</link><guid isPermaLink="false">700-컴퓨터과학/디자인패턴.md</guid><pubDate>Sun, 21 Sep 2025 18:18:15 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[DB1 - SQL]]></title><description><![CDATA[
관계형 데이터베이스 표준언어 관계대수 + 확장된 투플 관계 해석 기초
고급, 비절차적(= 사용자 친화적) 데이터언어
표준화
선언적 언어 데이터 처리를 위한접근경로에 대한 명세가 불필요 레코드 집합 단위로 처리
터미널을 통해 대화식 질의어로 사용
프로그램에 삽입된 형태로도 사용 가능 기본 테이블 : DBMS 화일로 생성되고 저장
가상 테이블 : 어떤 기본 테이블로 유도되어 만들어지는 테이블 독자적으로 존재 불가 임시 테이블 : 질의문 처리 과정의 중간 결과로 만들어지는 테이블 DDL 문으로 만들어지지 않음 하나의 응용(사용자)에 속하는 테이블과 기타 구성요소 등의 그룹
스키마이름, 스키마 소유 허가권자, 테이블, 뷰, 도메인, 기타내용에 대한 기술자
DBA로부터 허가 받은 사용자만 소유 가능 SQL 시스템 내에서의 한 스키마 집합
Information_schema(DB의 메타&nbsp;정보를 모아놓은 스키마) 포함 실제로 레코드가 있는 것은 아님
read only 하나이상의 기본 테이블로부터 유도되어 만들어지는 가상테이블
외부스키마는 뷰와 기본테이블들의 정의로 구성
물리적 구현이 아님 카탈로그에 SELECT-FROM- WHERE로 저장 뷰에 대한 내용변경 -&gt; 테이블에 대한 변경
장점 논리적 독립성을 제공
데이터 접근을 제어
사용자의 데이터 관리를 단순화
여러 사용자에 다양한 데이터 요구를 지원 단점 정의 변경 불간
삽입, 삭제, 갱신연산에 제약이 많음 숫자 정수 : INT , SMALLINT
실수 : FLOAT(n) , REAL, DOUBLE PRECISION
정형 숫자 : DECIMAL(i,j), NUMERIC(i,j) 전체자리수와 소수점자리수를 정의해줌. 문자 스트링 고정 길이 문자 : CHAR(n)
가변 길이 문자 : VARCHAR(n) 비트 스트링 BIT(n), BIT VARYING(n) 날짜 DATE : YY-MM-DD 시간 TIME : hh:mm:ss
TIMESTAMP : DATE , TIME 포함
INTERVAL : DATE, TIME, TIMESTAMP 포함 DB 구조 정의
DB 객체(table, view, index etc) 생성, 수정, 삭제 PRIMARY KEY : 기본키와 제약조건을 명세 UNIQUE,NOT NULL속성을 가지고 있음 FOREIGN&nbsp;KEY ON DELETE
ON UPDATE CASCADE , SET NULL, NO ACTION, SET DEFAULT, RESTRICT의 옵션 잇음 UNIQUE : 후보키(유일성,최소성 확보된 키)
NOT NULL : 속성 값 제약조건 눌이 될 수 없다
삭제될때에 관한조건(기본이 RESTRICT) RESTRICT : 참조하는 테이블에 데이터가 남아 있으면 참조되는 테이블의 데이터를 삭제하거나 수정할 수 없음
CASCADE : 자신이 참조하고 있는 테이블의 데이터가 삭제되면 자동으로 자신의 데이터도 삭제 참조 무결성 준수 가능 CONSTRAINT : 제약조건에 이름을 붙이는 것
DEFAULT : 디폴트값지정
CHECK : 조건을 주어 해당 데이터 입력 불가능 CHECK(조건) CONSTRAINT 사용 경우
CREATE TABLE Employees ( emp_id INT, name VARCHAR(50), salary FLOAT, CONSTRAINT check_salary CHECK (salary &gt; 0)
); 제약조건만 드랍하고 수정이 가능함
-- alter 는 테이블 컬럼을 수정할 때 쓰는 키워드
ALTER TABLE Employees DROP CONSTRAINT check_salary; ALTER TABLE Employees ADD CONSTRAINT check_salary CHECK (salary &gt;= 50000); - 사용하지 않는 경우 ```sql CREATE TABLE Employees ( emp_id INT, name VARCHAR(50), salary FLOAT CHECK (salary &gt; 0) ); ``` salary속성 자체를 없애고 다시만들어야함 ```sql ALTER TABLE Employees DROP COLUMN salary; ALTER TABLE Employees ADD COLUMN salary FLOAT CHECK (salary &gt;= 50000);
중괄호는하나무적건잇어야함 대괄호는 생략가능 + 여러번반복될수잇다. * 전체를 선택하는기호CREATE TABLE 테이블이름( {열이름 데이타타입 NOT NULL DEFAULT 디폴트값,} [PRIMARY KEY (열이름_리스트),] {[UNIQUE (열이름_리스트),]} * {[FOREIGN KEY(열이름_리스트) REFERENCES 기본테이블(열이름_리스트) ] [ON DELETE 옵션 ] [ON UPDATE 옵션,]} [CONSTRAINT 이름] [CHECK(조건식)]
);
예시CREATE TABLE ENROL ( -- 속성들 정의 Sno INTEGER NOT NULL, Cno CHAR(6) NOT NULL, Grade INTEGER, -- PK정의 PRIMARY KEY(Sno,Cno), -- FK정의 FOREIGN KEY(Sno) REFERENCES STUDENT(sno) ON DELETE CASCADE ON UPDATE CASCADE, FOREIGN KEY(Cno) REFERENCES COURSE ON DELETE CASCADE ON UPDATE CASCADE, -- 제약조건 CHECK(Grade &gt;0 AND Grade &lt;100));
CREATE VIEW 뷰_이름[(열_이름 리스트)] AS SELECT문 [WITH CHECK OPTION] CREATE VIEW CSTUDENT(Sno, Sname, Year) AS SELECT Sno, Sname, Year FROM STUDENT WHERE Dept = '컴퓨터’ WITH CHECK OPTION; WITH CHECK OPTION : 뷰를 통해 데이터를 변경시 뷰의 정의를 만족하는지 확인하는 옵션이다
뷰는 제한적인 갱신만 가능
%% 열부분 집합뷰 %%
- 기본키를 포함한경우 (Sno)
CREATE VIEW STUDENT_VIEW1 AS SELECT Sno, Dept FROM STUDENT; %% 행부분 집합뷰 , 당연히 기본키가 포함됨 %% CREATE VIEW STUDENT_VIEW3 AS SELECT Sno, Sname, Year, Dept FROM STUDEN
%% 열부분 집합뷰 %%
- 기본키를 포함하지 않은경우
CREATE VIEW STUDENT_VIEW2 AS SELECT Sname, Dept FROM STUDENT; %% 조인뷰(두개의 테이블 이상이 관련되서 정의된 경우) %%
- 조인이 있는 경우
CREATE VIEW STUDENT_VIEW2 AS SELECT Sname, Dept FROM STUDENT;
- 조인이 없는 경우
CREATE VIEW HONOR(Sname, Dept, Grade) AS SELECT STUDENT.Sname, STUDENT.Dept, ENROL.Final -- 조인 FROM STUDENT, ENROL WHERE STUDENT.Sno = ENROL.Sno -- 조인기준 AND ENROL.Final &gt; 95; %% 통계적 요약 뷰, 데이터가 변형되서 들어갓을 경우 %%
-- 집계함수 사용
CREATE VIEW COSTAT(Cno, Avpoint) AS SELECT Cno, AVG(Midterm) FROM ENROL GROUP BY Cno; --열이 상수나 산술 연산자 또는 함수가 사용된 산술식
CREATE VIEW Employee_Annual_Salary AS
SELECT EmployeeID, FirstName, LastName, Salary * 12 AS AnnualSalary
FROM Employees; %% 변경할수 없는 뷰를 기초로 정의 됐을때 %%
%% %%
DROP TABLE 테이블 이름 [조건]
DROP SCHEMA 스키마 이름 [조건]
ALTER TABLE 테이블이름 DROP 열이름 [조건] ADD 열이름 데이터타입 [DEFAULT 디폴트값] DB 데이터 관리
입력 수정 삭제, 검색
--[]시 먼저 나오는게 디폴트 값
--DISTINCT : 중복제거
SELECT [ALL | DISTINCT] 속성 FROM 테이블_리스트 [WHERE 조건] [GROUP BY 열_리스트 [HAVING 조건]] [ORDER BY 열_리스트 [ASC | DESC]]; 가로로 합침
SELECT Sname, Dept, Grade FROM STUDENT JOIN ENROL ON (STUDENT.Sno=ENROL.Sno) WHERE ENROL.Cno = 'C413'; SELECT Sname, Dept, Grade FROM STUDENT JOIN ENROL USING(Sno) WHERE ENROL.Cno = 'C413'; SELECT Sname, Dept, Grade FROM STUDENT NATURAL JOIN ENROL WHERE ENROL.Cno = 'C413'; ON은 조인할때의 기준을 정의할 때 사용한다
USING은 조인할때 두테이블의 컬럼명(속성명)이 같을때 사용
NATURAL JOIN은 두 테이블에 둘 다 존재하는 속성을 dbms에서 자동으로 찾아서 알아서 조인해줌
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://doh-an.tistory.com/30" target="_self">https://doh-an.tistory.com/30</a> 새로로 합침
UNION : 중복되는 투플제거 , UNION ALL : 중복되는 투플 제거 ㄴㄴ
속성이 같아야 함
SELECT Sno FROM STUDENT WHERE Year = 1 UNION SELECT Sno FROM ENROL WHERE Cno = 'C324'; COUNT, SUM, AVG, MAX, MIN
집계함수(속성) 형식
as 써서 반환 이름 변경 가능<br>
<img alt="assets/Pasted image 20231216170306.png" src="700-컴퓨터과학/assets/pasted-image-20231216170306.png" target="_self" style="width: 500px; max-width: 100%;">
SELECT COUNT(*) AS 학생수 FROM STUDENT;
SELECT COUNT(DISTINCT Cno) FROM ENROL WHERE Sno = 300;
SELECT AVG(Midterm) AS 중간평균 FROM ENROL WHERE Cno = ‘C413’;
SELECT Sname, Dept FROM STUDENT WHERE Dept = (SELECT Dept FROM STUDENT WHERE Sname = ‘정기태’);
바로 비교해도됨.
-- in 앞에 비교대상
SELECT Sname FROM STUDENT WHERE Sno IN (SELECT Sno FROM ENROL WHERE Cno = 'C413');
SELECT Sname FROM STUDENT WHERE Sno NOT IN (SELECT Sno FROM ENROL WHERE Cno = ‘C413’); -- all 앞에 연산자와 비교대상
SELECT Sno, Cno FROM ENROL WHERE Final &gt; ALL (SELECT Final FROM ENROL WHERE Sno = 500); --any 앞에 연산자랑 비교대상
SELECT column_name(s) FROM table_name WHERE column_name &gt; ANY (SELECT column_name FROM table_name WHERE condition); -- exist 앞에 머없음
SELECT Sname FROM STUDENT WHERE EXISTS (SELECT * FROM ENROL WHERE Sno = STUDENT.Sno AND Cno = 'C413');
UPDATE 테이블 SET { 열_이름 = 산술식} ’+ [WHERE 조건];
UPDATE STUDENT SET Year = 2 WHERE Sno = 300;
UPDATE COURSE SET Credit = Credit + 1 WHERE Dept = '컴퓨터';
SET 뒤나 WHERE뒤에 부속질의어를 써도 된다
단 SET에는 부속질의어가 하나의 값만 반환하도록 해야한다.INSERT INTO STUDENT(Sno, Sname, Year, Dept) VALUES (600, '박상철', 1, '컴퓨터'); --전부다 넣을땐 생략가능 단 순서대로..
INSERT INTO STUDENT VALUES (600, '박상철', 1, '컴퓨터');
value 부분에 넣을수있음.INSERT INTO COMPUTER(Sno, Sname, Year) SELECT Sno, Sname, Year FROM STUDENT WHERE Dept = '컴퓨터';
--조건안붙이면 레코드가 다 삭제됨
DELETE FROM 테이블 [WHERE 조건];
레코드를 삭제할때 부속질의문 쓰는 방식은 SELECT랑같음
DB 관리 및 통제
DB 백업/복원
사용자 등록, 권한 관리 sql의 이중모드 원리 대화식 환경(터미널)이나 응용프로그램에 내장될 수 있음 삽입 sql을 포함하는 응용프로그램 특징 명령문앞에 EXEC SQL QNXDLA
호스트 실행문이 나타나는 어느곳이든 사용 호스트 변수는 : 앞에 붙임 EXEC SQL DELETE FROM Employees WHERE EmployeeID = :id;``` 호스트 변수 SQLSTATE를 포함 : SQL문장의 실행 상태를 나타냄 00000 : 성공적으로 실행
아니면 경고 or 에러 호스트 변수와 대응하는 열의 데이터 타입은 일치 : SQL 문장에 사용되는 호스트 변수의 데이터 타입과 해당 변수가 대응하는 데이터베이스 테이블의 열의 데이터 타입은 일치해야 합니다.
그냥 프로그램에서 중간결과값을 저장하는 것EXEC SQL DECLARE C1 CURSOR FOR /*커서 C1의 정의*/ SELECT Sno, Sname, Year FROM STUDENT WHERE Dept = :dept; EXEC SQL OPEN C1; /*질의문의 실행*/ DO /* C1으로 접근되는 모든 레코드에 대해 */ EXEC SQL FETCH C1 INTO :sno,:sname,:year; /*다음 레코드를 채취*/ . . . . . . END; EXEC SQL CLOSE C1; /*커서 c1의 활동 종료 * PREPARE sql문을 예비 컴파일해서 object code로 생성하여 저장 EXECUTE 저장되어있는 object code를 실행 ]]></description><link>700-컴퓨터과학/db1-sql.html</link><guid isPermaLink="false">700-컴퓨터과학/DB1 - SQL.md</guid><pubDate>Sun, 21 Sep 2025 18:16:50 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[school) DB2-2(설계절차)]]></title><description><![CDATA[db설계작업의 개요를 제공~!
설계절차 완료가 중요하다db설계에 필수적임
조직내에서 면담, 자신간의 면담 이 있음
설계의 핵심 정보를 제공 받을 수 있음
생략하면 중요한정보를 놓쳐 최종구조에 악영향 미칠 수 있음
지침을 이용하면 일관성있고 성공적으로 면담을 할수있게도움을 줌
참여자 지침 의도를 알 수 있게함
일련의 과정 중 하나인지 여부를 알게함
응답이 전반적인 설계에 중요하다는 것을 알게함
논쟁이 생기면 여러분이 공식적인 중재자라는 것을 이해시킴
db구조에 최선의 이익이 되도록 결정함 면담자 지침 10명을 한계로
사용자 관리자 면담은 따로
필기 or 녹음
모든사람에게 동일한관심
질문미리 준비함 특별한 목적을 일반적인 용어로 작성하는 것
이 프로젝트 데이터베이스의 목적은 증권사와 주식시장이 제공하는 정보를 관리하여 투자자에게 공모주에 투자하기 위한 의사결정을 돕는 정보를 제공하기 위한 것이다. 참여 그룹 : db개발자, 조직의 소유자 및 간부, 관리직원
좋은 임무 명세 명확하고 잘정의 되어있어야함
특정 작업을 구체적으로 설명하는 구나 문장이 없음 임무명세 구성(with 면담) 조직의 장or 간부와의 면담
개방 지향적 질문 참여자가 많은 노력 없이 db목적을 설명하도록 할 수 있음
주제에 초점을 맞추면서도 참여자가 완전한 답변이라고 느끼는것을 응답할 수 있도록 해줌
임무목표로 변환 가능한 응답을 얻을 수도 있음
여러분은 조직의 목적을 무엇이라고 말하겟음? 새고객에게 어떻게 설명하겟음? 주요기능은? 응답 재작성하여 임무명세로 변환 가능 db에서 지원되는 일반적인 작업을 나타냄
우리는 회사의 재무 정보를 관리할 필요가 있다
우리는 기업 공개 정보를 관리할 필요가 있다
우리는 공모 일정 정보를 관리할 필요가 있다
우리는 공모주의 주가 정보를 관리할 필요가 있다.
우리는 고객의 기업 관심목록을 추적할 필요가 있다
우리는 고객의 정보를 관리할 필요가 있다 참여 그룹 : db개발자, 관리 직원, 최종사용자
좋은 임무 목표 조건 선언적 문장
불필요한 세부사항 없음
일반적인 용어
하나의 작업만 정의 목적 db내의 다양한 구조를 정의하는데 도움을 주고 db개발의 전반적인 방향을 안내하는데 도움을 주기 위한 것 임무 목표 구성(with 면담) 어떤 작업이 db에 의해 지원 될 필요가 있는지 결정하기 위함
사용자 및 관리자와 함께 면담을 수행
매우 일반적인 논의를 포함함, 개념적
모든문장을 선언적으로 기록함
개방 지향적 질문
뒤따르는 질문을 함
함축적인 정보 파악
ex) 여러분은 업무 설명을 어떻게 정의하시겠습니까, 어떤 종류의 데이터로 작업하고 싶습니까?, 어떤 종류의 서비스를 제공합니까? 해야하는 이유 조직의 현재 요구사항을 지원하는지 파악
기존의 구조적 결함을 발견하기 위해 목표 : 조직사용 데이터 종류, 관리유지 방법, 사용 방법을 판단 절차 : 표현하는 다양한 방법을 검토, 사용자 및관리자와 면담 수행
규칙 : 현재 db의 구조를 새 db의 구조를 위한 기초로 삼지 말라.
종이 기반의 db 분석 문제점 : 일관성 없는 데이터, 잘못된 데이터,이중데이터,중복데이터, 불완전한 입력, 삭제되어야 할 오래된 데이터
분석 이유 : 새 db에 포함시킬 수 있는 항목을 식별하기 위함
개별적인 데이터 조각을 추출 레거시 db 분석 레거시 : 유산이라는 뜻(보통 5년 이상)
혼란의 가능 성을 내포함
메인프레임 레거시의 문제 계층형,망형 모델에 기초를 둔 것이 많음 관계형 레거시의 문제 부적절하거나 비효율적인 구조를 가진 경우가 많음 pc 기반의 레거시의 문제 비관계형 db시스템이 많음
이중필드와 중복데이터로 데이터 무결성에 문제가 있는 경우가 많음 종이기반보다 레거시가 더 쉬움 : 더 조직화 구조화, 구조가 명확히 정의 데이터가 수집되는 방법 검토 종이 기반 기록하기 위해 어떤 종이문서를 썻나
샘플을 하나씩 수집 컴퓨터 소프트웨어 프로그램 프로그램을 어떻게 사용하는지 보여주는 샘플 화면 덤프를 수집하기 위함 인터넷을 통해 데이터 수집하는 웹페이지 데이터 입력폼과 비슷하게 보임
어플리케이션과 같은 검사 절차를 사용
웹페이지 화면을 덤프 정보가 표현되는 방법 검토 보고서 데이터 배열하고 표현된는데 사용
샘플 수집 &gt; 폴더에 모음 ppt 조직화 된 방법을 주제를 논의하는 화면으로 구성
데이터를 사용하거나 통합하는 화면을 검토
db데이터 와 직접관계가 있는 것을 검토
화면덤프 &gt; 폴더에 저장 웹페이지 방대한 정보, 보고서형식
db에서 직접 정보를 추출 하는 웹페이지를 검토
ppt와 같은 검토 방법버 사용자 및 관리자와 면담 수행 이건 검토에서 모은 샘플의 세부사항을 제공함
예비필드, 테이블 구조 정의하는데 도움
개방 지향적, 폐쇄적인 질문 둘다 사용 개방 지향적 : 주제에 초점
폐쇄적 질문 : 구체적 세부사항에 초점 ==주제 식별 기술 주제는 항상 명사
사람, 장소 , 사물, 사건을 명확하게 나타내는 명사만
개방 지향적 ==특성 식별 기술 특정 주제와 연관된 질문을 함
특성을 나타내는 명사를 표시함
주제와 같은 시트에 열거 ㄴㄴ
개방 지향적 사용자 &gt; 관리자 순으로 면담
사용자 면담 현재사용하고 있는 데이터 종류와 용도 개방 지향적
면접과정서 주제,특성식별 기술을 씀
초점을 좁혀나감
ex ) 일상적으로 여러분은 어떤 종류의 일을 하나요? &gt; 세부사항 샘플 검토 취합한 샘플에 초점을 맞춤
질문에 앞어 앞서 수행한 논의로부터 작성한 메모를 검토
복잡한 샘플의 경우 샘플 내에 어떤주제가 표현되었는지 판단해야함 주제 식별기술 쓰셈 응답이 만족할 정도일 경우 샘플에 대한 설명의 기초로 사용
샘플의 설명은 간결해야하고 목적,용도를 명확히 적어야함 ex) 이 화면은 모든 고객 데이터를 수집하고 관리하기 위해 사용된다 ex) 앞의 논의에서 여러분은 모든 고객을 추적한다고 했었습니다. 이화면이 그작업을 수행하는데 어떻게 도움이 되나요? 정보 요구사항 검토 목적 개별 사용자가 스스로 직접 통제하지 않는 데이터에 기초한 정보를 받는지 여부를 판단
어떤 종류의 추가적인 정보를 필요로 하는지 판단
어떤 종류의 정보들이 그들의 미래에 필요하다고 예측할 수 있는지 판단 데이터 출처를 판단하고 사용자에 의해 사용되는 모든데이터를 식별할 수 있어야함
ex) 보고서에 사용된 데이터를 여러분이 제공함?&gt; 그러면 여러분이 매일 이데이터를 직접 입력하고 관리함? 추가적인 정보 요구사항 검토 목적 : 사용자들이 그들에게 전달되지 않은 추가적인 정보를 필요로 하는지 판단 if yes, 어떤 추가적인정보를 필요, 그를 지원하기 위한 새 데이터 구조를 정의해야함 그들이 보고싶은 다른 정보가 있는지 질문, why도 질문
어떤 영향을 미칠지 질문
추가적인 정보에 나타나는 새 주제나 새 특성이 있는지 여부를 결정 if 새 주제, 주제목록에 추가하고 최대한 많은 특성을 식별함
그리고 전체절차를 반복함
근데 보통은 새 특성만 식별하긴함 마지막으로 참여자들이 만든 메모에 대해 질문이나관심이 있는지 판단함
ex) 제조업체 이름을 포함할 수 있을까? 이건 특정제품을 식별하는것을 더 쉽게해줄거야
미래의 정보 요구사항 목적 : 조직이 발전하면서 참여자들이 받을 필요가 있다고 믿는 정보를 식별함
조직이 어떻게 발전할 것인지 관련해 참여자들의 생각을 파악할 수 있음
발전할때까지 그들이 필요로하는 정보의 종류를 예측할 수 있음
ex) 조직의 발전이 여러분의 업무에 필요한 정보의 양에 어떤 영향을 미칠까요 유의 사항: 데이터와 정보의 차이점을 이해하고 기억해야함 관리자 면담 현재의 정보 요구사항 검토 목적 : 관리자가 받는 정보를 식별하고 그룹샘플에 없는 보고서를 받는지 여부를 판단하기 위함
각 참여자가 수행하는 작업과 직책에 부과된 책임에 대해 질문
관리자에게 주제 식별 도움을 요청
샘플에 없는 보고서를 받는다면 새 보고서 샘플을 구하고 검토함 추가적인 정보 요구사항 검토 목적 : 관리자가 받는 보고서에 현재 빠져있는 추가적인 정보를 관리자가 필요로 하는지 판단 하는 것
참여자들과 샘플 보고서 검토-&gt; 추가시키고 싶은 정보가 있는지 물어봄
추가적인 정보를 주제,특성 식별구술을 써서 식별하여 목록에 출가 미래의 정보 요구사항 검토 목적 : 관리자가 어떤 정보를 미래에 필요하다고 예측하는지 판단하기를 위함
조직이 현재 어떻게 발전하고 있는지 생각 하도록함.
그발전이 올바른 판단을 하기 위해 그들에게 필요한 정보가 어떻게 영향을 끼칠지 질문 전반적인 정보요구사항 검토 목적 : 앞에서 논의되지는 않았지만 조직이 관리할 필요가 있는 데이터가 있는지 논의하기 위함
모든 보고서를 한번더 검토
조직에 유용하고 가치있지만 아직 조직내의 누구도 받아본 적이 없는 정보가 있는지 질문 예비필드 목록 조직의 기초적인 데이터 요구사항을 나타네고, db에서 정의할 필드의 핵심집합을 구성 특성 목록을 검토하고 정제 분석과 면담 작업을 통해 취합한 특성목록을 검토
이중 특성을 제거해야 함
같은 이름을 가진 항목을 정제 같은이름을 가져도 각 이름이 고유한 특성을 나타내는 것도 있음 이름 , 주소 등
주제 + 특성으로 바꾸셈
이러한 특성목록에 일상적으로 나타나는항목을 일반적항목이라고 통칭할 수 있음 나머진 제거 같은 특성을 나타네는 항목제거 같은 특성을 나타내는항목찾고 나머지 제거
ex) 제품 no , 제품 번호, 제품 # 다같은 특성 =&gt; 제품 번호로 정제 항목들이 특성을 나타내는지확인 주제를 나타내는 목록에 항목을 넣기가 쉬움
항목을 테스트하기 위한 질문 이단어는 무언가 설명하는데 사용될 수 ㅣㅇ쓴ㄴ가
이단어는 어떤것의 구성요소, 세부사항,일부인가
이단어는 더작은 조각으로 쪼개질 어떤것을 나타내는가 샘플에서 새로운 특성들이 있는지 파악 목적 : 분석 작업에서 수집한 모든 샘플에 대해 검사하고 예비 필드 목록에 추가할 특성들이 있는지 여부를 판단하기 위함
샘플에 특성을강조
목록에 있는지 확인 후 제거
남아있는것중 같은 의미를 가지고 있는지 확인하고 제거
남아있는것을 예비 필드 목록에 추가
부수적 메모: 값목록 특성의 허용되는 값의 범위를 지정하거나 업무 규칙을 부과하기도함
고유하고 독특한 값집합을 수용하는 특성의 경우 반드시 기록해야함&lt;&lt;필드명세나 업무규칙에 참조 계산된 필드 목록 모든 계산된 필드를 제거하고 그것을 별도의 목록으로 만든(해당 목록을 계산된필드 목록이라함)
이건 나중에 설계 작업에서 활용하기에 따로 열거해야함
계산된필드 : 함계 평균등 다른 필드를 이용하여 계산한 필드 완료시 예비필드목록 version 3과 계산된 필드 목록, 두개의 목록을 가지게 됨
해당 목록들을 면담을 통해 또 검토함 &gt; 누락된 필드가 있는지확인 암시적 주제 식별하기 예비 필드 목록을 검토하여 필드 내에 내포되어 있는 주제를 식별함
주제 목록보다 예비 필드 목록을 먼저 보는 이유 테이블 누락의 가능성 : 임의의 필드들이 특정 주제를 암시할 수 있음
편중되지 않은 관점 목록의 필드로부터 주제를 추론할 수 있으면 그주제를 새 예비 테이블 목록에 넣음
모든 필드를 훑어보고 가능한 많은 주제가 식별될때까지검토 후 예비 테이블목록에 추가 주제 목록 사용하기 주제 목록과 예비테이블 version 1(암시적 주제식별하기에서했던) 것을 통합하여 예비테이블 목록 version 2를 만듬
통합시 절차 이중항목들 제거 같은 이름이더라도 다른 주제를 나타낼 수도 있음
이럴 시 각 항목의 이름을 바꿔서 주제를 정확히 식별하도록함
면담메모를 이때 검토 같은 주제 나타내는 항목 제거 주제목록상의 항목과 예비 테이블 목록상의 항목이 다른이름이지만 같은 주제를 가졌는지 여부를 파악함
항목들의 집합을 식별하면 그 주제를 가장 잘 나타내는 이름을 선택하고 그 주제의 유일한 식별자로 정함 주제목록과 예비테이블 목록의 항목 통합 걍 남아있는 주제목록의 모든 항목을 예비테이블 ver 1 에 모두 추가하여 ver 2를 만듬
남아있는 주제목록은 버리쉠ㅋ 임무 목표 사용하기 앞의 두단계에서 빠뜨린 주제가 있는지 임무목표를 사용함
주제 식별 기술 &gt; 예비테이블 목록 체크 &gt; 같은 뜻이면 더 잘 식별하는 이름으로 변경 &gt; 새주제면 예비테이블 목록 추가 예비테이블 목록은 완전하므로 최종 테이블 목록으로 바꿈
테이블 이름 , 종류 설명을 가지고 있음
개요 테이블 종류 데이터 테이블 : 조직의 중요한 주제를 나타내고 데이터 베이스가 제공하는 정보의 첫번째 기초를 이룸
연결테이블 : 다대다 관계의 두테이블 연결을 설정함
부분집합 테이블 : 특정 데이터 테이블과 연결되어 있는 필드를 포함하고 구체적으로 더 설명함
검증 테이블 : 비교적 정적인 데이터를 포함하고 데이터 무결의 중요한 구성요소 설명 : 주제의 명확한 정의를 제공하고 왜 조직에 중요한지 설명 테이블 이름 정제하기 최종 테이블 목록으로 변환하기전 마지막 작업
테이블은 단일 주제를 나타냄으로 주제를 명확히 식별해야만함
유일하고 전체 조직에 의미가 있는 이름을 부여
물리적 특성을 전달하는 단어 사용 ㄴㄴ
최소 개수의 단어 사용
약어 사용 ㄴㄴ
이름의 복수형 사용 테이블 종류 보이기 최종 테이블 목록의 모든항목은 처음에는 데이터 테이블임
아직 관계를 정의하거나 무결성을 부과하지 않았기에 연결테이블, 검증테이블 없음
필드를 할당하지 않았기에 부분집합 테이블도 없음 테이블 설명 작성 주어진 테이블이 왜 존재하고 왜 데이터를 수집하는지 도와줌
정의와 테이블의 중요성에 대한 해설이 둘다 있어야함
지침 정확히 정의하는 문장을 포함한다
왜 테이블이 조직에게 중요한지 설명하는 문장을 포함한다
명확하고 간결한 설명을 작성한다
구현에 관련된 정보를 테이블 설명에 포함시키지않는다
테이블 설명에 예를 사용하지 않는다
ex) 학생 일정 - 이번학사년도내에 학생이 출석하기로 일정을 잡은 클래스들, 이테이블에서 제공되는 정보는 학생이 효과적인 시간관리를 실현하고,학교가 클래스 부단과 학생부담을 추정할 수 있도록 도와준다 사용자 및 관리자와 면담 테이블의 일반적인 설명에 대한 합의를 받기 위함
면담 완료후 메모를 가지고 최종 테이블 설명을 작성 테이블은 필드로 구성
예비필드 목록의 필드를 사용하여 최종 테이블 목록의 각 테이블에 필드를 할당
모든 필드들이 할당될때까지 계속 필드 이름 개선 필드 이름이 모호하거나 불명확할 시 개선이 필요함
지침 유일하고 전체조직에 의미가 있는 설명적 이름을 부여
필드가 나타내는 특성을 정확하게 식별할 수 있는 이름부여
특성의 의미를 전달하기 위한 최소개수의 단어를 사용
두문이나 약어 사용을 사려깊게 사용함
이름을 단수형을 사용한다
타당하고적절한 약어는 필드 이름의 의미를 손상시키지 않을 것 변칙을 해소하기 위해 이상적 필드 사용 잠재적으로 문제가 있는 필드를 식별하기 위해 이상적 필드의 요소를 따르는지 파악
이상적 필드 요소 주제의 고유한 특성을 나타낸다
단지 하나의 값만 포함한다
더 작은 구성요소로 해체 될 수 없다
계산되거나 연결된 값을 포함하지않는다
전체 데이터베이스 구조안에서 유일하다
하나 이상의 테이블에 나타날 때는 속성 대부분을 보유한다 문제의 필드를 식별했는가? 이후에 일들을 함 다중 부분 필드 해소 다중부분은 주소마냥 “부산시 기장군 정관읍”마냥 고유한 여러 항목을 가짐
정보추출하거나 정렬,그룹화하는것이 어려움
필드 값 내의 고유한 항목을 식별하고 각항목을 개별적인 새 필드로 취급함으로써 해결
구분하기 빡센거 악기 ID : GUIT2022 &lt;&lt; 앞에 악기의 범주가 있있고 뒤에 식별번호 이것도 분리해야함ㅋ 다중 값 필드 해소 리스트형태로 된것 쉼표 포함
평탄화함 특성A_1,특성A_2,특성A_3
범주 정보 추출이 지루함
구조가 변동적. 현재상태에서 한특성이 포함하는드 값의 개수를 제한함 필드가 단일값만 여러 레코드로 만들어서 해결
데이터 중복의 문제를 낳음 새테이블 만듬 필드를 테이블로부터 제거하고 새테이블에 원래 테이블과 관계를 맺기 위한 기존필드를 선택함
비록 중복된 데이터를 포함하지만 최소한의 중복임
의존하는 필드를 새 테이블의 구조에 포함시킴으로써 주어진 필드가 다중값필드에 의존하는 상황을 해햇 목적 : 적절한 필드들이 각 테이블에 할당됐고 각 테이블의 구조를 적절히 정의했음을 확인
비정상을 가지고 있는 지 확인
이상적 테이블 사용하기 이상적 테이블의 요소 개체 사건일 수 있는 단일 주제를 나타냄
주 키를 가짐
다중부분,다중값필드를 포함하지않음
계산된 필드를 포함하지 않음
불필요한이중 필드를 포함하지 않음(관계맺는거는 적용 ㄴㄴ)
최소한의 중복데이터만 포함 : 관계 맺는건 ㄱㄴ, 이외에는 일관성무결성에 문제일으킴 불필요한 이중 필드 해소 참조 정보를 제공하기 위한 이중필드는 불필요함 제거 사용자로 하여금 모든 발생하는 값이 사오 일관성 있다는것을 확인하도록 강요 나중에 논리적으로 필요할 경우 뷰를 이용하여서 작업하면됨
같은 종류의 값이 여러번 발생하는것을 나타내기위한 이중필드는 필요없음(평탄화할때) 이건 위에 새테이블 만듬으로 해결 부분집합 테이블 설정하기 어떤 필드들은 항상 값을 포함하지 않음
정말 하나의 주제를 나타내는지 확인
두집합일 수 있고 이 두집합이 여러 공통 특성을 공유할 수 있음 ex) 재고 -&gt; 장비 재고, 책재고 공통항목: 이름, 설명, 현재값
이는 재고 테이블에 의존하는 주제들임 이럴 시 여러개의 주제로하고 하나의 독립테이블(데이터 테이블)에 나머지는 종속 테이블을 만드는것으로 해결
<img alt="assets/Pasted image 20240422025513.png" src="700-컴퓨터과학/assets/pasted-image-20240422025513.png" target="_self" style="width: 300px; max-width: 100%;">
거의 같은 구조를 가진 테이블은 보통 부분 집합 테이블임 &gt; 필드가 불필요하게 중복 &gt; 정제해야함
각 테이블은 같은 주제의 서로다른 측면을 나타냄 ]]></description><link>700-컴퓨터과학/school)-db2-2(설계절차).html</link><guid isPermaLink="false">700-컴퓨터과학/school) DB2-2(설계절차).md</guid><pubDate>Sun, 21 Sep 2025 18:07:55 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 4.46.41]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-4.46.41.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-4.46.41.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 4.46.41.png</guid><pubDate>Tue, 19 Dec 2023 19:46:42 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 4.39.17]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-4.39.17.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-4.39.17.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 4.39.17.png</guid><pubDate>Tue, 19 Dec 2023 19:39:19 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 4.15.52]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-4.15.52.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-4.15.52.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 4.15.52.png</guid><pubDate>Tue, 19 Dec 2023 19:15:55 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 4.12.11]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-4.12.11.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-4.12.11.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 4.12.11.png</guid><pubDate>Tue, 19 Dec 2023 19:12:13 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 4.09.40]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-4.09.40.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-4.09.40.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 4.09.40.png</guid><pubDate>Tue, 19 Dec 2023 19:09:45 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 3.32.10]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.32.10.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.32.10.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 3.32.10.png</guid><pubDate>Tue, 19 Dec 2023 18:32:11 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 3.30.04]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.30.04.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.30.04.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 3.30.04.png</guid><pubDate>Tue, 19 Dec 2023 18:30:47 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 3.27.46]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.27.46.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.27.46.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 3.27.46.png</guid><pubDate>Tue, 19 Dec 2023 18:27:48 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 3.23.03]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.23.03.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.23.03.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 3.23.03.png</guid><pubDate>Tue, 19 Dec 2023 18:23:05 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 3.22.44]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.22.44.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.22.44.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 3.22.44.png</guid><pubDate>Tue, 19 Dec 2023 18:22:46 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 3.22.25]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.22.25.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.22.25.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 3.22.25.png</guid><pubDate>Tue, 19 Dec 2023 18:22:28 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 3.13.00]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.13.00.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.13.00.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 3.13.00.png</guid><pubDate>Tue, 19 Dec 2023 18:13:02 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 3.12.26]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.12.26.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.12.26.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 3.12.26.png</guid><pubDate>Tue, 19 Dec 2023 18:12:28 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 3.04.44]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.04.44.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.04.44.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 3.04.44.png</guid><pubDate>Tue, 19 Dec 2023 18:04:46 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 3.04.26]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.04.26.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.04.26.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 3.04.26.png</guid><pubDate>Tue, 19 Dec 2023 18:04:29 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 3.02.11]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.02.11.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.02.11.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 3.02.11.png</guid><pubDate>Tue, 19 Dec 2023 18:02:12 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 3.00.06]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.00.06.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-3.00.06.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 3.00.06.png</guid><pubDate>Tue, 19 Dec 2023 18:00:08 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 2.53.06]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-2.53.06.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-2.53.06.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 2.53.06.png</guid><pubDate>Tue, 19 Dec 2023 17:53:08 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 2.40.35]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-2.40.35.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-2.40.35.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 2.40.35.png</guid><pubDate>Tue, 19 Dec 2023 17:40:36 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20231220022054]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/pasted-image-20231220022054.png" target="_self">]]></description><link>700-컴퓨터과학/assets/pasted-image-20231220022054.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/Pasted image 20231220022054.png</guid><pubDate>Tue, 19 Dec 2023 17:20:54 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 2.13.44]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-2.13.44.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-2.13.44.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 2.13.44.png</guid><pubDate>Tue, 19 Dec 2023 17:13:47 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 2.10.58]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-2.10.58.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-2.10.58.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 2.10.58.png</guid><pubDate>Tue, 19 Dec 2023 17:11:03 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 2.00.20]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-2.00.20.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-2.00.20.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 2.00.20.png</guid><pubDate>Tue, 19 Dec 2023 17:00:27 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 1.57.07]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-1.57.07.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-1.57.07.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 1.57.07.png</guid><pubDate>Tue, 19 Dec 2023 16:57:10 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20231220015605]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/pasted-image-20231220015605.png" target="_self">]]></description><link>700-컴퓨터과학/assets/pasted-image-20231220015605.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/Pasted image 20231220015605.png</guid><pubDate>Tue, 19 Dec 2023 16:56:05 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 1.49.01]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-1.49.01.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-1.49.01.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 1.49.01.png</guid><pubDate>Tue, 19 Dec 2023 16:49:02 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 1.28.57]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-1.28.57.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-1.28.57.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 1.28.57.png</guid><pubDate>Tue, 19 Dec 2023 16:29:00 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 1.24.54]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-1.24.54.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-1.24.54.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 1.24.54.png</guid><pubDate>Tue, 19 Dec 2023 16:24:57 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 1.24.21]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-1.24.21.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-1.24.21.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 1.24.21.png</guid><pubDate>Tue, 19 Dec 2023 16:24:22 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 1.11.34]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-1.11.34.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-1.11.34.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 1.11.34.png</guid><pubDate>Tue, 19 Dec 2023 16:11:35 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 1.10.53]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-1.10.53.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-1.10.53.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 1.10.53.png</guid><pubDate>Tue, 19 Dec 2023 16:10:55 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 1.06.59]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-1.06.59.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-1.06.59.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 1.06.59.png</guid><pubDate>Tue, 19 Dec 2023 16:07:03 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 12.53.09]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-12.53.09.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-12.53.09.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 12.53.09.png</guid><pubDate>Tue, 19 Dec 2023 15:53:11 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-20 오전 12.53.01]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-12.53.01.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-20-오전-12.53.01.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-20 오전 12.53.01.png</guid><pubDate>Tue, 19 Dec 2023 15:53:03 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-19 오후 11.38.43]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-19-오후-11.38.43.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-19-오후-11.38.43.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-19 오후 11.38.43.png</guid><pubDate>Tue, 19 Dec 2023 14:38:44 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20231216170306]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/pasted-image-20231216170306.png" target="_self">]]></description><link>700-컴퓨터과학/assets/pasted-image-20231216170306.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/Pasted image 20231216170306.png</guid><pubDate>Sat, 16 Dec 2023 08:03:06 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-07 오후 9.59.35]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-07-오후-9.59.35.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-07-오후-9.59.35.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-07 오후 9.59.35.png</guid><pubDate>Thu, 07 Dec 2023 12:59:40 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-07 오후 9.39.37]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-07-오후-9.39.37.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-07-오후-9.39.37.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-07 오후 9.39.37.png</guid><pubDate>Thu, 07 Dec 2023 12:39:42 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-07 오후 9.34.48]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-07-오후-9.34.48.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-07-오후-9.34.48.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-07 오후 9.34.48.png</guid><pubDate>Thu, 07 Dec 2023 12:34:50 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-07 오후 9.31.12]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-07-오후-9.31.12.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-07-오후-9.31.12.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-07 오후 9.31.12.png</guid><pubDate>Thu, 07 Dec 2023 12:31:15 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-07 오후 9.30.22]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-07-오후-9.30.22.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-07-오후-9.30.22.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-07 오후 9.30.22.png</guid><pubDate>Thu, 07 Dec 2023 12:30:25 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-06 오후 9.40.01]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-06-오후-9.40.01.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-06-오후-9.40.01.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-06 오후 9.40.01.png</guid><pubDate>Wed, 06 Dec 2023 12:40:03 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-06 오후 8.42.43]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-06-오후-8.42.43.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-06-오후-8.42.43.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-06 오후 8.42.43.png</guid><pubDate>Wed, 06 Dec 2023 11:42:47 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-06 오후 8.29.19]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-06-오후-8.29.19.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-06-오후-8.29.19.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-06 오후 8.29.19.png</guid><pubDate>Wed, 06 Dec 2023 11:29:22 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-06 오후 8.27.16]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-06-오후-8.27.16.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-06-오후-8.27.16.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-06 오후 8.27.16.png</guid><pubDate>Wed, 06 Dec 2023 11:27:21 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-12-06 오후 3.19.28]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-12-06-오후-3.19.28.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-12-06-오후-3.19.28.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-12-06 오후 3.19.28.png</guid><pubDate>Wed, 06 Dec 2023 06:19:31 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스크린샷 2023-11-25 오후 7.13.54]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/스크린샷-2023-11-25-오후-7.13.54.png" target="_self">]]></description><link>700-컴퓨터과학/assets/스크린샷-2023-11-25-오후-7.13.54.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/스크린샷 2023-11-25 오후 7.13.54.png</guid><pubDate>Sat, 25 Nov 2023 10:14:00 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[📚 801 다 맡게팅]]></title><description><![CDATA[
회원, 매장관리
AI 콘텐츠 생성
SNS 자동업로드
성과 분석
<img alt="📚 801 다 맡게팅-1758471239595.png" height="246" src="99-settings/1-topics/assets/📚-801-다-맡게팅-1758471239595.png" target="_self" style="width: 382px; max-width: 100%;">
🤔 issues <br><a class="internal-link" data-href="../../300-백엔드개발/다른 서비스의 데이터가 필요할 때.md" href="300-백엔드개발/다른-서비스의-데이터가-필요할-때.html" target="_self" rel="noopener nofollow">다른 서비스의 데이터가 필요할 때</a>
<br><a class="internal-link" data-href="../../400-인프라 &amp; 아키텍처/카프카 이벤트 테스트를 어떻게 할까.md" href="400-인프라-&amp;-아키텍처/카프카-이벤트-테스트를-어떻게-할까.html" target="_self" rel="noopener nofollow">카프카 이벤트 테스트를 어떻게 할까</a>
<br><a class="internal-link" data-href="../../400-인프라 &amp; 아키텍처/외부에서 내부 서비스를 접근 못하게...md" href="400-인프라-&amp;-아키텍처/외부에서-내부-서비스를-접근-못하게...html" target="_self" rel="noopener nofollow">외부에서 내부 서비스를 접근 못하게..</a>
<br><a class="internal-link" data-href="../../300-백엔드개발/DTO를 어따둬야 깔끔할까.md" href="300-백엔드개발/dto를-어따둬야-깔끔할까.html" target="_self" rel="noopener nofollow">DTO를 어따둬야 깔끔할까</a> 🚨 error <br><a class="internal-link" data-href="../../400-인프라 &amp; 아키텍처/Error - 장시간 요청 Cloudfront timeout.md" href="400-인프라-&amp;-아키텍처/error-장시간-요청-cloudfront-timeout.html" target="_self" rel="noopener nofollow">Error - 장시간 요청 Cloudfront timeout</a>
<br><a class="internal-link" data-href="../../300-백엔드개발/Error - cookie 역직렬화 문제.md" href="300-백엔드개발/error-cookie-역직렬화-문제.html" target="_self" rel="noopener nofollow">Error - cookie 역직렬화 문제</a>
<br><a class="internal-link" data-href="../../300-백엔드개발/Error - transaction error.md" href="300-백엔드개발/error-transaction-error.html" target="_self" rel="noopener nofollow">Error - transaction error</a>
<br><a class="internal-link" data-href="../../300-백엔드개발/Error-websocket메세지 보내기 전 종료.md" href="300-백엔드개발/error-websocket메세지-보내기-전-종료.html" target="_self" rel="noopener nofollow">Error-websocket메세지 보내기 전 종료</a> 🧠 learned <br><a data-href="webflux vs mvc 관련 의문점" href="300-백엔드개발/webflux-vs-mvc-관련-의문점.html" class="internal-link" target="_self" rel="noopener nofollow">webflux vs mvc 관련 의문점</a>
<br><a class="internal-link" data-href="../../300-백엔드개발/다양한 oauth 인증 방식.md" href="300-백엔드개발/다양한-oauth-인증-방식.html" target="_self" rel="noopener nofollow">다양한 oauth 인증 방식</a>
<br><a class="internal-link" data-href="../../400-인프라 &amp; 아키텍처/kafka 메세지 전송.md" href="400-인프라-&amp;-아키텍처/kafka-메세지-전송.html" target="_self" rel="noopener nofollow">kafka 메세지 전송</a>
<br><a class="internal-link" data-href="../../400-인프라 &amp; 아키텍처/헥사고날 아키텍처.md" href="400-인프라-&amp;-아키텍처/헥사고날-아키텍처.html" target="_self" rel="noopener nofollow">헥사고날 아키텍처</a>
<br><a class="internal-link" data-href="../../300-백엔드개발/proxy.md" href="300-백엔드개발/proxy.html" target="_self" rel="noopener nofollow">proxy</a> ]]></description><link>99-settings/1-topics/📚-801-다-맡게팅.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 801 다 맡게팅.md</guid><pubDate>Sun, 21 Sep 2025 16:50:24 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[proxy]]></title><description><![CDATA[forward proxy reverse proxy
nginx]]></description><link>300-백엔드개발/proxy.html</link><guid isPermaLink="false">300-백엔드개발/proxy.md</guid><pubDate>Sun, 21 Sep 2025 16:48:21 GMT</pubDate></item><item><title><![CDATA[DTO를 어따둬야 깔끔할까]]></title><link>300-백엔드개발/dto를-어따둬야-깔끔할까.html</link><guid isPermaLink="false">300-백엔드개발/DTO를 어따둬야 깔끔할까.md</guid><pubDate>Sun, 21 Sep 2025 16:45:42 GMT</pubDate></item><item><title><![CDATA[외부에서 내부 서비스를 접근 못하게..]]></title><description><![CDATA[aws and docker설정
터널링]]></description><link>400-인프라-&amp;-아키텍처/외부에서-내부-서비스를-접근-못하게...html</link><guid isPermaLink="false">400-인프라 &amp; 아키텍처/외부에서 내부 서비스를 접근 못하게...md</guid><pubDate>Sun, 21 Sep 2025 16:44:55 GMT</pubDate></item><item><title><![CDATA[MJ's Brain]]></title><description><![CDATA[지식을 체계화하기 위해 정리해 나가고 있습니다.
큰 토픽별로 분류 각 폴더로 분류 되어있습니다. 프로젝트 별 분류 <a class="internal-link" data-href="99-Settings/1-Topics/📖 800 프로젝트.md" href="99-settings/1-topics/📖-800-프로젝트.html" target="_self" rel="noopener nofollow">📖 800 프로젝트</a> <br>이 이전에 썼던 blog : <a rel="noopener nofollow" class="external-link is-unresolved" href="https://mj-hope.tistory.com/?page=4" target="_self">https://mj-hope.tistory.com/?page=4</a>]]></description><link>mj's-brain.html</link><guid isPermaLink="false">MJ's Brain.md</guid><pubDate>Sun, 21 Sep 2025 16:37:28 GMT</pubDate></item><item><title><![CDATA[spring filter, servlet]]></title><description><![CDATA[필터,서블릿은 &nbsp;자바 표준 인터페이스임
요청이 들어오면:
서버(WAS)가 요청을 받음
필터 체인(Filter Chain)이 호출되고, 각 필터의 로직이 순서대로 처리됨
마지막 필터가 서블릿(Servlet)에게 요청을 전달
서블릿이 요청을 받아 스프링 DispatcherServlet 등으로 연결해 컨트롤러를 실행
처리 완료 후 응답이 서블릿, 필터를 다시 거쳐 클라이언트로 전달
]]></description><link>300-백엔드개발/spring-filter,-servlet.html</link><guid isPermaLink="false">300-백엔드개발/spring filter, servlet.md</guid><pubDate>Sun, 21 Sep 2025 16:34:34 GMT</pubDate></item><item><title><![CDATA[webflux vs mvc 관련 의문점]]></title><description><![CDATA[
이미 많이 있지만 webflux와 spring mvc를 나의 언어로 정리하고 궁금한 것을 찾아보고자 한다
<a data-href="동기 vs 비동기, 블로킹 vs 논블로킹" href="700-컴퓨터과학/동기-vs-비동기,-블로킹-vs-논블로킹.html" class="internal-link" target="_self" rel="noopener nofollow">동기 vs 비동기, 블로킹 vs 논블로킹</a>
MVC Thread-per-Request : 1요청에 1스레드
Tomcat
Blocking WebFlux Event Loop
Netty
NonBlocking 틀렷으면 이야기 부탁드립니다...CompletableFuture같은 것들 말이지
다 블로킹되면 왜 비동기 쓰지?SpringMVC도 모두 blocking은 아니다! 서버 레벨 I/O만 블러킹된다는것이다.<br>
예를 들어 <a data-href="spring filter, servlet" href="300-백엔드개발/spring-filter,-servlet.html" class="internal-link" target="_self" rel="noopener nofollow">spring filter, servlet</a>, client요청을 읽는 과정에서 블로킹이 발생한다<br>
<a data-tooltip-position="top" aria-label="https://velog.io/@duskafka/%EA%B8%B0%EC%A1%B4-%EC%84%9C%EB%B8%94%EB%A6%BF-%EA%B8%B0%EB%B0%98-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%98-%ED%95%9C%EA%B3%84-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%99%80-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C-%EB%B3%B8-%ED%95%9C%EA%B3%84%EC%A0%90" rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@duskafka/%EA%B8%B0%EC%A1%B4-%EC%84%9C%EB%B8%94%EB%A6%BF-%EA%B8%B0%EB%B0%98-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%98-%ED%95%9C%EA%B3%84-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%99%80-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C-%EB%B3%B8-%ED%95%9C%EA%B3%84%EC%A0%90" target="_self">기존 서블릿 기반 애플리케이션의 한계</a>
But!! WebFlux는 첨부터 끝까지 Non-blocking방식으로 할 수 있음!즉 java코드레벨 비지니스로직은 Java표준에서 제공하는 방식으로 비동기,non-blocking처리될 수 있다.
CompletableFuture은 Java표준에서 제공하는 방식중 하나로 jvm에서 멀티 스레드 방식으로 구현된다웹v8엔진에서 이벤트루프 방식으로 작동하는 방식이랑 비슷한가한 스레드에서 여러 I/O를 처리가능함 How? with EventLoop.<br>
출처 : <a rel="noopener nofollow" class="external-link is-unresolved" href="https://oneny.tistory.com/125" target="_self">https://oneny.tistory.com/125</a><br>
<img alt="webflux vs mvc-1757788425212.png" src="300-백엔드개발/assets/webflux-vs-mvc-1757788425212.png" target="_self">
그렇다 비슷하다 이벤트 루프가 이벤트가 있는지 확인하고 꺼네서 이벤트를 수행하는 방식이다.<br>
<img alt="webflux vs mvc-1757788537542.png" src="300-백엔드개발/assets/webflux-vs-mvc-1757788537542.png" target="_self">Reactor는 일종의 패턴이다 이벤트루프는 이러한 패턴을 구현하기 위한 방식이다.옵저버 패턴도 많이 쓰인다고 들었는데 두개 언제 쓰이지?
내 생각에는 하드웨어를받아서 처리하는 I/O에서는 이벤트루프 , 소프트웨어단으로 넘어가선 옵저버쓸꺼같은데이벤트루프는 하드웨어,Lowlevel과 연관된 I/O작업에 쓰이고 이게 소프트웨어 단으로 넘어가서 객체간에 무언가 이벤트를 트래킹하기위해서는 옵저버 패턴을 씀
리액티브시스템에도 두개 섞어서 많이쓴다캄]]></description><link>300-백엔드개발/webflux-vs-mvc-관련-의문점.html</link><guid isPermaLink="false">300-백엔드개발/webflux vs mvc 관련 의문점.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Sun, 21 Sep 2025 16:34:29 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[그 비지니스 로직분리하기위해서 콜백전달햇던거]]></title><description><![CDATA[나중에함정리 ㄱ]]></description><link>300-백엔드개발/그-비지니스-로직분리하기위해서-콜백전달햇던거.html</link><guid isPermaLink="false">300-백엔드개발/그 비지니스 로직분리하기위해서 콜백전달햇던거.md</guid><pubDate>Sun, 21 Sep 2025 16:33:20 GMT</pubDate></item><item><title><![CDATA[Error-websocket메세지 보내기 전 종료]]></title><link>300-백엔드개발/error-websocket메세지-보내기-전-종료.html</link><guid isPermaLink="false">300-백엔드개발/Error-websocket메세지 보내기 전 종료.md</guid><pubDate>Sun, 21 Sep 2025 16:32:07 GMT</pubDate></item><item><title><![CDATA[헥사고날 아키텍처]]></title><link>400-인프라-&amp;-아키텍처/헥사고날-아키텍처.html</link><guid isPermaLink="false">400-인프라 &amp; 아키텍처/헥사고날 아키텍처.md</guid><pubDate>Sun, 21 Sep 2025 16:30:55 GMT</pubDate></item><item><title><![CDATA[kafka 메세지 전송]]></title><description><![CDATA[어케 메ㅔ싲 전송하ㅡㄴㄴ지메세ㅣㅈ 전송 옵션이 어케되는지<a rel="noopener nofollow" class="external-link is-unresolved" href="https://curiousjinan.tistory.com/entry/kafka-message-delivery-guarantees" target="_self">https://curiousjinan.tistory.com/entry/kafka-message-delivery-guarantees</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://oliveyoung.tech/2024-10-16/oliveyoung-scm-oms-kafka/?keyword=kafka" target="_self">https://oliveyoung.tech/2024-10-16/oliveyoung-scm-oms-kafka/?keyword=kafka</a>]]></description><link>400-인프라-&amp;-아키텍처/kafka-메세지-전송.html</link><guid isPermaLink="false">400-인프라 &amp; 아키텍처/kafka 메세지 전송.md</guid><pubDate>Sun, 21 Sep 2025 16:29:31 GMT</pubDate></item><item><title><![CDATA[Error - transaction error]]></title><link>300-백엔드개발/error-transaction-error.html</link><guid isPermaLink="false">300-백엔드개발/Error - transaction error.md</guid><pubDate>Sun, 21 Sep 2025 16:27:39 GMT</pubDate></item><item><title><![CDATA[다양한 oauth 인증 방식]]></title><link>300-백엔드개발/다양한-oauth-인증-방식.html</link><guid isPermaLink="false">300-백엔드개발/다양한 oauth 인증 방식.md</guid><pubDate>Sun, 21 Sep 2025 16:24:17 GMT</pubDate></item><item><title><![CDATA[Error - cookie 역직렬화 문제]]></title><link>300-백엔드개발/error-cookie-역직렬화-문제.html</link><guid isPermaLink="false">300-백엔드개발/Error - cookie 역직렬화 문제.md</guid><pubDate>Sun, 21 Sep 2025 16:21:05 GMT</pubDate></item><item><title><![CDATA[카프카 이벤트 테스트를 어떻게 할까]]></title><link>400-인프라-&amp;-아키텍처/카프카-이벤트-테스트를-어떻게-할까.html</link><guid isPermaLink="false">400-인프라 &amp; 아키텍처/카프카 이벤트 테스트를 어떻게 할까.md</guid><pubDate>Sun, 21 Sep 2025 16:19:47 GMT</pubDate></item><item><title><![CDATA[도커 명령어]]></title><description><![CDATA[
chmod 600 /Users/jeonminji/Downloads/a071189-key.pem 권한많으면 에러날 수 잇음 ssh -i /Users/jeonminji/Downloads/a071189-key.pem 사용자명@서버주소
Host myserver HostName 서버주소 User 사용자명 IdentityFile /Users/jeonminji/Downloads/a071189-key.pem
ssh myserver ]]></description><link>400-인프라-&amp;-아키텍처/도커-명령어.html</link><guid isPermaLink="false">400-인프라 &amp; 아키텍처/도커 명령어.md</guid><pubDate>Sun, 21 Sep 2025 16:19:38 GMT</pubDate></item><item><title><![CDATA[📚 801 다 맡게팅-1758471239595]]></title><description><![CDATA[<img src="99-settings/1-topics/assets/📚-801-다-맡게팅-1758471239595.png" target="_self">]]></description><link>99-settings/1-topics/assets/📚-801-다-맡게팅-1758471239595.html</link><guid isPermaLink="false">99-Settings/1-Topics/assets/📚 801 다 맡게팅-1758471239595.png</guid><pubDate>Sun, 21 Sep 2025 16:13:59 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[📚 801 다 맡게팅-1758471209903]]></title><description><![CDATA[<img src="99-settings/1-topics/assets/📚-801-다-맡게팅-1758471209903.png" target="_self">]]></description><link>99-settings/1-topics/assets/📚-801-다-맡게팅-1758471209903.html</link><guid isPermaLink="false">99-Settings/1-Topics/assets/📚 801 다 맡게팅-1758471209903.png</guid><pubDate>Sun, 21 Sep 2025 16:13:29 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[📚 705 보안]]></title><description><![CDATA[보안 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 700 컴퓨터 과학" href="99-settings/1-topics/📖-700-컴퓨터-과학.html" class="internal-link" target="_self" rel="noopener nofollow">📖 700 컴퓨터 과학</a>
]]></description><link>99-settings/1-topics/📚-705-보안.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 705 보안.md</guid><pubDate>Sun, 21 Sep 2025 15:59:16 GMT</pubDate></item><item><title><![CDATA[JS-제너레이터]]></title><description><![CDATA[<a class="internal-link" data-href="제너레이터(javascript) f5deabc515314f49add882764d4f7621/사용예 74fe883da3124b22af032137691e6a07.md" href=".html" target="_self" rel="noopener nofollow">사용예</a>일반적인 함수는 하나의 값을 반환한다. 제너레이터는 여러개의 값을 하나씩 반환 가능하다.<br><img alt="스크린샷 2023-02-27 오후 10.14.26.png" src="200-웹개발/assets/스크린샷_2023-02-27_오후_10.14.26.html" target="_self">제너레이터 안에 제너레이터function* generateSequence(start, end) { for (let i = start; i &lt;= end; i++) yield i;
} function* generatePasswordCodes() { // 0..9 yield* generateSequence(48, 57); // A..Z yield* generateSequence(65, 90); // a..z yield* generateSequence(97, 122);
} let generator = generatePasswordCodes();
console.log(generator.next());
console.log(generator.next()); let num = 0;
let str = "";
for (let code of generatePasswordCodes()) { str += code + "|"; num++;
}
console.log(str);
console.log([...generatePasswordCodes()]);
console.log("----------" + num + "회 호출---------");
<br><img alt="스크린샷 2023-02-28 오후 4.13.41.png" src="200-웹개발/assets/스크린샷_2023-02-28_오후_4.13.41.html" target="_self"><br><img alt="스크린샷 2023-02-28 오후 4.59.44.png" src="200-웹개발/assets/스크린샷_2023-02-28_오후_4.59.44.html" target="_self">function* gen() { let ask1 = yield "2 + 2 = ?"; alert(ask1); // 4 let ask2 = yield "3 * 3 = ?" alert(ask2); // 9
} let generator = gen(); alert( generator.next().value ); // "2 + 2 = ?" alert( generator.next(4).value ); // "3 * 3 = ?" alert( generator.next(9).done ); // true
제너레이터 함수는 여러 가지 장점이 있습니다.
비동기 처리: 제너레이터 함수는 비동기 처리와 함께 사용되면 유용하게 활용될 수 있습니다. 이를 통해 비동기적으로 실행되는 코드를 동기적으로 작성할 수 있습니다.
실행 중단 및 재개: 제너레이터 함수는 실행 중간에 멈출 수 있으며, 이후 다시 재개할 수 있습니다. 이를 통해 함수의 실행 흐름을 더욱 세밀하게 제어할 수 있습니다.
무한 시퀀스 생성: 제너레이터 함수는 무한한 시퀀스를 생성할 수 있습니다. 이를 통해 메모리 사용을 최적화할 수 있습니다.
이터러블 객체 생성: 제너레이터 함수는 이터러블 객체를 생성할 수 있습니다. 이를 통해 for...of 문과 같은 반복문에서 사용할 수 있습니다.
위와 같은 장점을 갖고 있어서, 제너레이터 함수는 ES6 이후 자바스크립트에서 많이 사용되고 있습니다.제너레이터 함수의 활용 예시로는, 이터러블 객체를 생성하는 것이 있습니다. 이터러블 객체를 생성하면 for...of 문을 사용해 반복문을 실행할 수 있습니다. 아래는 1부터 시작해서 2씩 증가하는 무한한 시퀀스를 생성하는 예제입니다.function* generateSequence() { let num = 1; while (true) { yield num; num += 2; }
} const sequence = generateSequence();
console.log(sequence.next().value); // 1
console.log(sequence.next().value); // 3
console.log(sequence.next().value); // 5 위 예제에서 generateSequence 함수는 제너레이터 함수입니다. 이 함수는 무한한 시퀀스를 생성하며, while 문과 함께 사용되어 끝없는 시퀀스를 생성합니다. sequence 변수에는 generateSequence 함수를 호출한 결과가 할당되며, 이 변수를 사용해 시퀀스를 생성할 수 있습니다. sequence.next()는 시퀀스에서 다음 값을 가져옵니다. 이를 통해 1, 3, 5와 같은 값을 생성할 수 있습니다.또한, 제너레이터 함수는 비동기 처리와 함께 사용될 때 유용하게 활용될 수 있습니다. 예를 들어, 서버로부터 데이터를 가져와서 화면에 출력하는 작업을 할 때, 제너레이터 함수를 사용하면 비동기적으로 데이터를 가져와서 화면에 출력할 수 있습니다.아래는 제너레이터 함수를 사용한 비동기 데이터 가져오기 예제입니다.function* fetchData() { const data = yield fetch('&lt;https://jsonplaceholder.typicode.com/todos/1&gt;'); console.log(data);
} const gen = fetchData();
const result = gen.next(); result.value .then(response =&gt; response.json()) .then(data =&gt; gen.next(data)); 위 예제에서 fetchData 함수는 제너레이터 함수입니다. 이 함수는 fetch 함수를 호출하고, 데이터를 가져오는 작업을 수행합니다. 그리고 데이터를 가져오면, console.log를 사용해 데이터를 출력합니다. gen 변수에는 fetchData 함수를 호출한 결과가 할당되며, 이 변수를 사용해 데이터를 가져올 수 있습니다. result 변수에는 gen.next()를 호출한 결과가 할당되며, 이를 통해 fetchData 함수의 첫 번째 yield 문에서 멈춥니다. 그리고 result.value.then을 사용해 데이터를 가져와서 gen.next(data)를 호출하면 fetchData 함수가 다시 실행됩니다.이처럼 제너레이터 함수를 사용하면 비동기 처리를 더욱 쉽게 구현할 수 있습니다.제너레이터 함수는 실행 중간에 멈출 수 있고, 이후 다시 재개할 수 있습니다. 이를 통해 함수의 실행 흐름을 더욱 세밀하게 제어할 수 있습니다. 아래는 제너레이터 함수를 사용한 실행 중단 및 재개 예제입니다.function* foo() { console.log('start'); yield; console.log('middle'); yield; console.log('end');
} const f = foo();
f.next(); // 'start'
f.next(); // 'middle'
f.next(); // 'end' 위 예제에서 foo 함수는 제너레이터 함수입니다. 이 함수에는 console.log를 사용해 'start', 'middle', 'end'를 출력하는 코드가 있습니다. f 변수에는 foo 함수를 호출한 결과가 할당되며, f.next()를 호출하면 foo 함수가 실행됩니다. 그리고 yield 문에서 멈춥니다. 이후 f.next()를 다시 호출하면, foo 함수가 이전 위치에서 다시 실행되며, 다음 yield 문에서 멈춥니다. 이를 통해 함수의 실행 흐름을 세밀하게 제어할 수 있습니다.마지막으로, 제너레이터 함수는 무한한 시퀀스를 생성할 수 있습니다. 이를 통해 메모리 사용을 최적화할 수 있습니다. 아래는 제너레이터 함수를 사용한 무한한 시퀀스 생성 예제입니다.function* infiniteSequence() { let num = 0; while (true) { yield num++; }
} const generator = infiniteSequence(); console.log(generator.next().value); // 0
console.log(generator.next().value); // 1
console.log(generator.next().value); // 2 위 예제에서 infiniteSequence 함수는 제너레이터 함수입니다. 이 함수는 무한한 시퀀스를 생성하며, while 문과 함께 사용되어 끝없는 시퀀스를 생성합니다. generator 변수에는 infiniteSequence 함수를 호출한 결과가 할당되며, 이 변수를 사용해 시퀀스를 생성할 수 있습니다. generator.next()는 시퀀스에서 다음 값을 가져옵니다. 이를 통해 0, 1, 2와 같은 값을 생성할 수 있습니다.위와 같이 제너레이터 함수는 ES6 이후 자바스크립트에서 많이 사용되고 있으며, 여러 가지 장점을 갖고 있습니다. 이를 통해 비동기 처리를 더욱 쉽게 구현하고, 실행 흐름을 더욱 세밀하게 제어할 수 있으며, 무한한 시퀀스를 생성할 수 있습니다.]]></description><link>200-웹개발/js-제너레이터.html</link><guid isPermaLink="false">200-웹개발/JS-제너레이터.md</guid><pubDate>Sun, 21 Sep 2025 08:18:54 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[JS-this]]></title><description><![CDATA[
자신이 속한 객체 또는 생성할 인스턴트를 가리키는 자기 참조 변수.
호출될 때 동적으로 값이 결정된다.
생성자 함수에서는 this 가 추후 생성될 인스턴스에 바인딩됨.function Circle(radius){ this.radius = radius; this.getDiameter = function (){ return 2 * this.radius; }
} const circle1 = new Circle(10);
const circle2 = Circle(10)
console.log(circle1.getDiameter()); //20
console.log(circle2) //undefined
console.log(circle2.getDiameter()); //error
“new” 와 함깨 호출하지 않으면 일반함수로 동작.메서드 내부의 this는 메서드를 호출한 객체에 바인딩된다.const person = { name:'Lee', getName(){ console.log(this); return this.name; }
} function Person(name){ this.name = name; this.getName = function(){ console.log(this); return this.name; }
} const person1=new Person("Lee");
const getName1 = person.getName; person.getName();//{ name: 'Lee', getName: [Function: getName] }
person1.getName();//Person { name: 'Lee', getName: [Function] }
getName1();//window
//return는 undefined window.name이없으니깐..
일반 함수로 호출된 모든 함수의 내부 this에는 전역 객체가 바인딩된다.function foo(){ console.log(this);//window function bar(){ console.log(this);//window } bar();
} const obj = { value: 100, foo(){ console.log(this);//obj function bar(){ console.log(this);//window } bar(); }, poo(){ setTimeout(function(){ console.log(this);//window },100) },
}
const obj = { value: 100, poo(){ const that = this; setTimeout(function(){ console.log(this);//window console.log(that.value);//100 },100) },
}
화살표 함수의 내부 this는 상위 스코프 this를 가리킨다.const obj = { value: 100, poo(){ const that = this; setTimeout(()=&gt;{ console.log(this.value);//100 },100) },
} apply, call
기본적으론 함수 호출하는 것.첫번째 인수로 전달한 객체를 this에 바인딩function getThisBinding(){ console.log(arguments); return this;
} const thisArg = { a : 1 };
console.log(getThisBinding.apply(thisArg,[1,2,3]));
//Arguments(3) 1,2,3
//{a : 1}
console.log(getThisBinding.call(thisArg,1,2,3));
//Arguments(3) 1,2,3
//{a : 1} bind
함수 호출 X , this 바인딩이 bind의 첫번째 인수로 교채된 함수로 반환.function getThisBinding(){ console.log(arguments); return this;
} const thisArg = { a : 1 };
console.log(getThisBinding.bind(thisArg)());
//{a : 1} var healthObj = { name : "달리기", lastTime : "PM10:12", showHealth : function() { setTimeout(function(){ console.log(this.name + "님, 오늘은 " + this.lastTime + "에 운동을 하셨네요"); }.bind(this), 500); }
}
]]></description><link>200-웹개발/js-this.html</link><guid isPermaLink="false">200-웹개발/JS-this.md</guid><pubDate>Sun, 21 Sep 2025 08:17:16 GMT</pubDate></item><item><title><![CDATA[JS-prototype]]></title><description><![CDATA[자바스크립트의 모든 객체는 [[Prototype]]이라는 숨김 프로퍼티를 가지고 있다.그리고 이 참조 대상을 prototype 이라고 부른다.이것은 상속 받아 사용할 수 있고 해당 객체에서 해당 프로퍼티가 없을 시 프로토타입에서 해당 프로퍼티를 찾게된다.let A = { name: "A" };
let B = { name: "B" };
B.__proto__ = A; console.log(B.__proto__);//{name: "}
console.log(A.__proto__);//{}
<img alt="Untitled" src="200-웹개발/assets/prototype.png" target="_self"> [[Prototype]] : 숨김 프로퍼티, 객체를 참조하거나 null값을 갖는다.prototype: [[Prototype]] 숨김 프로퍼티가 참조하는 대상이다.<br>__proto__ : <a data-href="**Prototype**" href=".html" class="internal-link" target="_self" rel="noopener nofollow">**Prototype**</a>의 getter setter , null이나 객체만 가능, 다른자료형 무시함수 객체에는 prototype이라는 일반프로퍼티도 있지만 이후에 다룰 예정.let A = { name: "A", age: 30, id: "25532" };
let B = { name: "B", age: 26 };
let C = { name: "C" }; B.__proto__ = A;
C.__proto__ = B; console.log(C.name);//C
console.log(C.age);//26
console.log(C.id);//25532
자신에게 해당 프로퍼티가 있다면 그 값을 리턴하고,참조된 prototype을 순서대로 확인하여 가까운 프로퍼티값을 리턴한다.prototype의 값은 변경이 불가능하다.값을 변경할려면 해당 객체에서 변경을 해야한다.let user = { name: "John", surname: "Smith", fullName: "John Smith"
}; let admin = { __proto__: user, isAdmin: true
}; console.log(admin.fullName); // John Smith (*) admin.fullName = "Alice Cooper"; console.log(admin.fullName);//Alice Cooper"
console.log(user.fullName);//John Smith
이렇게 프로퍼티를 할당할려고하면 prototype에 있는 프로퍼티임에도 불구하고 admin객체에 해당 프로퍼티가 추가된다.let user = { name: "John", surname: "Smith", set fullName(value) { [this.name, this.surname] = value.split(" "); }, get fullName() { return `${this.name} ${this.surname}`; }
}; let admin = { __proto__: user, isAdmin: true
}; console.log(admin.fullName); // John Smith (*) // setter 함수가 실행됩니다!
admin.fullName = "Alice Cooper"; // (**) console.log(admin.fullName); // Alice Cooper, setter에 의해 추가된 admin의 프로퍼티(name, surname)에서 값을 가져옴
console.log(user.fullName); // John Smith, 본래 user에 있었던 프로퍼티 값
프로퍼티의 메서드는 실행되나 user의 프로퍼티 값은 그대로고 admin에 값이 추가된다.키-값을 순회하는 대부분이 메서드는 상속프로퍼티를 제외하고 작동한다
Object.keys
Object.values
for … in 반복문: 상속프로퍼티도 순회한다.함수를 이용하여 객체를 만들 수 있다. 이러한 생성자 함수에는 prototype이라는 일반 프로퍼티가있다. prototype프로퍼티에 할당된 객체는 새로운 객체가 생성될 시의 프로퍼티가 된다.let animal = { eats: true
}; function Rabbit(name) { this.name = name;
} Rabbit.prototype = animal; let rabbit = new Rabbit("흰 토끼");
//rabbit의 [[prototype]] : aniaml console.log( rabbit.eats ); // true
console.log(rabbit.__proto__);// {eats: true}
모든 함수는 prototype 프로퍼티를 갖는다.아무 것도 지정하지 않았을시 갖는 default prototype은 constructor하나만 있는 객체를 가리키고이 constructor의 값은 이 값의 생성자 함수를 가리킨다.생성자 함수를 모를 때 이를 이용하여 생성자 함수를 찾을 수 있다.function Rabbit() {}
let rabbit = new Rabbit()
alert( Rabbit.prototype.constructor === Rabbit ); // true
alert(rabbit.constructor == Rabbit);//rabbit은 prototype프로퍼티는 없음
하지만 prototype에 다른 객체를 할당하면 이 default프로퍼티는 없어지게 된다let animal = { eats: true
}; function Rabbit(name) { this.name = name;
} Rabbit.prototype=animal;
let rabbit = new Rabbit()
console.log(Rabbit.prototype.constructor === Rabbit) //false
console.log(rabbit.constructor == Rabbit) //Object(){}
그대로 constructor 를 유지할려면 prototype 객체에 프로퍼티를 추가하면된다..]]></description><link>200-웹개발/js-prototype.html</link><guid isPermaLink="false">200-웹개발/JS-prototype.md</guid><pubDate>Sun, 21 Sep 2025 08:17:16 GMT</pubDate><enclosure url="200-웹개발/assets/prototype.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="200-웹개발/assets/prototype.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[JS-함수 심화학습]]></title><description><![CDATA[
자기 자신을 호출하는 함수
재귀 호출의 최대 개수(재귀 깊이)를 제한하고 있다. function pow(x, n) { let result = 1; for (let i = 0; i &lt; n; i++) { result *= x; } return result;
} function pow(x, n) { return (n == 1) ? x : (x * pow(x, n - 1));
}
반복문으로도 표현 가능하지만 , 재귀를 이용하면 훨신 더 간결하고 유지보수가 쉬운 코드를 만들 수 있을 때가 있다.하지만 반복문은 메모리를 더 적게 사용하고 재귀는 메모리를 더 많이 잡아먹는다실행 컨텍스트 : 해당 함수의 실행 절차, 변수의 현재값, this의 값등 의 함수 실행에대한 세부 정보를 담고 있는 내부 데이터 구조1 함수 호출 = 1 실행 컨텍스트 생성
스택 최상단에 현재 컨텍스트가 '기록’됩니다.
서브 호출을 위한 새로운 컨텍스트가 만들어집니다.
서브 호출이 완료되면. 기존 컨텍스트를 스택에서 꺼내(pop) 실행을 이어나갑니다.
이후 간단히 표기할 실행 컨텍스트{ 인수 , 함수의 실행 위치}(1) function pow(x, n) { if (n == 1) {
(2) return x; } else {
(3) return x * pow(x, n - 1); }
} alert( pow(2, 3) ); pow(2,3)이 호출 된 순간
실행 컨텍스트 | { x : 2 , n : 3 , ( 1 )} |
(3) 위치에서 pow(2,2)가 호출 된 순간
실행 컨텍스트 | { x : 2 , n : 2 , ( 1 )} |
| { x : 2 , n : 3 , ( 3 )} |
(3) 위치에서 pow(2,1)가 호출 된 순간
실행 컨텍스트 | { x : 2 , n : 1 , ( 1 )} |
| { x : 2 , n : 2 , ( 3 )} |
| { x : 2 , n : 3 , ( 3 )} |
n==1 을 만족 시킴으로 x가 리턴되면서 함수 종료 됨
실행 컨텍스트 | { x : 2 , n : 1 , ( 1 )} | ⇒ 2 반환 → pop
| { x : 2 , n : 2 , ( 3 )} |
| { x : 2 , n : 3 , ( 3 )} |
———————————————
| { x : 2 , n : 2 , ( 3 )} | 실행 → pow(2,1)결과 알고잇음으로 4 반환 → pop
| { x : 2 , n : 3 , ( 3 )} |
———————————————
| { x : 2 , n : 3 , ( 3 )} | 실행 → pow(2,2)결과 알고잇음으로 8 반환 → pop
깊이 탐색하는 알고리즘을 구현할 때 사용가능 dfs 같은..queue 나 deque의 자료구조를 이용할 때 shift() 나 unshift() 를 이용하면 시간 복잡도가 크다. O(n)형태let list = { value : 값, next : 다음 객체 참조
}
“함수 심화학습 78247e2a19094e7fb4a96710da56ace6/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-01-16_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.20.01.png” could not be found.
let list1 = { value : 1, next : null,
} let list2 = { value : 2, next : list3,
} let list3 = { value : 3, next : null,
} /**
원래 형태
list1 list2 -&gt; list3
**/ // 추가
list3.next = {value : 4}
list1.next = list2
/**
추가 후 형태
list1 -&gt; list2 -&gt; list3 -&gt; {value:4}
**/
남아 있는 매개변수들을 배열에 넣어서 반환function test(a,b,...c){ console.log(a);// 1 console.log(b);// 2 console.log(c);// [3,4,5,6,7]
} test(1,2,3,4,5,6,7);
남아있는 매개변수를 담기에 중간에 있으면 안됨.a , …b , c 불가능.나머지 매개변수 전에 쓰였던 것이터러블 객체지만 배열은 아님화살표 함수는 arguments가 없음 , 호출 시 외부 일반 함수의 arguments 반환function showName() { alert( arguments.length ); alert( arguments[0] ); alert( arguments[1] );
} // 2, Bora, Lee가 출력됨
showName("Bora", "Lee"); // 1, Bora, undefined가 출력됨(두 번째 인수는 없음)
showName("Bora");
배열을 통체로 매개변수로 넘겨 주는것
배열을 인수로 전달 할 때
let arr1 = [1, -2];
let arr2 = [8, 3]; Math.max(1, ...arr1, 2, ...arr2, 25) //25
//이 두개는 같다.
Math.max(1, 1, -2, 2, 8, 3, 25) //25 배열을 합칠 때
let arr1 = [1, -2];
let arr2 = [8, 3]; let arr3 = [...arr1, ...arr2] //[1,-2,8,3] 배열을 복사 할 때
Object.assign({}, obj) 도 이용할 수 있긴 하지만 이 편이 더 간단하다.
let arr1 = [1, -2];
let copyarr1 = [...arr1]; console.log(arr1 ===copyarr1); //false
여기서의 변수는 let과 const만 다룬다.코드블록 { } 안에서 선언한 변수는 블록 안에서만 사용 가능하다.{ // 지역 변수를 선언하고 몇 가지 조작을 했지만 그 결과를 밖에서 볼 수 없습니다. let message = "안녕하세요."; // 블록 내에서만 변숫값을 얻을 수 있습니다. alert(message); // 안녕하세요.
} alert(message); // ReferenceError: message is not defined
스크립트 전체 , 코드블록 , 호출된 함수는 렉시컬환경이라는 내부수김 연관 객체를 갖는다.(실제로 접근은 불가.)생성된 기준으로 렉시컬환경을 갖는다.
환경 레코드
모든 지역 변수와 함수를 프로퍼티로 저장하고 있는 객체
this값과 같은 정보도 여기에서 저장
외부 렉시컬 환경에 대한 참조
외부 코드와 연관됨
변수는 환경 레코드의 프로퍼티. 변수 변경시 환경레코드의 프로퍼티가 변경됨“함수 심화학습 78247e2a19094e7fb4a96710da56ace6/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-01-16_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.34.12.png” could not be found.(1) 스크립트 시작시 변수가 렉시컬 환경에 올라간다. 변수상태는 uninitialized가 된다. 변수상태를 인지는 하고 있으나 변수를 참조할 수 없다.(2) 변수가 선언됨. 값을 할당하지 않았으면 undefined의 값을 가지게 된다.(3,4) 값이 할당바로 초기화 됨. 렉시컬환경이 만들어 지는 즉시 사용가능.함수를 호출해 실행하면 새로운 렉시컬환경이 자동으로 만들어진다.이 새로운 렉시컬환경에서는 매개 변수와 해당 함수의 지역 변수들을 저장하고 외부 렉시컬을 참조한다.변수에 접근 시 내부 렉시컬 → 참조하는 외부 렉시컬 순으로 확장하며 검색.“함수 심화학습 78247e2a19094e7fb4a96710da56ace6/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-01-16_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.52.29.png” could not be found.반환된 내부함수가 자신이 선언됐을 때의 환경(Lexical environment)인 스코프를 기억하여 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 환경(스코프)에 접근할 수 있는 함수function makeCounter() { let count = 0; return function() { return count++; };
} let counter = makeCounter(); console.log(counter());//0
console.log(counter());//1
console.log(counter());//2
“함수 심화학습 78247e2a19094e7fb4a96710da56ace6/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-01-19_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.05.15.png” could not be found.makeCounter를 호출할때마다 새로운 렉시컬이 생성됨.makeCounte는 실행되고 반환되었지만 익명함수는 생성만되고 실행되지 않음.즉, 익명함수의 렉시컬환경은 기억되고 있음.이 익명함수는 count라는 makeCounter이라는 내부변수를 참조하고 있는데 때문에 count의 값은 계속 기억되고 있음.
정보 은닉
count변수는 외부에서 접근이 불가능하다. 때문에 의도적인 변경을 피할수 있어 안정적이다.
메모리 많이 차지
해당 환경의 변수를 사용하고 있어서 지워지않는 거기 때문에 메모리를 많이 잡아 먹는다.
전역 객체를 이용하여 어디서나 사용 가능한 변수나 함수를 만들 수 있음브라우저 환경 - windownode.js - global현재는 globalThis로 표준화var은 전역 객체의 프로퍼티가 되지만 let은 그렇지 않다.window.alert("hello") var gVar = 5;
alert(window.gVar); //5 let gLet = 5;
alert(window.gLet); // undefine
모든 곳에서 사용가능한 변수 만들기// 모든 스크립트에서 현재 사용자(current user)에 접근할 수 있게 이를 전역 객체에 추가함
window.currentUser = { name: "John"
}; // 아래와 같은 방법으로 모든 스크립트에서 currentUser에 접근할 수 있음
alert(currentUser.name); // John // 지역 변수 'currentUser'가 있다면
// 지역 변수와 충돌 없이 전역 객체 window에서 이를 명시적으로 가져올 수 있음
alert(window.currentUser.name); // John
전역객체를 이용하여 해당 기능 지원하는지 확인if (!window.Promise) { alert("구식 브라우저를 사용 중이시군요!");
} if (!window.Promise) { window.Promise = ... // 모던 자바스크립트에서 지원하는 기능을 직접 구현함
} javascript에서의 함수는 객체이다.
따라서 함수에 프로퍼티를 추가,제거,참조할 수 있다.
함수의 이름을 가져올 수 있다. 메서드에서도 이를 사용이 가능하며 익명함수도 자동으로 이름이 할당된다.let sayHi = function() { alert("Hi");
}; alert(sayHi.name); // sayHi (익명 함수이지만 이름이 있네요!)
매개변수의 개수를 반환나머지 매개변수는 이에 포함이 되지않음함수의 타입검사를 위해서도 종종 사용됨자체적으로 프로퍼티를 추가할 수도 있다.function sayHi() { alert("Hi"); // 함수를 몇 번 호출했는지 세봅시다. sayHi.counter++;
}
sayHi.counter = 0; // 초깃값 sayHi(); // Hi
sayHi(); // Hi alert( `호출 횟수: ${sayHi.counter}회` ); // 호출 횟수: 2회
프로퍼티는 변수가 아니라 여기에 let counter을 선언하고 실행하여도 아무 상관이 없다클로저를 함수 프로퍼티로 대체 가능하다.function makeCounter() { //함수 프로퍼티 function counter() { return counter.count++; }; counter.count = 0; return counter;
} function makeCounter() {//클로저 let count = 0 return function counter() { return count++; };
}
클로저로 생성시 외부에서 count에 접근이 불가능하지만 함수프로퍼티를 사용시 외부에서 값을 수정 가능하다.문자열을 함수로 변환함.let func = new Function ([arg1, arg2, ...argN], functionBody); 일반적인 함수와 다르게 현재 렉시컬환경을 참조하는 것이 아닌 전역 렉시컬을 참조하게 된다.
//make function with 'new Function'
function getFunc() { let value = "test"; let func = new Function('alert(value)'); return func;
}
getFunc()(); // ReferenceError: value is not defined //general function
function getFunc() { let value = "test"; let func = function() { alert(value); }; return func;
} getFunc()(); // getFunc의 렉시컬 환경에 있는 값 "test"가 출력됩니다. 일정 시간이 지난 후에 원하는 함수를 호출할 수 있게 하는 것 setTimeout : 일정 시간이 지난 후에 함수를 실행할 수 있다.
setInterval : 일정한 간격을 두고 함수를 실행할 수 있다.
//문법
let timerId = setTimeout(func, [delay], [arg1], [arg2], ...);//스케줄링
clearTimeout(timerId);//스케줄링 취소 //사용 예제
function sayHi(who, phrase) { alert( who + ' 님, ' + phrase );
} setTimeout(sayHi, 1000, "홍길동", "안녕하세요."); //1초 뒤, '홍길동 님, 안녕하세요.'
일정한 간격을 두고 함수를 실행할 수 있다. 이후에 나올 setInterval과 비슷한 역할을 한다. delay를 변수로 두어 함수를 실행할 때마다 일정하게 간격을 조정할 수 있다.let timerId = setTimeout(function tick() { alert('째깍'); timerId = setTimeout(tick, 2000); // (*)
}, 2000);
setInterval은 지연간격에 함수의 실행시간을 포함시킨다.“함수 심화학습 78247e2a19094e7fb4a96710da56ace6/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-01-20_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_4.09.27.png” could not be found.setInterval“함수 심화학습 78247e2a19094e7fb4a96710da56ace6/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-01-20_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_4.09.38.png” could not be found.중첩 setTimeout반면 , setTimeout은 함수가 끝나고 지연시간을 잰다.function slow(x) { alert(`slow(${x})을/를 호출함`); return x;
} function cachingDecorator(func) {//클로저 let cache = new Map(); return function(x) {// func를 캐싱 로직으로 감쌈.(wrapper) if (cache.has(x)) { // cache에 해당 키가 있으면 return cache.get(x); // 대응하는 값을 cache에서 읽어옵니다. } let result = func(x); // 그렇지 않은 경우엔 func를 호출하고, cache.set(x, result); // 그 결과를 캐싱(저장)합니다. return result; };
} slow = cachingDecorator(slow);
decorator : 위의 cachingDecorator같이 인수로 받은 함수의 행동을 변경시켜주는 함수decorator를 이용하면 장점
cachingDecorator를 재사용 할 수 있습니다. 원하는 함수 어디에든&nbsp;cachingDecorator를 적용할 수 있습니다.
캐싱 로직이 분리되어&nbsp;slow&nbsp;자체의 복잡성이 증가하지 않습니다.
필요하다면 여러 개의 데코레이터를 조합해서 사용할 수도 있습니다(추가 데코레이터는&nbsp;cachingDecorator&nbsp;뒤를 따릅니다).
this를 명시적으로 고정해 함수를 호출 가능func.call(context, arg1, arg2, ...)
// worker.slow에 캐싱 기능을 추가해봅시다.
(3)let worker = { someMethod() { return 1; }, slow(x) { // CPU 집약적인 작업이라 가정 alert(`slow(${x})을/를 호출함`); return x * this.someMethod(); // (*) }
}; // 이전과 동일한 코드
function cachingDecorator(func) { let cache = new Map(); return function(x) { if (cache.has(x)) { return cache.get(x); } console.log(this);//{someMethod:~,slow:~} let result = func(x); cache.set(x, result); return result; };
} (1) worker.slow = cachingDecorator(worker.slow); // 캐싱 데코레이터 적용 (2)alert( worker.slow(2) ); // 에러 발생!, Error: Cannot read property 'someMeth this 는 함수가 호출 될 때 결정된다.
함수에서의 this 일반적으론 전역 객체가 바인딩된다.
메소드일 경우 해당 객체가 바인딩된다.
메소드의 내부함수는 전역객체가 바인딩된다. 따라서 ,(1) 실행후의 worker,let worker = { someMethod() { return 1; }, slow: function(x) { //cache변수는 메모리에 저장되어 있었기 때문에 사용가능 (클로저) if (cache.has(x)) { return cache.get(x); } (3)console.log(this);//{someMethod:~,slow:~} let result = function(x){ alert(`slow(${x})을/를 호출함`); (4)return x * this.someMethod(); }; cache.set(x, result); return result; };
};
(2) 실행 후,(3)에서 worker에 할당된 객체를 가르킴(4)에서는 메소드 내부함수 이므로 전역객체가 바인딩됨.전역객체에 someMethod따위는 없음 → 에러해결let worker = { someMethod() { return 1; }, slow(x) { alert(`slow(${x})을/를 호출함`); return x * this.someMethod(); }
}; function cachingDecorator(func) { let cache = new Map(); return function(x) { if (cache.has(x)) { return cache.get(x); } let result = func.call(this, x); //this를 worker로 고정 cache.set(x, result); return result; };
} worker.slow = cachingDecorator(worker.slow); // 캐싱 데코레이터 적용
argument를 이용한 코드let worker = { slow(min, max) { alert(`slow(${min},${max})을/를 호출함`); return min + max; }
}; function cachingDecorator(func, hash) { let cache = new Map(); return function() { let key = hash(arguments); // (*) if (cache.has(key)) { return cache.get(key); } let result = func.call(this, ...arguments); cache.set(key, result); return result; };
} function hash(args) { return args[0] + ',' + ar함
뒤에 인수를 각각 넣어야하기 때문에 …을 이용기능은 func.call이랑 같은데 인자를 각각 넣는대신 유사 배열을 넣어주면됨func.apply(context, args)
위의 argument를 이용한 코드에서 let result = func.call(this, ...arguments); 대신let result = func.apply(this, arguments);를 넣으면됨.
하객체 메서드안에 funtion이 호출될때 this가 사라지는 문제 해결방법!let user = { firstName: "John", sayHi() { alert(`Hello, ${this.firstName}!`); }
}; 1)setTimeout(user.sayHi, 1000); // Hello, undefined! 2)setTimeout(function() { user.sayHi(); // Hello, John!
}, 1000);
1)번은 user의 문맥을 읽고 sayhi 함수만 전달되게 된다2)번은 wrapper로 감싸 user.sayHi()를 호출함으로써 user의 문맥을 그대로 가지고 간다.취약성 : 실행되전 1초안에 user가 바뀌면 변경된 객체의 메서드를 호출this를 특정한객체로 고정하게 해주는 함수이후 인수도 고정해서 바인딩할수도 있음let bound = func.bind(context, [arg1], [arg2], ...); call,apply와의 차이점 : bind는 함수를 실행시키지 않음.
let user = { firstName: "John"
}; function func() { alert(this.firstName);
} let funcUser = func.bind(user);
funcUser(); // John
bind호출 시점에서의 user가 this로 고정됨. 위의경우처럼 시간 딜레이가 있을때 사이에 변경되도 안전함
화살표함수에는 this가 없어서 외부에서 this를 가져옴
arguments 지원 X
new와 함께 호출 불가능
super도 없음
예시 출처: <a rel="noopener nofollow" class="external-link is-unresolved" href="https://stackoverflow.com/questions/31866390/how-do-i-get-the-right-this-in-an-array-map" target="_self">https://stackoverflow.com/questions/31866390/how-do-i-get-the-right-this-in-an-array-map</a>a = { foo: 'bar', things: [1, 2, 3], showFooForEach: function() { this.things.map(function(thing) { console.log(this.foo, thing); }); }
} a.showFooForEach();
여기서 this.foo에서 this는 global가 되어 에러가 일어난다. (메서드 내의 함수→ 전역)방법 1. 화살표함수a = { foo: 'bar', things: [1, 2, 3], showFooForEach: function() { this.things.map((thing) =&gt; { console.log(this.foo, thing); }); }
} a.showFooForEach();
화살표함수는this가 없기때문에 상위에서 this 를 가져오게 되어서 a를 가르킨다.방법 2. binda = { foo: 'bar', things: [1, 2, 3], showFooForEach: function() { this.things.map(function(thing) { console.log(this.foo, thing); }.bind(this)); }
} a.showFooForEach();
방법 3. 변수로 this저장a = { foo: 'bar', things: [1, 2, 3], showFooForEach: function() { var self = this; this.things.map(function(thing) { console.log(self.foo, thing); })); }
} a.showFooForEach();
방법 4. 일부함수에는 인자로 this를 넘겨줄 수 있다.(forEach, map)arr.map(callback(currentValue[, index[, array]])[, thisArg])
arr.map(callback(currentValue[, index[, array]])[, thisArg])
a = { foo: 'bar', things: [1, 2, 3], showFooForEach: function() { this.things.map(function(thing) { console.log(this.foo, thing); }, this); }
} a.showFooForEach();
]]></description><link>200-웹개발/js-함수-심화학습.html</link><guid isPermaLink="false">200-웹개발/JS-함수 심화학습.md</guid><pubDate>Sun, 21 Sep 2025 08:17:16 GMT</pubDate></item><item><title><![CDATA[JS-프로퍼티 어트리뷰트]]></title><description><![CDATA[내부 슬롯과 내부메서드내부구현알고리즘을 설명하기위해 사용하는 의사 프로퍼티와 의사 메서드다.설명에서 <a data-href="…" href=".html" class="internal-link" target="_self" rel="noopener nofollow">…</a> &lt;&lt;내부슬롯과 내부메서드 ex)<a data-href="prototype" href=".html" class="internal-link" target="_self" rel="noopener nofollow">prototype</a>프로퍼티에 대해서 js에서 관리하는 내부슬롯들프로퍼티를 생성할때 자동정의한다.key와 value로 구성
<br><a data-href="value" href=".html" class="internal-link" target="_self" rel="noopener nofollow">value</a>
<br><a data-href="writable" href=".html" class="internal-link" target="_self" rel="noopener nofollow">writable</a>–&nbsp;true이면 값을 수정할 수 있습니다. 그렇지 않다면 읽기만 가능합니다.
<br><a data-href="enumerable" href=".html" class="internal-link" target="_self" rel="noopener nofollow">enumerable</a>–&nbsp;true이면 반복문을 사용해 나열할 수 있습니다. 그렇지 않다면 반복문을 사용해 나열할 수 없습니다.(for-in,Object.keys)
<br><a data-href="configurable" href=".html" class="internal-link" target="_self" rel="noopener nofollow">configurable</a>–&nbsp;true이면 프로퍼티 삭제나 플래그 수정이 가능합니다. 그렇지 않다면 프로퍼티 삭제와 플래그 수정이 불가능합니다 configurable&nbsp;플래그를 수정할 수 없음
enumerable&nbsp;플래그를 수정할 수 없음.
writable: false의 값을&nbsp;true로 바꿀 수 없음(true를&nbsp;false로 변경하는 것은 가능함).
접근자 프로퍼티&nbsp;get/set을 변경할 수 없음(새롭게 만드는 것은 가능함).
삭제할라면 에러는 발생하지않고 무시됨. strictmode에서는 에러.. 기본적으로 생성될 때,
value는 프로퍼티 값으로 초기화
나머지는 true로 초기화된다.
자체적으론 값 ㄴㄴ , 데이터프로퍼티 값을 읽거나 저장할때 호출되는 접근자함수로 구성.접근자함수를 getter setter함수라고도 부름.<br><img alt="Untitled" src="200-웹개발/assets/property1.png" target="_self"><br><img alt="스크린샷 2023-08-23 오후 6.13.42.png" src="200-웹개발/assets/property2.png" target="_self">Object.getOwnPropertyDescriptor(객체참조, 프로퍼티key)를 이용해서 간접 접근가능프로퍼티 디스크립터라는 것을 반환.(어트리뷰트 정보제공)let user = { name: "John"
}; let descriptor = Object.getOwnPropertyDescriptor(user, 'name'); alert( JSON.stringify(descriptor, null, 2 ) );
/* property descriptor:
{ "value": "John", "writable": true, "enumerable": true, "configurable": true
}
*/
key를 넣지않을시 모든 키에대한 프로퍼티 디스크립터를 반환한다.Object.defineProperty(obj, propertyName, descriptor) 해당 프로퍼티가 있을 때
명시된 attribute만 바꿔준다.
해당 프로퍼티가 없을 때
명시되지 않은 attribute는 다 false , undefined(get,set,value)
let user = {};
//데이터프로퍼티정의)
Object.defineProperty(user, "firstName", { value: "John"
}); let descriptor = Object.getOwnPropertyDescriptor(user, 'firstName');
/*
{ "value": "John", "writable": false, "enumerable": false, "configurable": false
} */ Object.defineProperty(user,'fullname",{ get(){}, set(){}, enumerable:true, configurable:true,
}
<br>프로퍼티 여러개 정의 : <a data-tooltip-position="top" aria-label="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties" rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties" target="_self">Object.defineProperties(obj, descriptors)</a>객체는 변경가능하며 프로퍼티 어트리부트 또한 재정의될 수 도 있다.| 구분 | 메서드
Object.~ | 프로퍼티 추가 | 프로퍼티
삭제 | 프로퍼티 값 읽기 | 프로퍼티 값 쓰기 | 프로퍼티 어트리뷰트 재정의 | 확인방법 메서드
Object.~ |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 확장 금지 | preventExtensions | X | O | O | O | O | isExtensible |
| 밀봉 | seal | X | X | O | O | X | isSeal |
| 동결 | freeze | X | X | O | X | X | isFrozen |<br>프로퍼티추가 : 동적추가 (<a data-tooltip-position="top" aria-label="http://user.name" rel="noopener nofollow" class="external-link is-unresolved" href="http://user.name" target="_self">user.name</a> = “어쩌구”)와 Object.defineProperty로 가능함.const person = { name: 'Lee', address: { city: 'Seoul' }
}
person을 freeze해도 중첩객체인 { city: 'Seoul' } 는 동결되지않는다.그래서 재귀돌려서 하나씩 freeze를 시켜줘야함.function deepFreeze(obj) { if(obj === null || typeof obj !== 'object') { Object.freeze(obj); Object.keys(obj).forEach(key =&gt; obj[key] &amp;&amp; typeof obj[key] === 'object' &amp;&amp; deepFreeze(obj[key])); } return obj;
}
]]></description><link>200-웹개발/js-프로퍼티-어트리뷰트.html</link><guid isPermaLink="false">200-웹개발/JS-프로퍼티 어트리뷰트.md</guid><pubDate>Sun, 21 Sep 2025 08:17:16 GMT</pubDate><enclosure url="200-웹개발/assets/property1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="200-웹개발/assets/property1.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[JS-테스트코드]]></title><description><![CDATA[저는 대표적인 Jest와 Mocha를 비교해보고 넘어가겠습니다 ㅎㅎ.보통 JavaScript 진영에서는 테스트 코드를 짤 때 유명한 프레임워크로 다음과 같은 것이 입니다.
Jest (강력한 Mocking 기능으로 TOP 1)
Mocha (+ Chai)
Cypress
등
여러 선택지가 있습니다. 프론트엔드에서는 dom 검사를 위해서 react-testing-library 등을 함께 쓰던군영.Jest는 기능이 강력한 대신 느립니다. 나중에 테스트가 쌓이면 매번 몇 초 동안 기다려야 하기 때문에 답답할 수 있습니다.대신 zero config를 추구하기 때문에 특별한 설정 없이 바로 시작할 수 있습니다.<img src="https://blog.kakaocdn.net/dn/IGUOh/btrU6Y1Es27/oL9hSEjabGBOyF44ImwN5k/img.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>Jest 홈페이지 캡처 : <a rel="noopener nofollow" class="external-link is-unresolved" href="https://jestjs.io/" target="_self">https://jestjs.io/</a>환경을 Mocha + Chai로 세팅해봤던 저장소입니다.<br><a data-tooltip-position="top" aria-label="https://github.com/IamGroooooot/ts-goos-tdd/tree/060c6be23d783f3e583c0c5ea3c12e254e7a7287" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/IamGroooooot/ts-goos-tdd/tree/060c6be23d783f3e583c0c5ea3c12e254e7a7287" target="_self"><strong></strong>
Contribute to IamGroooooot/ts-goos-tdd development by creating an account on GitHub.
github.com</a>GitHub - IamGroooooot/ts-goos-tddMocha는 Test 프레임워크입니다. Node나 브라우저 상으로 동기적이거나 비동적인 코드를 테스팅할 수 있게 해줍니다.테스트코드를 짜보셨다면 익숙할 describe, it, before, after 와 같은 함수 등을 제공해주고 test coverage도 계산해줍니다.보통 여러 Assertion을 추가적으로 쓰기 위해서 Chai라는 라이브러리와 같이 씁니다.Chai로 expect(myVariable).to.equal(111)와 같은 assertion을 작성할 수 있게됩니다.얘가 Jest에 비해 몇 배 더 빠릅니다.<br><a data-tooltip-position="top" aria-label="https://fe-developers.kakaoent.com/2023/230216-custom-jest-matchers/" rel="noopener nofollow" class="external-link is-unresolved" href="https://fe-developers.kakaoent.com/2023/230216-custom-jest-matchers/" target="_self">나만의 Jest Matchers 만들기</a>]]></description><link>200-웹개발/js-테스트코드.html</link><guid isPermaLink="false">200-웹개발/JS-테스트코드.md</guid><pubDate>Sun, 21 Sep 2025 08:17:16 GMT</pubDate><enclosure url="https://blog.kakaocdn.net/dn/IGUOh/btrU6Y1Es27/oL9hSEjabGBOyF44ImwN5k/img.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://blog.kakaocdn.net/dn/IGUOh/btrU6Y1Es27/oL9hSEjabGBOyF44ImwN5k/img.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[JS-클래스]]></title><description><![CDATA[class User { constructor() { this.name = '보라'; } //name = "보라"; 둘다같다
} let user = new User();
console.log(user.name); // 보라
console.log(User.prototype.name); // undefined
]]></description><link>200-웹개발/js-클래스.html</link><guid isPermaLink="false">200-웹개발/JS-클래스.md</guid><pubDate>Sun, 21 Sep 2025 08:17:16 GMT</pubDate></item><item><title><![CDATA[JS-왜 프로토타입을 사용하나]]></title><description><![CDATA[<a data-tooltip-position="top" aria-label="https://medium.com/@limsungmook/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-997f985adb42" rel="noopener nofollow" class="external-link is-unresolved" href="https://medium.com/@limsungmook/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-997f985adb42" target="_self">자바스크립트는 왜 프로토타입을 선택했을까</a><br><a data-tooltip-position="top" aria-label="https://medium.com/@limsungmook/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-997f985adb42" rel="noopener nofollow" class="external-link is-unresolved" href="https://medium.com/@limsungmook/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-997f985adb42" target="_self">자바스크립트는 왜 프로토타입을 선택했을까</a>정리Class -플라톤선생님의 말. 눈앞에 실제로, 구체적으로 존재하는 사물이 있다면 반드시 그것의 본질이 존재한다
개념을 추상화하여서 정의하고 인스턴스화하여 구체적으로 정의한다. 그러나, 현실에는 모추상화하여 분류할수 없는 경우가 존재한다.비트겐슈타인 왈
공유 속성의 관점에서 정의하기 어려운 개념이 있다,
세계에 미리 내재되어서 대상과 언어를 완전히 규정하는 어떤 언어란 존재하지 않는다
표현은 삶의 흐름 속에서만 의미를 갖는다
→맥락이 중요하다. → this 동적할당,,실행컨택스트…→대상을 분류할 때 모집단에서 가장 유사성 높은 것(가장 다른것들과 비슷한점이 많은것.)을기준으로 자. → prototype.]]></description><link>200-웹개발/js-왜-프로토타입을-사용하나.html</link><guid isPermaLink="false">200-웹개발/JS-왜 프로토타입을 사용하나.md</guid><pubDate>Sun, 21 Sep 2025 08:17:16 GMT</pubDate></item><item><title><![CDATA[JS-데이터 타입]]></title><description><![CDATA[<img alt="Untitled" src="200-웹개발/assets/datatype1.png" target="_self">typeof 를 통해 확인할수있다.모든 원시 값은&nbsp;불변하여 변형할 수 없습니다. 변수는 새로운 값을 다시 할당할 수 있지만, 이미 생성한 원시 값은 객체, 배열, 함수와는 달리 변형할 수 없습니다.배정밀도 : 64 비트 사용<br>부동 소수점 : <a data-tooltip-position="top" aria-label="http://1.xxx" rel="noopener nofollow" class="external-link is-unresolved" href="http://1.xxx" target="_self">1.xxx</a> * 2^n형식으로 나타낸다첫 비트 양수음수 그다음 8bit 몇칸움직엿는지 (n을 이진수로) 다음 1xxx 넣고 나머지 0다른언어에서 생기는 0.1 + 0.2 === 0.3 ≠ true가 고대로 나타난다.<br><img alt="스크린샷 2023-08-09 오후 5.11.51.png" src="200-웹개발/assets/datatype2.png" target="_self">
NaN , Infinity, -Infinity
NaN == NaN false isNaN을 통해 확인해야한다.“” ‘’ ``<br><img alt="스크린샷 2023-08-09 오후 5.23.49.png" src="200-웹개발/assets/datatype3.png" target="_self"><br><img alt="스크린샷 2023-08-09 오후 5.24.48.png" src="200-웹개발/assets/datatype4.png" target="_self">LF 쓰는게 좋음CF는 운영체제에 따라 인식 못하는 경우가 잇음줄바꿈문자도 인식함 ${} 통해 변수넣을 수 있음자바스크립트 엔진이 변수를 초기화할때 사용하는 값값을 초기화 하지 않으면 기본적으로 undefined가 할당된다.개발자가 의도적으로 할당하지 않는게 좋음.값이 없다는것을 의도적으로 명시하는 자료형참조하는경우 더이상 참조하지 않겟다!var foo =”hi”foo = null더이상참조하지않으므로 가비지 콜랙션이 수행됨.찾아본것..타입에따라서 래퍼객체가잇음해당변수를 사용할때마다 해당객체에 래핑됨var str = "문자열"; // 문자열 리터럴 생성
var strObj = new String(str); // 문자열 객체 생성
str.length; // 리터럴 값은 내부적으로 래퍼 객체를 생성한 후에 length 프로퍼티를 참조함.
str == strObj; // 동등 연산자는 리터럴 값과 해당 래퍼 객체를 동일하게 봄.
str === strObj; // 일치 연산자는 리터럴 값과 해당 래퍼 객체를 구별함.
typeof str; // string 타입
typeof strObj; // object 타입
다른 값과 중복되지 않는 유일 무의한값, 외부에 노출안된다.왜필요함?
값을 저장할 때 확보해야하는 메모리 공간의 크기를 결정하기 위해
값을 참조할 때 한번에 읽어 들어야할 메모리공간의 크기를 결정하기 위해.
메모리에서 읽어들인 2진수를 어떻게 해석할지 결정하기 위해.
선언시 타입을 선언 , 컴파일 시점에서 타입체크함js할당에 의해서 타입이 결정된다. 할당되는 값에 따라 타입이 동적으로 변함..유연성 증가 신뢰성하락필요한 경우에만변수생성 상수 최대한 사용스코프 최대한 좁게만듬네이밍 잘하샘]]></description><link>200-웹개발/js-데이터-타입.html</link><guid isPermaLink="false">200-웹개발/JS-데이터 타입.md</guid><pubDate>Sun, 21 Sep 2025 08:17:16 GMT</pubDate><enclosure url="200-웹개발/assets/datatype1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="200-웹개발/assets/datatype1.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[JS-객체 프로퍼티 설정]]></title><description><![CDATA[객체의프로퍼티의 속성 = value + flag
writable&nbsp;–&nbsp;true이면 값을 수정할 수 있습니다. 그렇지 않다면 읽기만 가능합니다.
enumerable&nbsp;–&nbsp;true이면 반복문을 사용해 나열할 수 있습니다. 그렇지 않다면 반복문을 사용해 나열할 수 없습니다.(for-in,Object.keys)
configurable&nbsp;–&nbsp;true이면 프로퍼티 삭제나 플래그 수정이 가능합니다. 그렇지 않다면 프로퍼티 삭제와 플래그 수정이 불가능합니다 configurable&nbsp;플래그를 수정할 수 없음
enumerable&nbsp;플래그를 수정할 수 없음.
writable: false의 값을&nbsp;true로 바꿀 수 없음(true를&nbsp;false로 변경하는 것은 가능함).
접근자 프로퍼티&nbsp;get/set을 변경할 수 없음(새롭게 만드는 것은 가능함). 일반적으로 모두 true가 default특정 객체의 프로퍼티에 대한 정보를 모두 얻을 수 있음let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
obj -객체propertyName - key값let user = { name: "John"
}; let descriptor = Object.getOwnPropertyDescriptor(user, 'name'); alert( JSON.stringify(descriptor, null, 2 ) );
/* property descriptor:
{ "value": "John", "writable": true, "enumerable": true, "configurable": true
}
*/
Object.defineProperty(obj, propertyName, descriptor)
descriptor - 적용하고자하는 프로퍼티의 속성
해당 프로퍼티가 있을 때
명시된 속성만 바꿔준다.
해당 프로퍼티가 없을 때
명시되지 않은 속성은 다 false
let user = {}; Object.defineProperty(user, "name", { value: "John"
}); let descriptor = Object.getOwnPropertyDescriptor(user, 'name'); /*
{ "value": "John", "writable": false, "enumerable": false, "configurable": false
} */
프로퍼티 여러개 정의 : <a data-tooltip-position="top" aria-label="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties" rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties" target="_self">Object.defineProperties(obj, descriptors)</a>Object.defineProperties(obj, { prop1: descriptor1, prop2: descriptor2 // ...
});
그외의 객체 수정 방지 메서드Object.preventExtensions(obj)
객체에 새로운 프로퍼티를 추가할 수 없게 합니다.Object.seal(obj)
새로운 프로퍼티 추가나 기존 프로퍼티 삭제를 막아줍니다. 프로퍼티 전체에 configurable: false를 설정하는 것과 동일한 효과입니다.Object.freeze(obj)
새로운 프로퍼티 추가나 기존 프로퍼티 삭제, 수정을 막아줍니다. 프로퍼티 전체에 configurable: false, writable: false를 설정하는 것과 동일한 효과입니다.
아래 메서드는 위 세 가지 메서드를 사용해서 설정한 제약사항을 확인할 때 사용할 수 있습니다.Object.isExtensible(obj)
새로운 프로퍼티를 추가하는 게 불가능한 경우 false를, 그렇지 않은 경우 true를 반환합니다.Object.isSealed(obj)
프로퍼티 추가, 삭제가 불가능하고 모든 프로퍼티가 configurable: false이면 true를 반환합니다.Object.isFrozen(obj)
프로퍼티 추가, 삭제, 변경이 불가능하고 모든 프로퍼티가 configurable: false, writable: false이면 true를 반환합니다.객체의 프로퍼티
데이터 프로퍼티 : 일반적인 프로퍼티
접근자 프로퍼티 : 데이터 프로퍼티에 접근하기위한 프로퍼티
접근자 프로퍼티(get/set메서드를 가짐)나 데이터 프로퍼티(value를 가짐) 중 한 종류에만 속할 수 있음
get&nbsp;– 인수가 없는 함수로, 프로퍼티를 읽을 때 동작함 //getter
set&nbsp;– 인수가 하나인 함수로, 프로퍼티에 값을 쓸 때 호출됨 //setter
enumerable&nbsp;– 데이터 프로퍼티와 동일함
configurable&nbsp;– 데이터 프로퍼티와 동일함 값을 원하는대로 통제할 수 있음
let user = { get name() { return this._name; }, set name(value) { if (value.length &lt; 4) { alert("입력하신 값이 너무 짧습니다. 네 글자 이상으로 구성된 이름을 입력하세요."); return; } this._name = value; }
}; user.name = "Pete";
alert(user.name); // Pete user.name = ""; // 너무 짧은 이름을 할당하려 함
defineProperty안에 get과 value를 동시에 설정하면 에러가 난다class Foo { constructor () { Object.defineProperty(this, 'bar', { get () { return this._bar; }, set (value) { this._bar = value; } }); } get baz () { *return this._baz; } set baz (value) { this._baz = value; }
} const myFoo = new Foo();
console.log('bar', myFoo.hasOwnProperty('bar')); // true
console.log('baz', myFoo.hasOwnProperty('baz')); // false*
class Example1 { get hello() { return 'world'; }
} const obj = new Example1();
console.log(obj.hello);
// "world" console.log(Object.getOwnPropertyDescriptor(obj, 'hello'));
// undefined console.log( Object.getOwnPropertyDescriptor( Object.getPrototypeOf(obj), 'hello' )
);
// { configurable: true, enumerable: false, get: function get hello() { return 'world'; }, set: undefined }
상속시 get과 set은 prototype의 프로퍼티로 설정됨출처<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/get" target="_self">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/get</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://ko.javascript.info/object-properties" target="_self">https://ko.javascript.info/object-properties</a>]]></description><link>200-웹개발/js-객체-프로퍼티-설정.html</link><guid isPermaLink="false">200-웹개발/JS-객체 프로퍼티 설정.md</guid><pubDate>Sun, 21 Sep 2025 08:17:16 GMT</pubDate></item><item><title><![CDATA[school) DB2-1(설계전 이론)]]></title><description><![CDATA[이론의 중요성
결과를 예측할 수 있도록 도와준다.
설계의 중요성
데이터의 일관성,무결성,정확성에 영향을 준다
부적절하게 설계를 했을 경우 정보추출이 힘들고, 검색에서 부정확한 정보를 얻는 위험을 감수해야한다.
좋은 설계 방법론의 장점
단계적으로 기술의 조직화된 집합을 제공함
실수와 설계반복을 최소화 할 수 있음
좋은 설계의 목적
db는 필수적인 것과 임의적인 정보 추출을 둘다 지원함
필드,테이블,관계수준에서 무결성이 부과됨
업뮤규칙을 지원함
좋은 설계의 이점
db구조를 쉽게 수정,유지할 수 있음
정보추출이 쉬움
최종 사용자 어플리케이션 개발이 쉬워짐
3단계를 거침
모델이 되는 사업에 대한 조사
현재의 평가와 요구 분석을 위한 사용자 및 관리자와의 면담
사업전반에 대한 요구사항 평가 erd 관계는 다이아몬드, 의미-개체 모델링
개체-관계 모델링
<a data-href="DB - 데이터 모델링(DB 설계)" href="school/23-2/db/db-데이터-모델링(db-설계).html" class="internal-link" target="_self" rel="noopener nofollow">DB - 데이터 모델링(DB 설계)</a> 여기에 설명이 더 자세히 되어있음.중복 데이터와 이중 데이터를 줄이고, 데이터 삽입-갱신-삭제에서 발생하는 문제를 줄여줄 수 있다.<br>
<a data-href="DB - 종속성과 정규화" href="school/23-2/db/db-종속성과-정규화.html" class="internal-link" target="_self" rel="noopener nofollow">DB - 종속성과 정규화</a>
데이터 : 정적 , 데이터베이스에 ”저장“하는 값, 표면적 의미 없음
정보 : 동적, 무언가를 위해 의미 있고 유용하도록 처리한 데이터, 정보는 ”추출“하는 것
null : 누락되었거나 미지의 값 누락 : 일반적으로 사람의 오류
미지 : 값이 정의디지 않음, 정말 unknown, 적용 되지 않음(적용하지않다/적용할 수 없다) 적용할 수 없는 경우 N/A가 더적합함 단점 : 널을 포함하는 연산은 널로 평가됨 테이블 각 테이블은 항상 하나의 구체적 주제를 나타냄 주제는 개체 or 사건 관계형에서는 릴레이션이라고 불림,각 릴레이션은 튜플(레코드),속성(필드로) 구성
논리적으로 테이블을 구성함에 따라 데이터의 물리적 독립성을 유지 테이블내의 레코드와 필드의 논리적 순서는 중요치 않음
각 레코드 들은 식별하는 주키를 포함 종류 데이터 테이블 정보를 제공하는 테이블, 데이터 조작 가능 검증 테이블(lookup table) 데이터 무결성을 구현하는데 사용하는 데이터를 저장
정적임
값을 검증하기 위해 간접적으로 테이블 사용
일반적으론 주제를 나타냄 필드 db에서 가장 작은구조
속해있는 테이블의 주제의 특성을 나타넴
좋은 db는 한필드에 하나의 값(원자성)
잘못 설계된 db의 필드 종류 계산된 필드: 다른필드의 정보들을 계산한 결과를 포함하는 필드
다중 부분 필드 : 둘이상의 서로 다른 항목들을 값으로 가지는 필드
다중 값 필드 : 같은 종류의 값을 여러벌 가지는 필드 레코드 테이블 주제의 고유한 인스턴스
주키에 의해 테이블 전체에 걸처 식별 뷰 가상적 테이블 자체적으로 뎅터 저장 ㄴㄴ, 기반데이터들로 부터 데이터 추출 db내의 정보를 다른 측면에서 볼 수 있음
여러 테이블로 온 데이터를 작업하는 것을 허용
사용자가 특정 필드를 보거나 조작하는것을 방지(보안에 굿)
데이터 무결성에 사용가능(검증뷰) 키 레코드 식별시 사용되는 논리적 구조
pk : 전체 db에 걸처 특정 레코드를 식별하고 주키 필드는 전체 db를 거처 주어진 테이블을 식별함
fk : 두 테이블 간의 관계설정, 관계수준의 무결성에 도움이 됨(고아레코드 방지) 인덱스 데이터 처리를 개선하기 위해 rdbms가 제공하는 구조
논리적 db 구조와 관련이 1도 없음
데이터 처리를 최정화 하기 위해 사용하는 물리적 구조 데이터 무결성에 도움이 됨 중복 데이터를 줄이고 이중데이터를 베제하는데 도움이 됨 다중테이블 뷰를 만들 수 있게 해줌
참여 종류 강제적 : B테이블에 하나의 레코드를 삽입전에 적어도 A테이블에 적어도 하나의 레코드를 삽입해야함
선택적 : B테이블에 하나의 레코드를 삽입전에 A테이블에 레코드 삽입할 필요 없음 참여 수준 연관된 테이블의 한레코드와 반드시 연결되어야하는 테이블의 최소레코드 수와 허용되는 최대 레코드 개수를 결정함
왼쪽엔 최소 오른쪽에 최대
ex) 테이블 : 대행사, 고객 대행사가 적어도 하나의 고객을 상대함 but 8명이상은상대하지 못함
참여수준 : 1,8 <br><img alt="assets/Pasted image 20240421022139.png" src="700-컴퓨터과학/assets/pasted-image-20240421022139.png" target="_self" style="width: 300px; max-width: 100%;">
서로 한레코드만 연관되어있을때
한테이블은 부모테이블역할, 다른 한 테이블은 자식역할
부모테이블의 주키의 복사본을 취해서 자식 테이블의 구조에 포함시킴(이거시 외래키가 됨)
<br><img alt="assets/Pasted image 20240421022345.png" src="700-컴퓨터과학/assets/pasted-image-20240421022345.png" target="_self" style="width: 300px; max-width: 100%;"><br>
<img alt="assets/Pasted image 20240421022428.png" src="700-컴퓨터과학/assets/pasted-image-20240421022428.png" target="_self" style="width: 300px; max-width: 100%;">
A레코드가 B의 여러 레코드에 연관, 역은 오직 하나
부모,자식모델 성립
중복 데이터를 최소화 하는데 도움을 줌(데이터 무결성에 굿)
가장 일반적인 관계
<br><img alt="assets/Pasted image 20240421022617.png" src="700-컴퓨터과학/assets/pasted-image-20240421022617.png" target="_self" style="width: 300px; max-width: 100%;"><br>
<img alt="assets/Pasted image 20240421023050.png" src="700-컴퓨터과학/assets/pasted-image-20240421023050.png" target="_self" style="width: 500px; max-width: 100%;">
여러 레코드 link 여러레코드
서로 관계가 있는 주키의 복사본을 취함
연결테이블이라고 함 연결된 테이블끼리 레코드를 연결시키기 쉽게 해주고, 추가 삭제 수정에 문제 없도록 보장하는데 도움이 됨 pkfk 합쳐서 연결테이블의 복합 주키를 형성 필드 명세 : aka 도메인 필드의 모든 요소를 나타냄
일반적 요소 : 필드 이름,설명,부모테이블등
물리적 요소: 어케만들어지고 어케표현할지
논리적 요소: 필드에 저장되는 값을 설명,필수값 범위 등 데이터 무결성 데이터의 유효성,일관성, 정확성을 가르킴
db추출정보의 정확성은 데이터 무결성 수준에 정비례
테이블 수준의 무결성 중복 레코드 ㄴㄴ
각 레코드를 식별하는 필드가 유일하고 널이아님 필드 수준의 무결성(aka 도메인 무결성) 필드 구조가 정확하고 값이 유효하고 일관성있음
같은 종류의 필드가 db전체에 걸처 일관성있게 정의 됨 관계수준의 무결성(aka 참조 무결성) 테이블 쌍 관계가 정확함
임의의 테이블에서 삽입 갱신 삭제 될때마다 동기화 되는것을 보장 업무 규칙 조직이 데이터를 인식하고 사용하는 방법을 기초로함
db의 특정한 측면에 대해 제약,규제를 부과
필드 내 저장되는 값을 번위와 형식, 참여종류와 수준 등 설계측면에 영향을 미칠 수 있음 ]]></description><link>700-컴퓨터과학/school)-db2-1(설계전-이론).html</link><guid isPermaLink="false">700-컴퓨터과학/school) DB2-1(설계전 이론).md</guid><pubDate>Sun, 21 Sep 2025 07:53:05 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[OS-8) 프로세스 교착상태]]></title><description><![CDATA[<a href=".?query=tag:deadlock" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#deadlock">#deadlock</a> 상호 배제(mutual exclusion= mutex)
동시에 한자원을 한 프로세스만 사용가능하다.
이게 아니라면 교착상태가 애시당초 발생하지 않음(한 자원을 한번에 여러프로세스가 접근 가능하니까) 점유 상태로 대기(hold and wait)
하나이상의 자원을 가진 프로세스가 다른 프로세스가 가지고 있는 다른 자원을 획득하기 위해 기다린다.
선점 불가(no preemption)
프로세스가 가진 자원은 사용이 끝난 후에 자발적으로만 방출될 수 있다.(== 뺏을 수 없다.)
순환성 대기(circulal wait)
프로세스 집합이 존재할 때 순환형으로 자원을 기다리고 있는상황
자원 할당 그래프를 그려보면 사이클이 발생하는지 알 수 있다.
그래프에 사이클이 존재하지 않는다 =&gt; 교착상태 ㄴㄴ
“”에 사이클이 존재한다
자원타입마다 오직 하나의 인스턴스가 있다 -&gt; 교착상태 발생
여러개 있으면 교착상태 발생 가능성 있음<br>
<img alt="assets/Pasted image 20240418211706.png" src="700-컴퓨터과학/assets/pasted-image-20240418211706.png" target="_self">
이 4가지 조건이 동시에 만족할 때 발생한다. BUT 4가지조건이 동시에 만족한다고 반드시 교착상태가 발생하는 것은 아니다.
자원 A,B를 두개의 스레드S1,S2가 동시에 사용하려고 함
이때 자원이 두개니 뮤텍스또한 두개고 A가 있는 뮤택스를 LockA, B가 있는 뮤텍스를 LockB라고 하자.
S1이 LockA를 확인한다. 내려가 있으니 올린다.(=1이되면 누군가 점유하고 있다는 뜻이고 다른프로세스는 이자원을 획득하기 위해선 기다린다.). 후 자원을 S1이 점유. S1 : wait(A)
S2가 LockB를 확인한다. 내려가 있으니 올리고 자원을 점유 S2 : wait(B)
-- 지금까지 S1은 A를 소유 , S2는 B를 소유하고 있다. —
S1은 LockB를 확인한다. 안내려가 있으니 대기
S2는 LockA를 확인한다. 안내려가 있으니 대기
-- 교착상태 —
위의 4가지 필수조건 중 하나라도 발생하지 않게한다
상호 배제 : 비공유자원을 미리확보,상호배제 조건을 인정하지 않는 경우는 거의 불가능하기에
점유 상태로 대기 : 자원 요청시 어떠한 자원을 보유하지 않음을 보장(But 낮은 자원활용율, 기아 초래)
선점 불가 : 자원보유중인 프로세스가 다른자원을 즉시 할당받지 않을시 소유중인 자원을 모두 방출
선점 당한 프로세스는 기존 자원과 새로요청한 자원을 확보 할 수 있는 경우에만 실행
순환 대기 : 모든 자원유형을 전체 순서를 정하여 자원요청
각 요청을 운영체제가 직접 분석함으로써 데드락이 발생할 가능성을 확인(동적임)
사용가능한 추가적인 사전 정보를 시스템이 가저야 한다
상태 판단
safe state인지를 판단하여 교착상태에 빠지지 않게 한다
safe state : 모든프로세스에 순서가 존재함, 교착상태 발생불가
unsafe state : 교착상태 발생 가능성있음(반드시 발생 ㄴㄴ)<br>
<img alt="assets/Pasted image 20240418214254.png" src="700-컴퓨터과학/assets/pasted-image-20240418214254.png" target="_self" style="width: 300px; max-width: 100%;"> 자원이 하나의 인스턴스만 있는 경우
<br><img alt="assets/Pasted image 20240423222740.png" src="700-컴퓨터과학/assets/pasted-image-20240423222740.png" target="_self" style="width: 300px; max-width: 100%;">
이렇게 사이클이 생기면 unsafe state라는 것
인스턴스여러개일때<br>
<img alt="assets/Pasted image 20240424033353.png" src="700-컴퓨터과학/assets/pasted-image-20240424033353.png" target="_self">
자원이 여러개의 인스턴스가 있는 경우
각 프로세스는 최대 필요한 자원수를 선언
모든 리소스 가져올 시 유한 시간 내 반환
need = max - allocation<br>
<img alt="assets/Pasted image 20240423223102.png" src="700-컴퓨터과학/assets/pasted-image-20240423223102.png" target="_self" style="width: 500px; max-width: 100%;"> p1 할당 반환 , available : 5 3 2
p3 할당 반환 , available : 7 4 3
p4 할당 반환 , available : 7 4 5
p0 할당 반환 , available : 7 5 5
p2 할당 반환 , available : 10 5 7
데드락이 반드시 발생할것을 가정하고 어느부분이 데드락이 발생햇는지 탐색하는 방식프로세스를 강제로 종료시거나 자원을 강제로 회수한다.]]></description><link>700-컴퓨터과학/os-8)-프로세스-교착상태.html</link><guid isPermaLink="false">700-컴퓨터과학/OS-8) 프로세스 교착상태.md</guid><pubDate>Sun, 21 Sep 2025 07:51:00 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[OS-6) 프로세스 스케줄링]]></title><description><![CDATA[
CPU에서 실행할 프로세스를 선택하는 것
프로세스 실행은 cpu-i/o burst cycle(cpu 다음에 io) CPU 사용을 최대화 &nbsp;CPU Utilization = ∑ (Process time / period) 처리량 최대화
총처리 시간을 최소화
대기 시간을 최소화
응답시간을 최소화 job queue : 모든 프로세스가 올라가 있는 큐 (Long term)
ready queue : 준비 상태에 있는 큐들이 올라가 있다 (short term)
device queue : 입출력 장치마다 있는것,
큐, 자원(원모양),프로세스의 이동 흐름을 나타냄
<img alt="assets/스크린샷 2024-04-16 오후 9.47.34.png" src="700-컴퓨터과학/assets/스크린샷-2024-04-16-오후-9.47.34.png" target="_self">
process create 되고 나선 바로 job queue에 적재된다.
이 적재된것중에 ready queue 로 가는 것
순서 : create &gt; job queue &gt; ready queue
다음에 cpu에 할당될 프로세스를 선택한다
즉 준비큐에 있는 프로세스를 선택한다.
ms 간격으로 호출 &gt; 빨라야함 running -&gt; wait 상태 전이 (비선점 방식)
running -&gt; ready 상태 전이 (선점 방식)
wait -&gt; ready 상태 전이 (선점방식)
종료 될 때 (비선점 방식)
선점 방식인 이유 공유 데이터 접근 고려
커널모드있는 동안의 선점 고려
os작업중에 인터럽트 발생 고려 단기 스케줄러가 선택한 프로세스에게 cpu 제어를 주는 모듈
하는 작업 문맥교환
사용자 모드로 전환
프로그램을 다시 시작하기위해 사종자 프로그램의 적절한 위치로 이동 디스페처 지연 디스페처가 하나의 프로세스를 중단시키고 다른 프로세스를 실행시키는데 소요되는 시간 준비큐로 이동할 프로세스를 선택한다.
s, min 간격으로 호출
이 스케줄러가 다중프로그래밍 정도를 결정
io bound 와 cpu bound프로세스가 고루 섞이도록 한다. 많은 프로세스가 있을때(= 다중프로그래밍 중일 때), 너무 많은 프로세스에게 메모리를 할당해 시스템 성능이 저하 되는 것을 방지하기 위함
swaping 이용 &nbsp;물리 메모리 공간이 부족해지면, 물리 메모리의 확장 개념으로 swap area를 사용하고 swap out 시켜 내보냄
메모리 &lt;-&gt; 디스크 걍 queue
딱 시작하는 타이밍이 waiting 시간
호위효과가 발생할 수 있음 모든 프로세스가 긴프로세스하나가 cpu를 양도하기를 기다리는 것 우선순위가 먼저인 것을 머저 할당
아래는 우선순위가 cpu burst 시간인 경우이다
SJF(shortest job first) 버스트 길이를 기준으로 가장 짧은 시간을 가진 프로세스를 스케줄
언제나 최소의 평균 대기시간을 보장
단기 스케줄러에서 구현 못함
BUT, CPU 버스트 시간을 알기 어렵다.
대략 예측 방법
- t(n) : n번째 프로세스 실제 CPU 사용 시간
- 타우 n+1 : (n+1)번째 프로세스 CPU 사용 시간 추정치<br>
<img alt="assets/스크린샷 2024-04-17 오후 4.56.05.png" src="700-컴퓨터과학/assets/스크린샷-2024-04-17-오후-4.56.05.png" target="_self" style="width: 300px; max-width: 100%;"> SRTF(shortest remaining time first) 선점 방식
진행하다가 그 시간에 bursttime이 더 짧은 프로세스가 오면 선점함
대기시간 = 마지막 조각 프로세스가 실행한 시간 - 프로세스도착시간 - 이전에 다른 조각프로세스가 실행한 시간
평균대기시간 = 대기시간/프로세스 개수 starvation : 낮은 우선순위 프로세스는 실행되지 않을 수 있다.
aging : 시간이 흘러갈수록 프로세스의 우선순위를 증가시킨다. 선점형
프로세스는 적은양의 cpu 시간을 할당 받음(time quantum) 시간이 경과할때마다 인터럽트 if 준비큐에 n개, 시간할당량 q, 각프로세스는 q(n-1) 이상을 대기하지 않음
- q가 커질수록 FIFO에 가까워짐
- q가 적어지면 오버헤드가 커짐 so 문맥교환시간에 비해서는 충분히 커야함<br>
<img alt="assets/스크린샷 2024-04-17 오후 5.30.48.png" src="700-컴퓨터과학/assets/스크린샷-2024-04-17-오후-5.30.48.png" target="_self" style="width: 400px; max-width: 100%;">
ready queue를 여러개로 분할
프로세스는 지정된 큐에 영원히 존재 (와리가리 못침)
큐 사이의 스케줄링도 정해야함
foreground queue user과의 상호작용을 많이하는 프로세스 존재
보통 cpu 시간의 80퍼를 받아 RR방식으로 스케줄링 background queue user와 멀리떨어진 batch system형태의 프로세스 존재
보통 cpu시간의 20퍼를 받아 FCFS 방식으로 스케줄링 foreground queue 처리후 background queue고려
-&gt; starvation 야기 -&gt; cpu 시분할을 통해 방지
각 프로세스가 여러 큐로 이동할 수 있다.
aging기법을 다음과 같은 방식으로 구현할 수 있음
응답속도가 빨라짐<br>
<img alt="assets/스크린샷 2024-04-17 오후 5.42.45.png" src="700-컴퓨터과학/assets/스크린샷-2024-04-17-오후-5.42.45.png" target="_self" style="width: 400px; max-width: 100%;">
먼저 quantum 8(RR방식)의 큐에 넣는다
if 위의 큐에서 처리안되면, 하위큐에 넣음
최종적으로도 처리 안될 시 FCFS에 들어가서 처리됨
<br>ex) NUMA<img alt="assets/스크린샷 2024-04-17 오후 6.09.25.png" src="700-컴퓨터과학/assets/스크린샷-2024-04-17-오후-6.09.25.png" target="_self" style="width: 400px; max-width: 100%;">
cpu가 여러개
다중처리기 접근 비대칭 다중처리 : 오직 하나의 처리기 만이 시스템 자료구조에 접근가능
대칭 다중처리 : 각처리기는 독자적으로 스케줄링, 모든 프로세스는 각각이나 공통의 준비큐에 있을 수 있다. 처리 친화성 : 프로세스는 현재 자신이 실행중인처리기를 더 선호한다(당연한거아뉨?)
효율적으로 작동할라면 로드밸런싱이 있어야한다 push migration : 각처리기의 부하를 점검하고 일을 분배
pull mirgration : 노는 처리기가 바쁜 처리기에서 대기중인 일을 가져와 실행 한 물리적칩안에 여러개의 처리기 코어를 배치
빠르며 더 적은 전력을 소모
코어마다 여러 스레드 지원이 증가하는 추세
메모리 멈춤 상황이 발생할 수 있음(여러프로세스가 메모리에 접근
Real-Time System은 "Deadline"이 존재하고 해당 Dealine을 지키지 않는다면 시스템에 치명적인 영향을 줄 수 있다. 그래서 반드시 "Deadline"내에 job을 끝내야 한다
선점형, 우선순위 기반(prioriy-based) 스케줄링을 지원해야함
마감시간을 충족해야한다
<br><img alt="assets/스크린샷 2024-04-17 오후 6.16.55.png" src="700-컴퓨터과학/assets/스크린샷-2024-04-17-오후-6.16.55.png" target="_self" style="width: 400px; max-width: 100%;">
soft real time : 중요한 실시간 프로세스가 언제 스케줄될지 보장 ㄴㄴ
hard real time : 테스크는 마감시간 전 까지 반드시 완료
RMS (Rate Montonic Scheduling) 우선순위가 주기의 역수로 매겨짐
즉, 빠른(적은)주기== 높은우선순위
ex) P1은 주기가 50초이고, 20초동안 processing한다. P2는 주기가 100초이고, 35초동안 processing한다<br>
<img alt="assets/IMG_0039.png" src="700-컴퓨터과학/assets/img_0039.png" target="_self"> EDF(Earliest Deadline First Scheduling) 우선순위가 마감시간에 따라 부여됨
이 방법은 RMS처럼 static하게 priority를 주는&nbsp;것이 아니라, task들이 들어올때마다 deadline을 비교해보고, priority를 정하는 방식이다
ex) P1은&nbsp;주기가 50이고, processing이 25이다. P2는 주기가 80이고, processing이 35이다. 주기가 deadline일때<br>
<img alt="assets/IMG_0041.png" src="700-컴퓨터과학/assets/img_0041.png" target="_self"> Proportional Share Scheduling n/t deadline을 지킬려면 지연시간을 최소화 해야함
두종류의 지연이 성능에 영향을 준다
인터럽트 지연 : 인터럽트가 도착해서 인터럽트를 서비스하기 시작할 때까지의 시간
디스패치 지연 : 프로세스를 중단시키고 새로운 프로세스로 전환하는데 걸리는시간(문맥전환) 충돌이 될 수 있는 단계 커널 모드에서 실행중인프로세스 선점
낮은 우선순위의 프로세스가 높은 우선순위의 프로세스가 요구하는 자원을 방출 특정 예측된 부하를 미리 정해 놓고 그 부하에 대한 각 알고리즘의 성능을 측정한다
분석적 평가의 한 부류
간단하고 빠르지만 특수한 입력에 대해서만 해당될 수 있음 프로세스 도착과 cpu,i/o 버스트를 확률적 분포를 설명 평균 처리량, 이용률, 대기시간 등을 계산 각 서버는 대기 프로세스르 넣을 큐를 가진다
little's law n = 람다 * W (사실상 거속시아님?)
n : 평균 큐의 길이(몇개의 프로세스가 존재 가능하냐)
람다 : 큐에 평균적으로 도착하는 평균 개수
W : 큐에서 평균적으로 기다리는 시간 컴퓨터 시스템의 프로그램 모델
클럭은 가변적
알고리즘 성능을 나타내는 통계자료를 수집
데이터 수집 방법 확률에 기초한 랜덤넘버 발생
수학적 or 경험적으로 정의된 분포
실제 시스템의 이벤트를 차례대로 기록한 추적테이프 위에것들보단 정확하지만 한계는 있다
]]></description><link>700-컴퓨터과학/os-6)-프로세스-스케줄링.html</link><guid isPermaLink="false">700-컴퓨터과학/OS-6) 프로세스 스케줄링.md</guid><pubDate>Sun, 21 Sep 2025 07:51:00 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[webflux vs mvc-1757788537542]]></title><description><![CDATA[<img src="300-백엔드개발/assets/webflux-vs-mvc-1757788537542.png" target="_self">]]></description><link>300-백엔드개발/assets/webflux-vs-mvc-1757788537542.html</link><guid isPermaLink="false">300-백엔드개발/assets/webflux vs mvc-1757788537542.png</guid><pubDate>Sat, 13 Sep 2025 18:35:37 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[webflux vs mvc-1757788425212]]></title><description><![CDATA[<img src="300-백엔드개발/assets/webflux-vs-mvc-1757788425212.png" target="_self">]]></description><link>300-백엔드개발/assets/webflux-vs-mvc-1757788425212.html</link><guid isPermaLink="false">300-백엔드개발/assets/webflux vs mvc-1757788425212.png</guid><pubDate>Sat, 13 Sep 2025 18:33:45 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[tomcat vs netty]]></title><description><![CDATA[
]]></description><link>300-백엔드개발/tomcat-vs-netty.html</link><guid isPermaLink="false">300-백엔드개발/tomcat vs netty.md</guid><pubDate>Sat, 13 Sep 2025 18:30:09 GMT</pubDate></item><item><title><![CDATA[filter, servlet]]></title><description><![CDATA[필터,서블릿은 &nbsp;자바 표준 인터페이스임
요청이 들어오면:
서버(WAS)가 요청을 받음
필터 체인(Filter Chain)이 호출되고, 각 필터의 로직이 순서대로 처리됨
마지막 필터가 서블릿(Servlet)에게 요청을 전달
서블릿이 요청을 받아 스프링 DispatcherServlet 등으로 연결해 컨트롤러를 실행
처리 완료 후 응답이 서블릿, 필터를 다시 거쳐 클라이언트로 전달
]]></description><link>300-백엔드개발/filter,-servlet.html</link><guid isPermaLink="false">300-백엔드개발/filter, servlet.md</guid><pubDate>Sat, 13 Sep 2025 18:26:30 GMT</pubDate></item><item><title><![CDATA[Apache VS Nginx VS Tomcat]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@gnoesnooj/Apache-VS-Nginx-VS-Tomcat#nginx%EC%9D%98-%EB%8B%A8%EC%A0%90-" target="_self">https://velog.io/@gnoesnooj/Apache-VS-Nginx-VS-Tomcat#nginx%EC%9D%98-%EB%8B%A8%EC%A0%90-</a>]]></description><link>300-백엔드개발/apache-vs-nginx-vs-tomcat.html</link><guid isPermaLink="false">300-백엔드개발/Apache VS Nginx VS Tomcat.md</guid><pubDate>Sat, 13 Sep 2025 18:23:19 GMT</pubDate></item><item><title><![CDATA[동기 vs 비동기, 블로킹 vs 논블로킹]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC" target="_self">https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC</a><br><img alt="동기 vs 비동기, 블로킹 vs 논블로킹-1757786738823.png" src="700-컴퓨터과학/assets/동기-vs-비동기,-블로킹-vs-논블로킹-1757786738823.png" target="_self"><br><img alt="동기 vs 비동기, 블로킹 vs 논블로킹-1757786764391.png" src="700-컴퓨터과학/assets/동기-vs-비동기,-블로킹-vs-논블로킹-1757786764391.png" target="_self">]]></description><link>700-컴퓨터과학/동기-vs-비동기,-블로킹-vs-논블로킹.html</link><guid isPermaLink="false">700-컴퓨터과학/동기 vs 비동기, 블로킹 vs 논블로킹.md</guid><pubDate>Sat, 13 Sep 2025 18:06:04 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[동기 vs 비동기, 블로킹 vs 논블로킹-1757786764391]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/동기-vs-비동기,-블로킹-vs-논블로킹-1757786764391.png" target="_self">]]></description><link>700-컴퓨터과학/assets/동기-vs-비동기,-블로킹-vs-논블로킹-1757786764391.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/동기 vs 비동기, 블로킹 vs 논블로킹-1757786764391.png</guid><pubDate>Sat, 13 Sep 2025 18:06:04 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[동기 vs 비동기, 블로킹 vs 논블로킹-1757786738823]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/동기-vs-비동기,-블로킹-vs-논블로킹-1757786738823.png" target="_self">]]></description><link>700-컴퓨터과학/assets/동기-vs-비동기,-블로킹-vs-논블로킹-1757786738823.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/동기 vs 비동기, 블로킹 vs 논블로킹-1757786738823.png</guid><pubDate>Sat, 13 Sep 2025 18:05:38 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[동기 vs 비동기, 블로킹 vs 논블로킹-1757786723764]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/동기-vs-비동기,-블로킹-vs-논블로킹-1757786723764.png" target="_self">]]></description><link>700-컴퓨터과학/assets/동기-vs-비동기,-블로킹-vs-논블로킹-1757786723764.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/동기 vs 비동기, 블로킹 vs 논블로킹-1757786723764.png</guid><pubDate>Sat, 13 Sep 2025 18:05:23 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[동기 vs 비동기, 블로킹 vs 논블로킹-1757784480602]]></title><description><![CDATA[<img src="700-컴퓨터과학/assets/동기-vs-비동기,-블로킹-vs-논블로킹-1757784480602.png" target="_self">]]></description><link>700-컴퓨터과학/assets/동기-vs-비동기,-블로킹-vs-논블로킹-1757784480602.html</link><guid isPermaLink="false">700-컴퓨터과학/assets/동기 vs 비동기, 블로킹 vs 논블로킹-1757784480602.png</guid><pubDate>Sat, 13 Sep 2025 17:28:00 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스프링 부트 모니터링, 보안설정]]></title><description><![CDATA[
모니터링 및 헬스 체크 Spring Boot Actuator는 운영 상태 모니터링, 관리, 상태 점검(헬스 체크), 메트릭 수집 등 다양한 엔드포인트를 제공
대표적으로&nbsp;/actuator/health&nbsp;엔드포인트를 통해 애플리케이션의 건강 상태(UP, DOWN 등)를 확인할 수 있습니다. 이 엔드포인트는 데이터베이스, 메시지 브로커, 캐시 등 주요 의존성의 상태까지 함께 체크할 수 있음
/actuator/metrics&nbsp;엔드포인트에서는 JVM, CPU, 메모리, HTTP 요청, 커스텀 비즈니스 메트릭 등 다양한 성능 지표를 실시간으로 확인할 수 있음
외부 모니터링 시스템(예: Prometheus, Grafana)과 연동하여 메트릭을 수집하고 시각화할 수 있습니다. 이때 Micrometer 라이브러리를 함께 사용하면 Prometheus 등 다양한 백엔드로 메트릭을 내보낼 수 있음
# actuator 엔드포인트 노출 설정
management.endpoints.web.exposure.include=health,metrics,prometheus # health 상세 정보 항상 노출
management.endpoint.health.show-details=always 보안 설정 연동시 인증(로그인), 인가(권한 관리) 기능이 자동으로 적용
spring-boot-starter-security&nbsp;의존성만 추가해도, 모든 엔드포인트에 기본적으로 인증이 필요하도록 보안이 활성화
기본 설정에서는 애플리케이션 실행 시 콘솔에 임시로 생성된 아이디/비밀번호가 출력되어, 이를 통해 로그인할 수 있음
필요에 따라 인증 방식, 접근 권한, 로그인/로그아웃 페이지, 암호화 방식 등 세부 보안 정책을 코드나 설정 파일로 쉽게 커스터마이징할 수 있음
]]></description><link>300-백엔드개발/스프링-부트-모니터링,-보안설정.html</link><guid isPermaLink="false">300-백엔드개발/스프링 부트 모니터링, 보안설정.md</guid><pubDate>Sat, 13 Sep 2025 17:20:26 GMT</pubDate></item><item><title><![CDATA[이벤트 기반 아키텍처(EDA)의 정합성]]></title><description><![CDATA[
도메인 데이터 변경과 이벤트 발행을 하나의 트랜잭션으로 묶어 처리합니다.
예: 주문 생성 시 orders 테이블에 데이터를 저장하고, 동시에 outbox 테이블에 이벤트를 기록합니다148.
장점: 데이터베이스의 ACID 특성을 활용해 도메인 상태와 이벤트 발행의 원자성을 보장합니다.
구현 예시:
BEGIN TRANSACTION; INSERT INTO orders (...) VALUES (...); INSERT INTO outbox (event_type, payload) VALUES ('OrderCreated', '...');
COMMIT; 배치 재시도: 주기적으로 outbox 테이블을 스캔하여 미발행된 이벤트를 재발행합니다18.
이벤트 상태 추적:
public class OutboxEvent { private boolean published; // 발행 성공 시 true로 업데이트 private LocalDateTime createdAt;
} 메시지 브로커의 신뢰성: Kafka, RabbitMQ와 같은 시스템은 메시지 영속화와 재전송 기능을 제공합니다67. 장기 실행 트랜잭션을 이벤트 시퀀스로 분할하고, 실패 시 보상 이벤트를 트리거합니다57.
예: 결제 실패 → OrderCancelled 이벤트 발행 → 재고 복구 로직 실행. 모든 상태 변경을 변경 불가능한 이벤트로 저장합니다.
시스템 상태는 이벤트 재생을 통해 복구되므로, 데이터 정합성을 자연스럽게 보장합니다5.
이벤트 큐는 다음과 같은 방식으로 유지됩니다: Idempotent Consumer: 동일 이벤트의 중복 실행을 방지하기 위해 이벤트 ID를 기반으로 처리 여부를 검증합니다4.
if (!eventLogRepository.existsByEventId(event.getId())) { processEvent(event); eventLogRepository.save(new EventLog(event.getId()));
} Dead Letter Queue (DLQ): 최대 재시도 후 실패한 이벤트를 별도 큐로 이동시켜 수동 조치가 가능하게 합니다7. 이벤트 축소: 페이로드를 최소화하여 식별자 + 이벤트 유형 + 타임스탬프만 포함시킵니다26.
{ "eventType": "OrderCreated", "orderId": "ORD-123", "timestamp": "2025-06-10T17:00:00"
}
이벤트 기반 아키텍처는 트랜잭셔널 아웃박스 패턴과 메시지 브로커의 영속성을 통해 정합성을 관리하며, 이벤트 큐는 디스크 저장과 재시도 메커니즘으로 지속성을 보장합니다. 다만, 복잡한 비즈니스 시나리오에서는 사가 패턴이나 이벤트 소싱과의 조합이 필수적입니다.]]></description><link>300-백엔드개발/이벤트-기반-아키텍처(eda)의-정합성.html</link><guid isPermaLink="false">300-백엔드개발/이벤트 기반 아키텍처(EDA)의 정합성.md</guid><pubDate>Sat, 13 Sep 2025 17:19:32 GMT</pubDate></item><item><title><![CDATA[Error - 장시간 요청 Cloudfront timeout]]></title><description><![CDATA[<img alt="nginx-1757772245845.png" src="error/assets/nginx-1757772245845.png" target="_self">
서비스 구조가 이렇게 되어있다. client : pending으로 요청이 가다가 504 에러 server &gt; nginx : 499에러 499 에러는 client가 요청을 닫앗다 즉 취소했다는 에러코드입니다 504 에러는 gateway timeout에러를 의미합니다 사용중인 client와 spring에서의 timeout시간을 최대로 늘려놓았음에도 불구하고 같은 에러가 중복되었다.따라서 중간에 프록시되는 cloudfront를 의심하게 되었다.<br>
<a data-tooltip-position="top" aria-label="https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/http-504-gateway-timeout.html" rel="noopener nofollow" class="external-link is-unresolved" href="https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/http-504-gateway-timeout.html" target="_self">cloudfront공식 문서</a>에서 cloudfront에 504문제가 나타는 경우를 2가지로 정의했다.
오리진이 CloudFront에 HTTP 504 상태 코드를 반환했습니다.
요청이 만료되기 전에 오리진이 응답하지 않았습니다.
우리는 이 2번째인 요청이 만료되기 전 origin이 응답하지 않는 문제가 발생햇던것이다.<br><a data-tooltip-position="top" aria-label="https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_CustomOriginConfig.html" rel="noopener nofollow" class="external-link is-unresolved" href="https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_CustomOriginConfig.html" target="_self">aws 공식 문서</a>에서 cloudfront의 originReadTimeout이 디폴트로 얼마나 있는지 확인해 볼 수 있엇다
OriginReadTimeout
Specifies how long, in seconds, CloudFront waits for a response from the origin. This is also known as the&nbsp;origin response timeout. The minimum timeout is 1 second, the maximum is 120 seconds, and the default (if you don't specify otherwise) is 30 seconds.
그렇다 디폴트로 30초이고 최대 2분까지 가능하다.당시 api는 ai모델을 이용하는 요청이였으므로 평균 2.5분이 걸렸다 즉 기존 http를 이용한 api로는 불가능하다고 판단하였다.따라서 ai서비스 진행상황도 유저가 트래킹할 수 있도록 웹소켓으로 데이터를 받는 것으로 수정하였다.]]></description><link>400-인프라-&amp;-아키텍처/error-장시간-요청-cloudfront-timeout.html</link><guid isPermaLink="false">400-인프라 &amp; 아키텍처/Error - 장시간 요청 Cloudfront timeout.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Sat, 13 Sep 2025 15:22:53 GMT</pubDate><enclosure url="error/assets/nginx-1757772245845.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="error/assets/nginx-1757772245845.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[b_계단 오르기_2579]]></title><description><![CDATA[한번에 1,2 jump 가능
연속된 3개 불가
마지막껀 반드시밟아야
애를밟앗을때가장높은점수
애를안밟았을때 가장 높은점수
약간 다이나믹프로그래믹
dfs로 모두 모두 다 탐색하는 일종의 브루드포스로 풀어보았다.
당연히 시간초과가 났다
import sys n = int(sys.stdin.readline().strip())
stair = []
for i in range(n): stair.append(int(sys.stdin.readline().strip())) result = 0 def dfs(i,visited,value): global result # print(i,visited,value,result) canVisit = True if i&gt;=n: if bool(visited[i-1]): # print("비교!") result=max(result,value) return if i&gt;1: canVisit = not (bool(visited[i-1] &amp; visited[i-2])) if canVisit: visited[i]=1 dfs(i+1,visited,value+stair[i]) visited[i]=0 dfs(i+1,visited,value) init_visit = [0]*n
dfs(0,init_visit,0)
print(result) 다이나믹 프로그래밍방식으로 풀었다.
0-안밟음,1-밟음밟을 수 있는 경우의 수
101
110
011
010
100, 001, 000 은 당연히 101,010 보다 클 수 없으므로 제외햇다.
그다음의 경우의 수
101 - 이전 110 or 010
110 - 이전 011
011 - 이전 101
010 - 이전 101import sys n = int(sys.stdin.readline().strip())
stair = []
for i in range(n): stair.append(int(sys.stdin.readline().strip())) def get_point(i,arr): # print(i,arr) global stair global n if i &gt;= n-2: return max(arr[i-1][0],arr[i-1][2]) # i는 -2한거임 arr[i][0]= max(arr[i-1][1]+stair[i+2],arr[i-1][3]+stair[i+2]) arr[i][1]= arr[i-1][2] arr[i][2]= arr[i-1][0]+stair[i+2] arr[i][3]= arr[i-1][0] return get_point(i+1,arr) def solution(): global n global stair if n&lt;3: return sum(stair) arr = [[0]*4 for _ in range(n-2)] arr[0][0]= stair[0]+stair[2] arr[0][1]= stair[0]+stair[1] arr[0][2]= stair[1]+stair[2] arr[0][3]= stair[1] return get_point(1,arr) print(solution()) 다른 풀이
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://bio-info.tistory.com/158" target="_self">https://bio-info.tistory.com/158</a>
점화식으로 풀엇다 나처럼 경우의 수를 직접지정하지않고
항상 마지막 stair을 밟는다고 정하고 점화식을 설계하였다 ]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/b_계단-오르기_2579.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/b_계단 오르기_2579.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Fri, 12 Sep 2025 15:40:57 GMT</pubDate></item><item><title><![CDATA[p_붕대감기]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://school.programmers.co.kr/learn/courses/30/lessons/250137" target="_self">https://school.programmers.co.kr/learn/courses/30/lessons/250137</a>
체력회복 : t초 * x
t초연속 붕대감기 성공시 +y추가 회복
최대 체력이 존재함
공격 당하면 기술과 체력회복이 취소당함
공격시 정해진 피해량만큼 체력줄어듬
if 체력 0이하 &gt; 캐릭터주금공격과 공겨사이 기간동안 추가회복이 한번만이뤄지는게아니라 여러번 이뤄질 수 있다는 것을 유의해야한다function solution(bandage, health, attacks) { let prevTime = 0; let curHealth = health; for(let a of attacks){ let [at,ad] = a; let remainTime = at- prevTime-1; curHealth = getRecovery(remainTime,curHealth,bandage,health); // console.log(remainTime,"초 회복후",curHealth) curHealth -= ad; // console.log("공격후",curHealth) // console.log('-----',at) prevTime = at; if(curHealth&lt;=0) return -1 } return curHealth;
} function getRecovery(time,curHealth,bandage,health){ let [bTime, bRecover, bAddRecover]=bandage; curHealth += time * bRecover if(time&gt;=bTime){ curHealth += bAddRecover *parseInt(time/bTime); } if(curHealth&gt;=health) return health; return curHealth;
}
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/p_붕대감기.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/p_붕대감기.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:24:25 GMT</pubDate></item><item><title><![CDATA[p_홀짝트리_388354]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://school.programmers.co.kr/learn/courses/30/lessons/388354?language=python3" target="_self">https://school.programmers.co.kr/learn/courses/30/lessons/388354?language=python3</a>1차답"""
홀짝 트리 : 노드번호의 홀짝여부와 자식노드의 개수의 홀짝여부가 일치
역 ~ : ~가 반대
모두다 트리긴함&lt;&lt; 사이클이ㅣ없음
하나씩 루트노드로지정해서
"""
import copy def solution(nodes, edges): dic = {} answer = [0,0] for n in nodes: dic[n]=[] for e in edges: dic[e[0]].append(e[1]) dic[e[1]].append(e[0]) for n in nodes: data=checkTree(n,copy.deepcopy(dic),None) if data != 0: answer[data-1] +=1 # print("결과",n,data,answer) return answer def checkTree(root,dic,isHoljjak): # print(id(dic)) # isHoljjak : 1- 홀짝, 2-역홀짝 if isHoljjak is None: # 루트노드 childLen = len(dic[root]) if root%2 == childLen%2: isHoljjak = 1 else: isHoljjak = 2 else: # 자식노드 childLen = len(dic[root]) - 1 # 부모 제외 if root%2 == childLen%2: if isHoljjak != 1: return 0 else: if isHoljjak != 2: return 0 # 자식들 확인 for child in dic[root]: dic[child].remove(root) result = checkTree(child, dic, isHoljjak) if result == 0: return 0 return isHoljjak
2차답def solution(nodes, edges): dic = {} answer = [0,0] for n in nodes: dic[n]=[] for e in edges: dic[e[0]].append(e[1]) dic[e[1]].append(e[0]) holjjak = [0, 0] # [홀짝 트리 수, 역홀짝 트리 수] for node in nodes: try: result = checkTree(node, dic.copy(), None) if result != 0: holjjak[result-1] += 1 except: pass return holjjak
3차답
아마 각노드마다 2가지경우가 있을 것같다
루트노드인경우
루트노드가아닌경우
이렇게해서 저장을하고돌려야할것같다
아님아님
4차답
레전드 한트리에 하나의 루트노드면 특정트리임
그래서 루트일때자식일때 어떤노드인지 받아놓고
한트리내에서 루트일때 A 자식일때 다 B면
또 뻐킹 런타임에러가난다.
근데 조금 개선되엇다.
그냥queue를이용하는측면이ㅓㅇ떤가싶다.def solution(nodes, edges): graph = {n: [] for n in nodes} visited = set() for a, b in edges: graph[a].append(b) graph[b].append(a) holjjakDic = {} # 보닌이 홀찍인지 역홀짝인지 for n in nodes: childLen = len(graph[n]) a = n%2 b = childLen%2 c = (childLen-1)%2 # 루트일때 자식일때 holjjakDic[n] = [1 if a==b else 2,1 if a==c else 2] # print(holjjakDic) holjjak = [0, 0] # [홀짝 트리 수, 역홀짝 트리 수] def dfs(node,dic): if node in visited: return False visited.add(node) r,c=holjjakDic[node] Rkey = f'R{r}' Ckey = f'C{c}' dic[Rkey].append(node) dic[Ckey].append(node) for child in graph[node]: dfs(child,dic) for node in nodes: if node in visited: continue dic = { "R1":[], "R2":[], "C1":[], "C2":[], } dfs(node, dic) if len(dic["R1"]) == 1: holjjak[0] +=1 if len(dic["R2"]) == 1: holjjak[1] +=1 # print(node,dic) return holjjak
5차답안 (성공!)
역시 재귀는 쓰래기다
라고하면안되겟죠?
depth가 커져서 메모리를 많이잡아 먹어 에러가 나는거 같다.
따라서 dfs에서 bfs
즉 queue와 while문을 이용하엿더니 통과하였다.from collections import deque def solution(nodes, edges): graph = {n: [] for n in nodes} visited = set() for a, b in edges: graph[a].append(b) graph[b].append(a) holjjakDic = {} # 보닌이 홀찍인지 역홀짝인지 for n in nodes: childLen = len(graph[n]) a = n%2 b = childLen%2 c = (childLen-1)%2 # 루트일때 자식일때 holjjakDic[n] = [1 if a==b else 2,1 if a==c else 2] # print(holjjakDic) holjjak = [0, 0] # [홀짝 트리 수, 역홀짝 트리 수] dic = {} for node in nodes: if node in visited: continue dic = { "R1":[], "R2":[], "C1":[], "C2":[], } queue = deque([node]) while len(queue)&gt;0: # print(queue) k = queue.popleft() if k in visited: continue visited.add(k) r,c=holjjakDic[k] Rkey = f'R{r}' Ckey = f'C{c}' dic[Rkey].append(k) dic[Ckey].append(k) for child in graph[k]: if child not in visited: queue.append(child) if len(dic["R1"]) == 1: holjjak[0] +=1 if len(dic["R2"]) == 1: holjjak[1] +=1 # print(node,dic) return holjjak
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/p_홀짝트리_388354.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/p_홀짝트리_388354.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:23:54 GMT</pubDate></item><item><title><![CDATA[p_퍼즐조각채우기_84021]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://school.programmers.co.kr/learn/courses/30/lessons/84021?language=python3" target="_self">https://school.programmers.co.kr/learn/courses/30/lessons/84021?language=python3</a>조각은 회전가능 뒤집기 불가기존에는 스탭에 따라 노드를 기억하거나 스탭(깊이)에 따른 이전스탭에 대한 차이값을 저장해야한다고생각했다, (이렇게하면 3차원이상...)근데 걍 기준점에 대해서 갈 수 있는 노드의 리스트를 얻으면 된다. 2차원배열. (x,y저장할때 1차원생기니깐)그리고 여기서는 조건이 있었다.from collections import deque
import copy
move = [[-1,0],[1,0],[0,-1],[0,1]] def bfs(arr,y,x,visit): # dif는 비교대상 visit table은0 다른건1 narr = copy.deepcopy(arr) limit = [len(narr)-1,len(narr[0])-1] q = deque([(y,x)]) shape = [(0,0)] # 기준점중심으로 바뀐 정도만 저장 narr[y][x] = visit while q: ny,nx = q.popleft() for m in move: my = ny + m[0] mx = nx + m[1] if my&lt;0 or mx&lt;0 or my&gt; limit[0] or mx &gt; limit[1]: continue if narr[my][mx] != visit: continue narr[my][mx] = visit shape.append((my-y,mx-x)) q.append((my,mx)) return shape def find_board(game_board,shapes): cnt = 0 for i in range(len(game_board)): for j in range(len(game_board[0])): if game_board[i][j] == 0: shape = bfs(game_board,i,j,1) if shape in shapes: shapes.remove(shape) cnt += 1 return [game_board,cnt] def solution(game_board, table): shapes = [] for i in range(len(table)): for j in range(len(table[0])): if table[i][j] == 1: shape = bfs(table,i,j,0) shapes.append(shape) cnt = 0 for _ in range(4): [game_board,n_cnt] = find_board(game_board,shapes) cnt += n_cnt print(shapes) game_board = list(map(list,zip(*game_board[::-1]))) [game_board,n_cnt] = find_board(game_board,shapes) cnt += n_cnt return cnt
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/p_퍼즐조각채우기_84021.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/p_퍼즐조각채우기_84021.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:23:51 GMT</pubDate></item><item><title><![CDATA[p_충돌위험찾기]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://school.programmers.co.kr/learn/courses/30/lessons/340211" target="_self">https://school.programmers.co.kr/learn/courses/30/lessons/340211</a>n개의 좌표 (y,x) 포인트가 있음 각 포인트는 지정숫자를 가짐
로봇마다 운송경로가 존재함
routes는 포인트들의 리스트로 이뤄져있음. 해당포인트를 거처야함.
routes[a] 는 a 번째 로봇의 운송 경로.
routes[a]의 값은 a번째 로봇이 순서대로 방문하는 포인트번호
로봇은 x대 , 0초에 출발, 1초마다 상하좌우한칸씩만 갈수 있음
이동시 항상최단경로. if 최단경로 여러개, y좌표 이동을 우선함
마지막포인트에 도착한로봇은 물류센터 벗어남, 벗어나는 경로는 고려 ㄴㄴ2대이상모인다면 충돌할 가능성이 있는 위험상황으로 간주
위험상황을 새라function solution(points, routes) { let crack = 0; let starts = []; let moves = []; let movesIndex = []; let pointCheck = {} for(let i = 0;i&lt;routes.length; i++){ let move = []; let before = []; for(let j = 0;j&lt;routes[0].length; j++){ let point = points[routes[i][j]-1] if(j===0){ let [y,x] = point; if(checkCrack(pointCheck,point)) crack++; starts.push([y,x]) }else{ let dy = point[0] - before[0]; let dx = point[1] - before[1]; move.push([dy,dx]) } before = point; } moves.push(move); movesIndex.push(0); } let time = 0; while(true){ time++; let currentPositions = {}; let allFinished = true; for(let i = 0; i &lt; routes.length; i++){ if(movesIndex[i] &gt;= moves[i].length){ continue; } allFinished = false; let [dy, dx] = moves[i][movesIndex[i]]; let [cy, cx] = starts[i]; if(dy !== 0){ starts[i][0] += dy &gt; 0 ? 1 : -1; } else if(dx !== 0){ starts[i][1] += dx &gt; 0 ? 1 : -1; } if(starts[i][0] === points[routes[i][movesIndex[i]+1]-1][0] &amp;&amp; starts[i][1] === points[routes[i][movesIndex[i]+1]-1][1]){ movesIndex[i]++; } let key = `${starts[i][0]},${starts[i][1]}`; if(currentPositions[key]){ currentPositions[key]++; if(currentPositions[key] === 2) crack++; } else { currentPositions[key] = 1; } } if(allFinished) break; } return crack;
} function checkCrack(dict, point){ let [y,x] = point; let key = `${y}${x}` if(dict[key]){ dict[key]++; if(dict[key]===2) return true }else{ dict[key]=1 } return false
}
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/p_충돌위험찾기.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/p_충돌위험찾기.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:23:37 GMT</pubDate></item><item><title><![CDATA[p_유연근무제_388351]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://school.programmers.co.kr/learn/courses/30/lessons/388351" target="_self">https://school.programmers.co.kr/learn/courses/30/lessons/388351</a>
1주일동안 출근희망시각에 늦지않게
토일 이벤트영향 ㄴㄴ67알바없음
출근희망시각 +10까지 ㄱㅊ
1-7 월시작
선물받을 직원구하삼startday포함 +7일인거 감안을 처음에안함
시간 : 20분 걸림def solution(schedules, timelogs, startday): N = len(schedules) answer = N for i in range(N): limitT = schedules[i] + 10 limitH = int(limitT/100) + int((limitT%100)/60) limitM = (limitT%100)%60 limitT = limitH*100+limitM # print(limitT) flag = True for j in range(7): day = (j+startday)%7 if day == 0 or day == 6: # print(i,day,timelogs[i][j],"통과") continue if limitT&lt;timelogs[i][j]: flag = False break if flag is not True: answer -= 1 # print(i,day,"탈락") # print("---") return answer
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/p_유연근무제_388351.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/p_유연근무제_388351.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:23:37 GMT</pubDate></item><item><title><![CDATA[p_시험장나누기_81305]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://school.programmers.co.kr/learn/courses/30/lessons/81305" target="_self">https://school.programmers.co.kr/learn/courses/30/lessons/81305</a>유니온파인드하면서 합치면될듯?내답import heapq def solution(k, num, links): N = len(num) # 노드의 개수 parent = [i for i in range(N)] # 직계 부모 weight = [] for i in range(N): weight.append([-num[i],i]) for i in range(N): l,r = links[i] increase= 0# 음수임 if l &gt; -1: parent[l] = i increase += weight[l][0] if r &gt; -1: parent[r] = i increase += weight[r][0] weight[i][0] += increase update(parent,weight,increase,i) # print(i,"------") # print(parent,weight,increase) heapq.heapify(weight) # heap 사용하고 최소힙이니깐 - 이용함 # k만큼 for 문 # 앞에꺼하나 뺌 # 자식이없음. &gt; 걍그거 리턴하시면됨. # 자식보다 부모가 항상큼 &gt; 고로 pop하면서 아니면 다시넣어주고 이런식으로하면댐 # 자식이잇음 &gt; 자식이 하나면 그거랑 끊고 자식이 2명이면 둘중 큰거랑 끊음&gt; 나랑 직계부모 업데이트, 부모정보도 업데이트+링크정보도 업뎃 # print('w',weight) for _ in range(k-1): w,i = heapq.heappop(weight) l,r = links[i] if parent[l] != i: # 이미 끊어 졋던거임 l = -1 links[i][0]= -1 if parent[r] != i: r = -1 links[i][1]= -1 if l&lt;0 and r&lt;0: return -w else: targetW = None depth = 0 remain = [] while targetW is None: # print(depth) if depth &gt;N: break depth +=1 nw,ni = heapq.heappop(weight) if ni == l or ni == r: targetW = [nw,ni] else: remain.append([nw,ni]) for rem in remain: heapq.heappush(weight,rem) # print(targetW) # 부모랑 연결끊기 if targetW is None: return -w tw,ti=targetW w -= tw parent[ti] = ti heapq.heappush(weight,[w,i]) heapq.heappush(weight,targetW) # print(weight) # print(parent) # print("-") return -weight[0][0] def update(parent,weight,value,idx): i = idx while parent[i] != i: i = parent[i] weight[i][0] += value
실제 답<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://loosie.tistory.com/342" target="_self">https://loosie.tistory.com/342</a>]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/p_시험장나누기_81305.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/p_시험장나누기_81305.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:23:16 GMT</pubDate></item><item><title><![CDATA[b_IF문대신_19637]]></title><description><![CDATA[전투력 기준으로 칭호를 붙여줄라고함if power &lt;= 10000 print WEAK
else if power &lt;= 100000 print NORMAL
else if power &lt;= 1000000 print STRONG
칭호개수, 캐릭터개수
칭호와 전투력겁나쉽잖아? &gt;&gt; 바로시간초과 ㅅㄱ
이분탐색써서했음import sys
from collections import deque
n, m = map(int,sys.stdin.readline().strip().split())
name = []
name_dic = {}
tmp_cnt =0
for j in range(n): tmp = sys.stdin.readline().strip().split() if j-tmp_cnt&gt;0: if name[j-tmp_cnt-1][1]==int(tmp[1]): tmp_cnt+=1 continue name.append([tmp[0],int(tmp[1])]) name_dic[tmp[1]] = tmp[0]
# print(name)
ans = ""
def search(start,end,v): mid = (start + end)//2 # print(start,end,mid,v) if start&gt;end: return name[start][0] mid_v = name[mid][1] if mid_v == v: return name[mid][0] elif mid_v &lt; v: return search(mid+1,end,v) return search(start,mid-1,v)
for _ in range(m): tmp = int(sys.stdin.readline().strip()) c="" start = 0 end = len(name)-1 if tmp in name_dic: c= name_dic[tmp] else: c = search(0,len(name)-1,tmp) # print('------'+c+'------') ans += (c+'\n')
print(ans)
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/b_if문대신_19637.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/b_IF문대신_19637.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:21:55 GMT</pubDate></item><item><title><![CDATA[p_동영상재생기]]></title><description><![CDATA[10초 전이동 : if 10초 미만 , 0으로이동
10초 후이동 : if end-current &lt;10sec , end로 이동
오프닝건너뛰기 : if current == opening구간 , opening끝으로 이동
오프닝 사이이면 자동으로 끝으로 이동해야함단순구현문제라 쉬웠다.function solution(video_len, pos, op_start, op_end, commands) { video_len = convertToTime(video_len); pos = convertToTime(pos); op_start = convertToTime(op_start); op_end = convertToTime(op_end); for(let c of commands){ pos = checkOpening(op_start,op_end,pos) if(c === "prev"){ pos[1] -= 10 if(pos[1]&lt;0){ pos[1] += 60 pos[0] -= 1 } if(pos[0]&lt;0){ pos = [0,0] } }else if(c === "next"){ pos[1] += 10 if(pos[1]&gt;59){ pos[1] -= 60 pos[0] += 1 } if(pos[0]&gt;video_len[0]||(pos[0]===video_len[0]&amp;&amp;pos[1]&gt;video_len[1])){ pos = [...video_len] } } // console.log(pos) } pos = checkOpening(op_start,op_end,pos) // console.log(pos) let answer = pos[0].toString().padStart(2,'0') + ':' + pos[1].toString().padStart(2,'0') return answer;
} function convertToTime(value){ return [parseInt(value[0]+value[1]),parseInt(value[3]+value[4])]
} function checkOpening(start,end,current){ if(start[0]&gt;current[0] || (start[0]===current[0] &amp;&amp; start[1]&gt;current[1])){ // 시작보다 앞이면 리턴 return current; } if(end[0]&lt;current[0] || (end[0]===current[0] &amp;&amp; end[1]&lt;current[1])){ // 끝보다 뒤면 리턴 return current; } return [...end]
} ]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/p_동영상재생기.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/p_동영상재생기.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:20:41 GMT</pubDate></item><item><title><![CDATA[p_두원사이의정수쌍_181187]]></title><description><![CDATA[1차답 시간초과# 둘다정수임
def solution(r1, r2): inner = 0 edge = 0 for x in range(r2+1): for y in range(r2+1): if x+y&lt;r1: continue des = calDes(x,y) if des &lt;=r2 and r1&lt;=des: if x == 0 or y == 0: edge +=1 else: inner +=1 return inner*4 + edge*2 def calDes(x,y): return (x**2 + y ** 2)**0.5
def solution(r1, r2): answer = 0 cntR1 = 0 cntR2 = 0 print('cntR2 count') for k in range(1 , r2): cntR2 = cntR2 + int((r2 ** 2 - (k) ** 2) ** 0.5) print('cntR1 count') for k in range(1 , r1): if (r1 ** 2 - (k) ** 2) ** 0.5 == int((r1 ** 2 - (k) ** 2) ** 0.5): cntR1 = cntR1 + int((r1 ** 2 - (k) ** 2) ** 0.5) - 1 else: cntR1 = cntR1 + int((r1 ** 2 - (k) ** 2) ** 0.5) answer = cntR2 - cntR1 + r2 - r1 + 1 return 4 * answer
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/p_두원사이의정수쌍_181187.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/p_두원사이의정수쌍_181187.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:20:35 GMT</pubDate></item><item><title><![CDATA[p_등굣길_42898]]></title><description><![CDATA[최단거리개수의합
아래와 오른쪽으로만갈수있음bfs를 이용해야겠다라는 생각을했다. 그리고 이미 방문한곳을 아예갈수 없는게 아니라 같은 스텝의 경우는 허용되기에 이부분을 어떻게 처리할지 고민이 깊었다.
근데 고민할 필요가없엇다 아래와 오른쪽으로만 갈 수 있다는 조건 이있었기에 각기 다른방향에서오는 최단거리를 고대로 합해주는 식으로 하면됐었다.
이때 주요포인트가 각자 다른 거리지만 한목적지를 향해서 오는 것에 대해서는 나중에 방문햇던 리스트목록에 set으로 넣어야한다는 것이다. 아니면 중복처리가 된다.
def solution(m, n, puddles): ways =[[0,1],[1,0]] visit =[[0]*m for _ in range(n)] q = {(0,0)} visit[0][0] = 1 while q and visit[n-1][m-1] == 0: tq = set([]) for y,x in q: before = visit[y][x] for dy,dx in ways: ny = y+dy nx = x+dx if [nx+1,ny+1] in puddles: continue if 0&lt;=ny and 0&lt;=nx and ny&lt;n and nx&lt;m: visit[ny][nx] +=before tq.add((ny,nx)) q = tq return visit[n-1][m-1] % 1000000007
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/p_등굣길_42898.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/p_등굣길_42898.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:20:30 GMT</pubDate></item><item><title><![CDATA[p_서버 증설 횟수_389479]]></title><description><![CDATA[m명당 서버 하나
한번 증설한 서버는 k시간동안 운영하고 반납함from collections import deque
def solution(players, m, k): que = deque([])# 시작 시간 넣을꺼임 answer = 0 for i in range(len(players)): while que: diff = i-que[0] if diff&gt;= k: que.popleft() else: break n = len(que) p = players[i] need = p // m - n if need &lt;= 0: continue for _ in range(need): que.append(i) answer += need return answer
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/p_서버-증설-횟수_389479.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/p_서버 증설 횟수_389479.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:20:02 GMT</pubDate></item><item><title><![CDATA[p_아날로그 시계_250135]]></title><description><![CDATA[초침 기준으로 분침과 시침이 겹치면 알람이 울린다.
울리는 알람의 횟수를 알려줘주의점 시침과 분침이 겹치면 1번으로 고려한다.1차답"""
시분초침이잇음용
속도는 일정
시침 분침 겹칠때마다알림
초침이 시침or분침과 겹치면알람울림 start각도를 구함
구간임
""" def solution(h1, m1, s1, h2, m2, s2): difS = (h2*3600+m2*60 +s2)- (h1*3600+m1*60 +s1) # 초앵글을 기준으로 리셋시킴 h_angle = h1 * 30 + m1 * 0.5 + s1 * 0.5/60 m_angle = m1 * 6 + s1 * 6/60 s_angle = s1 * 6 h_angle -= s_angle m_angle -= s_angle if h_angle&lt;0: h_angle += 360 if m_angle&lt;0: m_angle += 360 s_angle = 0 # print(difS,h_angle,m_angle,s_angle) # 일자로 생각해보셈 속력을 구하자 # 1도 도는데 속력 sec기준 # 함수로 생각해보셈 x초에 만난다. # 최대2번임 x가 음수면 안만남요 h_speed = 30/3600 m_speed = 6/60 s_speed = 360/60 # h_angle + x*h_speed = s_angle + x*s_speed # h_angle-s_angle = x(s_speed-h_speed) # 360 answer = 0 # 1분에 초가 360도도니깐 1분이기준이 되어야합니다 븅띤아! # 1분에 분침은 6도를돈다. while difS &gt;= 60: limit = 60 difS -= 60 flag = False xh = round((h_angle)/(s_speed-h_speed),4) xm = round((m_angle)/(s_speed-m_speed),4) h_angle,m_angle = add_angel_by_minute(h_angle,m_angle) if 0&lt;=xh and xh&lt;60: flag = True answer += 1 # print(xh) if 0&lt;=xm and xm&lt;60: flag = True answer += 1 if flag and xh == xm: answer -= 1 # print("중복일치",xh,xm) # print(xh,xm,difS,flag,answer,h_angle,m_angle) if difS &gt; 0: limit = difS flag = False xh = round((h_angle)/(s_speed-h_speed),4) xm = round((m_angle)/(s_speed-m_speed),4) h_angle,m_angle = add_angel_by_minute(h_angle,m_angle,difS/60) if 0&lt;=xh and xh&lt;=difS: flag = True answer += 1 # print(xh) if 0&lt;=xm and xm&lt;=difS: flag = True answer += 1 if flag and xh == xm: answer -= 1 # print("중복일치",xh,xm) # print(xh,xm,difS,flag,answer,h_angle,m_angle) return answer def add_angel_by_minute(h_angle,m_angle,time = 1): h_angle += 0.5/time m_angle += 6/time if h_angle &gt;= 360: h_angle -= 360 if m_angle &gt;= 360: m_angle -= 360 return [h_angle,m_angle] 30 179.75 177.0 0
30.000000000000004 29.999999999999996 -30 True 1
다음과같은 문제가 있다.
시작 지점인 h1 m1 s1으로 잡으면 마지막 구간을 판별을 못하고 마지막 지점인 h2 m2 s2로 잡으면 시작 구간을 판별하지 못합니다. (테스트 케이스 19번 문제)
생각해보니 0시정각인데
0, 0, 0, 23, 0, 0
27352차답
역시사람들은 뻐킹진어스하다.
60초만남았을때 즉
0이상 60초미만인상황에서
0&lt;=t&lt;60초만세고 60초 즉 다시 0초된상황을 포함시지않았던것이 문제였다.
def solution(h1, m1, s1, h2, m2, s2): difS = (h2*3600+m2*60 +s2)- (h1*3600+m1*60 +s1) # 초앵글을 기준으로 리셋시킴 h_angle = h1 * 30 + m1 * 0.5 + s1 * 0.5/60 m_angle = m1 * 6 + s1 * 6/60 s_angle = s1 * 6 h_angle -= s_angle m_angle -= s_angle if h_angle&lt;0: h_angle += 360 if m_angle&lt;0: m_angle += 360 s_angle = 0 # print(difS,h_angle,m_angle,s_angle) # 일자로 생각해보셈 속력을 구하자 # 1도 도는데 속력 sec기준 # 함수로 생각해보셈 x초에 만난다. # 최대2번임 x가 음수면 안만남요 h_speed = 30/3600 m_speed = 6/60 s_speed = 360/60 # h_angle + x*h_speed = s_angle + x*s_speed # h_angle-s_angle = x(s_speed-h_speed) # 360 answer = 0 # 1분에 초가 360도도니깐 1분이기준이 되어야합니다 븅띤아! # 1분에 분침은 6도를돈다. while difS &gt; 60: limit = 60 difS -= 60 flag = False xh = round((h_angle)/(s_speed-h_speed),4) xm = round((m_angle)/(s_speed-m_speed),4) h_angle,m_angle = add_angel_by_minute(h_angle,m_angle) if 0&lt;=xh and xh&lt;60: flag = True answer += 1 # print(xh) if 0&lt;=xm and xm&lt;60: flag = True answer += 1 if flag and xh == xm: answer -= 1 # print("중복일치",xh,xm) # print(xh,xm,difS,flag,answer,h_angle,m_angle) if difS &gt; 0: limit = difS flag = False xh = round((h_angle)/(s_speed-h_speed),4) xm = round((m_angle)/(s_speed-m_speed),4) h_angle,m_angle = add_angel_by_minute(h_angle,m_angle,difS/60) if 0&lt;=xh and xh&lt;=difS: flag = True answer += 1 # print(xh) if 0&lt;=xm and xm&lt;=difS: flag = True answer += 1 if flag and xh == xm: answer -= 1 # print("중복일치",xh,xm) # print(xh,xm,difS,flag,answer,h_angle,m_angle) return answer def add_angel_by_minute(h_angle,m_angle,time = 1): h_angle += 0.5/time m_angle += 6/time if h_angle &gt;= 360: h_angle -= 360 if m_angle &gt;= 360: m_angle -= 360 return [h_angle,m_angle] def solution(h1, m1, s1, h2, m2, s2): difS = (h2*3600+m2*60 +s2)- (h1*3600+m1*60 +s1) # 초 앵글을 기준으로 리셋시킴 즉 초앵글이 12로 가게끔. s_angle = s1 * 6 m_angle = m1 * 6 + s1 * 6/60 - s_angle h_angle = h1 * 30 + m1 * 0.5 + s1 * 0.5/60 - s_angle if h_angle&lt;0: h_angle += 360 if m_angle&lt;0: m_angle += 360 s_angle = 0 # print(difS,h_angle,m_angle,s_angle) # 일자로 생각해보셈 속력을 구하자 # 속력 per 초 # 단 초가 0~60사이 여야함. 한바뀌단위로 측정해야함.ㅇㅇ h_speed = 30/3600 m_speed = 6/60 s_speed = 360/60 # h_angle + x*h_speed = s_angle + x*s_speed # &gt;&gt; h_angle - s_angle = x(s_speed-h_speed) answer = 0 # 1분에 초가 360도도니깐 1분이기준이 되어야 함. while difS &gt; 0: isPassed = False isEnd = False if difS &lt;= 60 : isEnd = True limit = difS if isEnd else 60 difS -= 60 xh = round((h_angle)/(s_speed-h_speed),4) xm = round((m_angle)/(s_speed-m_speed),4) h_angle,m_angle = add_angel_by_minute(h_angle,m_angle) if 0&lt;=xh and (xh&lt;limit or (isEnd and xh == limit)): isPassed = True answer += 1 if 0&lt;=xm and (xm&lt;limit or (isEnd and xm == limit)): isPassed = True answer += 1 if isPassed and xh == xm: answer -= 1 # print("중복일치",xh,xm) # print(xh,xm,difS,flag,answer,h_angle,m_angle) return answer def add_angel_by_minute(h_angle,m_angle,time = 1): h_angle += 0.5/time m_angle += 6/time if h_angle &gt;= 360: h_angle -= 360 if m_angle &gt;= 360: m_angle -= 360 return [h_angle,m_angle] ]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/p_아날로그-시계_250135.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/p_아날로그 시계_250135.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:19:35 GMT</pubDate></item><item><title><![CDATA[p_요격시스템_181188]]></title><description><![CDATA[ㅁ사일 요격하려고함
미사일 최소로 사용해서 ㅇㅇ
x축의 값이 같으면 한번에 요격가능
s &gt; e 로 갈때 s와 e 값의 요격미사일은 격추 불가.
x축값은 실수임(정수가아님)개구간범위를 잘확인해야한다.import heapq
def solution(targets): answer= 0 start = -1 end = -1 heapq.heapify(targets) while targets: s,e = heapq.heappop(targets) if start == -1: start = s if end == -1 or e&lt;end: end = e if s&gt;=end: start = s end = e answer += 1 # print(s,e,start,end,answer) if not (start == -1 or end == -1) : answer +=1 return answer
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/p_요격시스템_181188.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/p_요격시스템_181188.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:19:28 GMT</pubDate></item><item><title><![CDATA[p_주사위고르기_258709]]></title><description><![CDATA[브루드포스주사위 n 개
n/2 개씩 각각 가질때
각각의 나오는 숫자과 확률 개수구해서 주사위 조합당 평균을 비교하면 되지않을까..
일단 주사위의 조합을 구해보자.
# dic길이 한자리수
dic_comb = {} # 각주사위별 숫자조합
comb_idx = [] def solution(dice): answer = [] visited = [0] * len(dice) find_combin(visited,0,0,{},dice) # print(dic_comb) # print(comb_idx) winner = [-1,-1] # 주사위, 확률 for left,right in comb_idx: win = 0 lose = 0 for k1,v1 in dic_comb[left]: for k2,v2 in dic_comb[right]: if k1&gt;k2: win += v1 * v2 elif k1&lt;k2: lose += v1 * v2 if win &gt; lose and winner[1]&lt;win: winner[0] = left winner[1] = win elif win &lt; lose and winner[1] &lt; lose: winner[0] = right winner[1] = lose # print(winner) return list(map(lambda x: int(x)+1,winner[0])) def find_combin(visited,ind,depth,current,dice): leng = len(visited) # print(visited,depth,current) if depth &gt;= leng/2: global dic_comb global comb_idx tmpv = "" tmpl = "" for i in range(leng): if visited[i]: tmpv += str(i) else: tmpl += str(i) if tmpv[0] == '0': comb_idx.append((tmpv,tmpl)) clisted= list(current.items()) clisted.sort() dic_comb[tmpv] = clisted return for i in range(ind,leng): if visited[i]: continue visited[i] = 1 tmpc = {} for j in dice[i]: if current: for key,value in current.items(): if key+j in tmpc: tmpc[int(key)+j] += value else: tmpc[int(key)+j] = value else: if j in tmpc: tmpc[j] +=1 else: tmpc[j] = 1 find_combin(visited,i,depth+1,tmpc,dice) visited[i] = 0
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/p_주사위고르기_258709.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/p_주사위고르기_258709.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:19:18 GMT</pubDate></item><item><title><![CDATA[p_택배 상자 꺼내기_389478]]></title><description><![CDATA[수직으로만 꺼냂 수잇음
n으로 나눠서
몫이 홀수면 왼쪽부터 짝수면 오른쪽부터임
나머지가 0이면 풀 잇기 시작 하면 n-나머지 만큼공간이 비어잇음def solution(n, w, num): # 0부터시작 다. def xyCalculate(value): y = (value-1) // w # 몫 b = (value-1) % w # 나머지 isEven = y % 2 == 0 # 짝수면 왼쪽부터 x = b if isEven else w-1 - b return [y,x,isEven] n_y,n_x,n_isEven = xyCalculate(n) num_y,num_x,num_isEven = xyCalculate(num) answer = n_y-num_y if n_isEven: # 왼쪽부터참 if num_x&gt; n_x: answer -= 1 else: if num_x&lt;n_x: answer -= 1 return answer + 1
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/p_택배-상자-꺼내기_389478.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/p_택배 상자 꺼내기_389478.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:19:03 GMT</pubDate></item><item><title><![CDATA[p_퍼즐게임챌린지]]></title><description><![CDATA[퍼즐난이도 : diff
현퍼즐 소요시간:time_cur
이전퍼즐 소요시간: time_prev
내숙련도 : level
if diff &lt;= level , +=time_cur
if diff &gt; level , diff-level 만큼틀림
틀릴때마다 time_cur + time_prev
만약풀면 앞에꺼 다시안풀어도되니깐 time_cur
limit 시간이 정해져있음
시간안에 해결할 수 있는 최소의 숙련도를 구하라.이분탐색이용하면 될꺼가튼데?
문제를 잘못이해햇다 이전꺼전부를푸는게아니라 바로 이전꺼만 풀면되는것엿다.
그리고 처음에는 Math.max썼는데 이거때매 에러남 인자길이가 너무길어지면 에러가 날 수 있다고 한다.
그리고 숙련도가 양의 정수라는 지문을 뻬먹었엇다.function solution(diffs, times, limit) { let start = 0; let end = 100000; let mid; while(start&lt;=end){ let time_prev = 0 mid = parseInt((start+end)/2) for(let i in diffs){ if(diffs[i]&lt;= mid){ time_prev += times[i] }else{ let wrong = diffs[i]-mid let before = i&lt;1? 0: times[i-1] time_prev += before*wrong + times[i]*(wrong+1) } } // console.log(start,end,mid,time_prev,limit) if(time_prev === limit) return mid if(time_prev&lt;limit){ end = mid -1; }else{ start = mid + 1 } } if(start&lt;1) return 1 return start
}
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/p_퍼즐게임챌린지.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/p_퍼즐게임챌린지.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:18:55 GMT</pubDate></item><item><title><![CDATA[P_합승택시요금]]></title><description><![CDATA[서로다른 사람 A,B가 같은 곳에서 출발해서 각각 다른지점에 갈려고한다.플로이드워셜일 각이 빡온다.
출발지는하나이나. 경유햇을경우!
역시맞앗다 ㅋㅋ
이때 유의해야할께 k가 가장 밖에잇어야한다는거시다.!function solution(n, s, a, b, fares) { //n 지점개수 , s 시작점, ab 각각 집들 //fares [c, d, f] c&lt;-&gt;d 의 비용 : f a -= 1; b -= 1; s-=1; let dist = []; for(let i =0;i&lt;n;i++){ let tmp = []; for(let j =0;j&lt;n;j++){ if(i===j){ tmp.push(0) }else{ tmp.push(Infinity); } } dist.push(tmp) } for(let i =0;i&lt;fares.length;i++){ let [c,d,f] = fares[i]; if(dist[c-1][d-1]&gt;f){ dist[c-1][d-1] = f dist[d-1][c-1] = f } } for(let k =0;k&lt;n;k++){ for(let i =0;i&lt;n;i++){ for(let j =0;j&lt;n;j++){ dist[i][j] = Math.min(dist[j][i],dist[i][j],dist[i][k]+dist[k][j]); dist[j][i] = dist[i][j] } } } // console.log(dist) let answer = dist[s][a]+dist[s][b]; // console.log(answer) for(let k =0;k&lt;n;k++){ let tmp = dist[s][k]+ dist[k][a]+dist[k][b]; answer = Math.min(tmp,answer) } return answer;
}
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/p_합승택시요금.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/P_합승택시요금.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:18:43 GMT</pubDate></item><item><title><![CDATA[s_CPTI]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://softeer.ai/practice/11002" target="_self">https://softeer.ai/practice/11002</a>중복제거를 할람면 sorting을행햐ㅏㅁ 걍 돌리는게맞음index + ":" + 숫자 이렇게해서 각각 set을 만들어 차집합으로 하면 어떨까 생각햇지만 그것또한 for문이돌아서안댄다dif=bin(b ^ tmp)[2:] 자르기도 걸려서 안하는게 좋다..import sys n,m = sys.stdin.readline().strip().split(' ') # 사람 수 , 문자열 길이
# 다른게 두개 이하면 친밀감 느낌 ans = 2** int(m) - 1
cnt = 0 before = [] for _ in range(int(n)): tmp = int(sys.stdin.readline().strip(),2) nCnt = 0 for b in before: dif=bin(b ^ tmp).count('1') # print(dif,bin(b ^ tmp)[2:]) if dif &lt; 3 : nCnt += 1; cnt += nCnt # print("cnt",cnt,nCnt) # print("----") before.append(tmp) # print(before)
print(cnt)
이렇게 하면 o(n^2 * m) 이다근데 이렇게 하면안된다 M이 훨씬적으니깐 m을 기준으로 찾아야한다.def count_intimate_pairs(N, M, cptis): cpti_count = {} # key는 M길이의 값이고 value는 그게 몇개인지 알려줌 total_pairs = 0 for cpti in cptis: x = int(cpti, 2) count = 0 # 동일한 CPTI count += cpti_count.get(x, 0) # 1비트 차이나는 CPTI for i in range(M): y = x ^ (1 &lt;&lt; i) # 하나씩 바꿔봐요 count += cpti_count.get(y, 0) # 2비트 차이나는 CPTI for i in range(M): for j in range(i+1, M): y = x ^ (1 &lt;&lt; i) ^ (1 &lt;&lt; j)# 두개씩 바꿔봐요 count += cpti_count.get(y, 0) total_pairs += count cpti_count[x] = cpti_count.get(x, 0) + 1 # 몇개있는지 저장,업데이트 return total_pairs # 입력 처리
N, M = map(int, input().split())
cptis = [input().strip() for _ in range(N)] # 결과 출력
result = count_intimate_pairs(N, M, cptis)
print(result) M≤30이므로, 주어진 이진 문자열을 32비트 정수로 저장 가능하며 M비트 정수로 취급할 수 있습니다.각 사람의 CPTI를 순서대로 순회하며, 현재 사람의 CPTI를 나타내는 이진 문자열을 M비트 정수 xx로 변환한다고 합시다. 그러면 그 사람이 친밀감을 느낄 수 있는 CPTI는 x와 최대 두 위치의 비트가 다른 M비트 정수입니다. 이를 위해 고려할 경우는 다음 세 가지입니다:
x와 동일한 값.
x와 한 개의 비트에서만 차이가 나는 값.
x와 두 개의 비트에서 차이가 나는 값.
이 값들이 사람들의 CPTI 목록에서 이전에 등장한 횟수를 전부 더하면 현재 사람이 친밀감을 느끼는 사람의 수를 구할 수 있습니다. 등장 횟수를 효율적으로 구하고 저장하기 위해 HashMap이나 TreeMap을 사용합니다. 2번, 3번에 해당하는 값들 모두 bitwise XOR 연산을 사용해 각각 O(M)O, O(M^2)에 순회할 수 있습니다. 최종 시간 복잡도는 선택한 자료 구조에 따라
O(N M^2 ) 또는 O(N M^2 * logN) 이 됩니다.한 가지 주의할 점은 각 사람에 대해 O(M2)O(M2)개의 후보들의 등장 횟수를 Map에 저장하는 방식으로 문제를 풀 경우 Map의 원소의 크기가 너무 커져서 시간/메모리초과가 발생하게 됩니다. 따라서 각 단계에서 xx의 등장 횟수만 Map에 누적해야 합니다.]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/s_cpti.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/s_CPTI.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:18:42 GMT</pubDate></item><item><title><![CDATA[s_탑의 높이]]></title><description><![CDATA[초기에
그냥 단순 바로 주변껄 보려고했다. 근데생각해보니 언제 오르막길이나타나는지 구해야할것같다
그래프라고 생각해보자 언제 오르막과 언제 내리막이 나타나는지 구하면된다.
!```python
import sysdef addHeight(tarr,idx,k):
if k&lt;0:
return -1
tarr[idx] += 1
k -= 1
left = idx - 1
right = idx + 1
if left &gt;= 0 and tarr[idx]-tarr[left]&gt;1:
return addHeight(tarr,left,k)
if right &lt; len(tarr) and tarr[idx]-tarr[right]&gt;1:
return addHeight(tarr,right,k)
return kn, k = map(int,sys.stdin.readline().strip().split())arr = list(map(int,sys.stdin.readline().split()))
length = len(arr)result = 0
if length &lt; 2 :
result = arr[0] + k
else:
keyIdx = [0]
pickIdx = [0] if arr[0]-arr[1]&gt;0 else []
l = 0
i = 2
while i&lt;length:
m = i-1
r = i
if arr[m] == arr[r]:
i += 1
else:
ldif = arr[l] -arr[m]
rdif = arr[r]-arr[m]
check = (ldif&gt;0 and rdif&gt; 0) or (ldif&lt;0 and rdif&lt;0)
if check:
# 꼭짓점이다. 기울기의 방향이 바뀌는 구간이다.
keyIdx.append(m)
if ldif&lt;0 and rdif&lt;0: pickIdx.append(m)
l = m
i = m+2
else:
i += 1
if arr[length-1]-arr[keyIdx[-1]]&gt;0 : pickIdx.append(length-1)
keyIdx.append(length-1)
# print(keyIdx,pickIdx)
if len(pickIdx) is 0 :
f = 0
while k&gt;=0:
f += 1
k -= f
result = f+arr[0]-1else: top = arr[pickIdx[0]] # tmpkeyIdx = keyIdx[:] for p in pickIdx: tmpk = k tmparr = arr[:] pTop = tmparr[p] while tmpk &gt;0: tmpk = addHeight(tmparr,p,tmpk) # print('tmpk',tmpk,p,tmparr) if tmpk &gt;= 0 : pTop = tmparr[p] # print('pTop',pTop) if top &lt; pTop: top = pTop result = top
print(result)]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/s_탑의-높이.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/s_탑의 높이.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:18:05 GMT</pubDate></item><item><title><![CDATA[t_개미전사_220]]></title><description><![CDATA[식량창고는 일직선
선택적으로 약탈, 인접한 식량창고가 공격당할시 알 수 있음, 최소한칸떨어저야함
==&gt; 들키지 않고 식량창고를 약탈할때 얻을 수 있는 식량의 최대값의식적으로 해당 알고리즘을 쓴다고 생각하면 쉽게 나오는 것 같다.
한칸뛰고 붙어있는거 두개를 비교해서 큰거를 적용하면된다. 이렇게 두가지 case가 있다는 것만 인식하면 될 것 같다.
문제의 답안과 풀이가 조금 다르지만 개념자체는 비슷하게 가져간것 같고 답도 맞는 것 같다.from collections import deque input = """
4
1 3 1 5
""" input = input.strip().split('\n')
stor = list(map(int,input[1].split()))
leng = len(stor)
for i in range(2,leng): b = i-2 bb = i-3 if bb &lt; 0: stor[i] += stor[b] continue stor[i] += max(stor[b],stor[bb]) print(stor) print(max(stor[leng-1],stor[leng-2])) ]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/t_개미전사_220.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/t_개미전사_220.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:17:45 GMT</pubDate></item><item><title><![CDATA[t_도시분할계획_300]]></title><description><![CDATA[n개의 마을, m개의 길 길양방향가능
길유지비가있음
마을을 분할하고싶음
각분리된마을한의 집들끼리 연결되어있어야함 마을에는 집이하나이상
길도 필요없는 건 없어고 비용을 줄이쉠처음엔문제가 이해가 안됏다 각마을에서 집들끼리는 최소하나의 길이있어야한다는건 이해했지만
연결된 집합들이 원래 두개로 나뉘어지는 것으로 이해했다.
But 항상 한뭉텅이고 내가 길하나를 없애서 두개의 그룹으로 만드는 것같다input = input.strip().split('\n')
n,m = map(int, input[0].split()) edges = [] for i in range(1, m+1): a, b, c = map(int, input[i].split()) edges.append((c,a,b)) edges.sort() parents = []
for i in range(n+1): parents.append(i) def find_parent(parents,v): if parents[v] != v: parents[v] = find_parent(parents,parents[v]) return parents[v] sum = 0
max_r = -1
for e in edges: c,a,b = e pa = find_parent(parents,a) pb = find_parent(parents,b) if pa != pb : sum += c if max_r &lt; c: max_r = c if pa &lt; pb: parents[pb]=pa else: parents[pa]=pb print(sum - max_r)
가장 마지막꺼가 cost가 당연히 젤클꺼기에(sort했잔슴;;)
비교가 필요없다..]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/t_도시분할계획_300.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/t_도시분할계획_300.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:17:36 GMT</pubDate></item><item><title><![CDATA[kt_꿀열매]]></title><description><![CDATA[동욱이는 N×M 격자판 미로를 탈출하려고 합니다. 동욱이는 미로를 상하좌우로 한 칸씩 움직입니다. 이때 벽이 없는 칸으로만 이동할 수 있습니다. 미로에는 꿀열매라는 것이 있습니다.
꿀열매를 먹으면 동욱이가 하루 동안 움직일 수 있는 칸의 수가 1 증가합니다. 꿀열매를 먹지 않은 상태의 동욱이는 하루에 한 칸씩 움직일 수 있습니다. 꿀열매는 여러 번 먹어도 효과가 중첩되지 않습니다. 집이 그리운 동욱이는 최적의 방법으로 미로를 탈출합니다. 동욱이가 미로를 탈출하는 데 며칠이 걸리는지 출력하는 프로그램을 작성해 주세요.]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/kt_꿀열매.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/kt_꿀열매.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:17:31 GMT</pubDate></item><item><title><![CDATA[t_미래도시_259]]></title><description><![CDATA[<a data-href="비용이있는 최단경로" href="600-알고리즘-&amp;-코딩테스트/theory/비용이있는-최단경로.html" class="internal-link" target="_self" rel="noopener nofollow">비용이있는 최단경로</a>n의 회사 도로를 통해 연결되어 있다.
1번회사에 위해 있으며 k번방문 &gt; x 번방문
도로는 정확히 1만큼의 시간으로 이동할 수 있다출발지가 정해져있다. &gt; 다익스트라다
라고 생각했지만 중간에 k &gt; x 로 가는 일이있으니깐 훼이엿다 플로이드 워셜이였다.# 1번회사에 위해 있으며 k번방문 &gt; x 번방문 input = input.strip().split('\n')
x , k = map(int, input.pop().split())
n , m = map(int, input[0].split()) inf = int(1e9)
graph = [[inf]*(n+1) for _ in range(n+1)] for i in range(1, len(input)): a,b = map(int,input[i].split()) graph[a][b] = 1 graph[b][a] = 1 for a in range(1,n+1): for b in range(1,n+1): for k in range(1,n+1): if a == b or b == k or a ==k: graph[b][b] = 0 continue tmp = min(graph[a][b],graph[a][k]+graph[k][b]) graph[a][b] = tmp graph[b][a] = tmp
sum = graph[1][k] + graph[k][x]
print(sum if sum &lt; inf else -1)
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/t_미래도시_259.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/t_미래도시_259.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:17:30 GMT</pubDate></item><item><title><![CDATA[t_바닥공사_223]]></title><description><![CDATA[바닥을 덮개로 채워야한다. 가로 N, 세로 2이다.
덮개는 (1,2) , (2,1) , (2, 2) 의 크기를 가지고 있다.
바닥을 채우는 모든 경우의 수를 구하시오
(2,2) = (1,2) 2 or (2,1) 2틀렸던 생각2,2 로 다 채우고 나머지는 1,2 로 매꾼다
2,2 를 변형할 수 있는 다른 덮개로 바꾸는 경우를 샌다
==&gt; 수학적으로 풀면 풀수 있을 듯하지만… 일단 못풀고 시험당일날 생각하기는 어려움
옳은 답
이미 다채워져 있고 나머지를 채운다는 식으로 접근을 한다
하나남았을땐 1,2 인 직사각형
2개 남았을 땐 1,2인거 두개 2,1인거 두개 2,2인거 하나 넣는 경우의수 3개가 존재한다.
하지만 1,2인가 두개인경우는 하나남았을때를 두번 반복한것과 겹친다.
고로 빼줘야한다.
Therefore , 1 남았을 경우 1개 {(1,2)} , 2개 남았을 경우 2개 {(2,1),(2,2)} 이런식으로 된다.
탑다운 형식
row = int(input.strip()) # a1 = 1 a2 = 3 def search(i): if i == 1 : return 1 if i == 2 : return 3 return search(i-1) + search(i-2)*2 print(search(row)%796796) 보텀업 형식
# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화 n = int(input.strip()) d = [0] * 1001 d[1] = 1 d[2] = 3 for i in range(3, n + 1): d[i] = (d[i - 1] + 2 * d[i - 2]) % 796796 print(d[n])
수가 매우 커지면 탑다운 형식은 메모리 문제가 생기기 쉽다. 재귀는 깊이 제한이 있기 때무네]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/t_바닥공사_223.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/t_바닥공사_223.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:17:23 GMT</pubDate></item><item><title><![CDATA[t_부품찾기_197]]></title><description><![CDATA[
천만계이상이라 이진탐색으로하는게 좋다
계수정렬로도 충분히구현가능하다(시간복잡도는 낮으나 메모리많이소요)
그냥 반복문 쓸꺼면 set을 이용하는편이 낫다.
search함수에서 Return을 안해주는 오류를 범했다.
return 을안해주면 재귀에서의 응답이 최종적으로 도출이안된다.
import sys n = int(sys.stdin.readline().strip())
narr = list(map(int, sys.stdin.readline().strip().split()))
m = int(sys.stdin.readline().strip())
marr = list(map(int, sys.stdin.readline().strip().split())) narr.sort() def search(num,start,end): if start &gt; end: return False mid = (start+end)//2 if narr[mid] == num: return True elif narr[mid] &lt; num : return search(num,mid+1,end) return search(num,start,mid-1) ans = []
for ma in marr: tmp = 'yes' if search(ma,0,n-1) else 'no' ans.append(tmp) print(" ".join(ans))
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/t_부품찾기_197.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/t_부품찾기_197.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:17:18 GMT</pubDate></item><item><title><![CDATA[t_전보_262]]></title><description><![CDATA[N개의 도시
a to b로 전보 보낼라면 a to b통로가 있어야함
각각 통로마다 보내는 시간이 있음
c출발하여 최대한 많이 퍼저 나갈것.각 통로마다 보내는 시간이 없으면 bfs로 해결이 가능할 것이다.
실수한부분
heapq에서는 우선순위로 두고싶은걸 앞에둬야한다!
큐에담겨있으므로 앞에 더 짧은 비용이 온것들이 왔을수 있다. 나의 생각상으로는 인접 노드들 불러오는 for문안에 sum이 더작은가 하는 if문에서 걸러지긴하지만
시간복잡도상으로는 이전에 더 짧은 시간이 온경우에는 continue처리해주는게 좋을것같다. import heapq input = """
3 2 1
1 2 4
1 3 2
""" input = input.strip().split('\n') n,m,s = map(int, input[0].split())
graph = [[] for _ in range(n+1)] for i in range(1,len(input)): x,y,z = map(int, input[i].split()) graph[x].append((y,z)) q = [] inf = 1e9
# 받게되는 도시는 몇개이며 받는데까지 걸리는 시간 times = [inf] * (n+1) heapq.heappush(q,(0,s))
times[s] = 0
while q: node,cost = heapq.heappop(q) if times[node] &lt;cost: # 더 짧은 놈이 방문한경우가 있음. continue for n1,c1 in graph[node]: sum = cost + c1 if times[n1]&gt; sum: times[n1] = sum heapq.heappush(q,(sum , n1)) cnt = 0
max_v = 0 for t in times: if t&lt;inf: cnt += 1 if max_v&lt;t: max_v = t print(cnt,max_v)
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/t_전보_262.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/t_전보_262.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:16:50 GMT</pubDate></item><item><title><![CDATA[t_커리큘럼_303]]></title><description><![CDATA[강의 1부터 n까지. 도잇에 여러강의 들을 수 있고 일부는 선수강의가 있다.
n개 강의에 대하여 수강하기까지 걸리는 최소의 시간을 각각출력from collections import deque input = input.strip().split('\n')
n = int(input[0])
times = [0]*(n+1)
q = []
# 진입차수가 0이다. = 강의를 들어도된다.
front = [[] for _ in range(n+1)]
for i in range(1,n+1): t,*arr,z = list(map(int,input[i].split())) times[i] = t front[i]= arr if len(arr) == 0 : q.append(i) while q: nq = [] syn = [[] for _ in range(n+1)] # q는 진입차수 0인거 for i in q: for j in range(1,n+1): leng = len(front[j]) if leng != 0 and i in front[j]: # 들은과목 들어야하는 과목에서빼준다.. syn[j].append(times[i]) if leng == 1: nq.append(j) times[j] += max(syn[j]) front[j].remove(i) q = nq for i in range(1,n+1): print(times[i])
나는 while문에서 진입차수가 0인 즉 동시에 실행할 수있는 과목중에서
특정 과목의 선수과목중에 윗줄에서 말한 과목이 있으면 리스트에 저장했다가
해당과목을 들어야할때 즉 진입차수가 0일때 동시에 들어야할 과목중에 max를 선택하는식으로 짯다.책에서는
times를 deepcopy하여
deepcopy를 하기 위해서는 import copy copy.deepcopy(list)를 이용하여 할 수 있다.result[i] = max(result[i], result[now] + time[i])
이런식으로 해도됨.]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/t_커리큘럼_303.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/t_커리큘럼_303.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:16:42 GMT</pubDate></item><item><title><![CDATA[t_효율적인화폐구성_228]]></title><description><![CDATA[화폐를 최소한으로 사용해서 합을 M이 되도록함
만약 만들 수 없으면 -1, 몇번쓰는지 print이전에 말했드시 좀더 작은 값이 큰값의 배수가 아니므로 그리디로 풀 수 없다.input = input.strip().split('\n') n,m = map(int,input[0].split())
arr = []
ans = -1
for i in range(1,len(input)): v = int(input[i]) if v == m: ans = 1 arr.append(v) q = deque(list(map(lambda x:[x,1],arr)))
while len(q) &gt; 0 and ans == -1: v, step = q.popleft() for a in arr: tmp = v + a if tmp == m: ans = step+1 break elif tmp &lt; m: q.append([tmp,step+1]) print(ans)
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/t_효율적인화폐구성_228.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/t_효율적인화폐구성_228.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:16:29 GMT</pubDate></item><item><title><![CDATA[c_NumberSolitaire]]></title><description><![CDATA[N 배열
정수구성 표시가능
자갈을 N-1로 옮겻을때 표시된 정수의 합
주사위 던짐 if 현재 + 주사위 == 배열인덱스, 이동&amp;표시
else 암것도하지않음
보드에서 얻을수 있는 최대를반환3가지 조건
전꺼랑 현재꺼랑둘다 표시
현재꺼만표시
전꺼만표시function solution(A) { let result = A[0] + A[A.length-1] if(A.length&lt;=2){ return result } let term = 0; for(let i = 2 ; i&lt;A.length-1; i++){ if(A[i]&gt;A[i-1] &amp;&amp; A[i]&gt;A[i]+A[i-1]){ term++; if(term&lt;=6){ A[i] = A[i]; continue; } } term = 0 A[i] = Math.max(A[i-1],A[i]+A[i-1]) } return A.length&lt;7? Math.max(result,result+A[A.length-2]):result+A[A.length-2]
}
특정인덱스의 정답값은 이전 6개의 인덱스의 정답값 + 현재인덱스 값을 더하것임.(마지막은항상방문에해야하기에)function solution(A) { for(let i = 1; i&lt;A.length; i++){ let sStart = i-6; if(sStart&lt;0) sStart=0; let tmpSl= A.slice(sStart,i) // tmpSl 1일때 0부분만있기에 // 이후에 무조건 0을포함하게되어있음 A[i] = Math.max(...tmpSl) + A[i] } return A[A.length-1]
}
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/c_numbersolitaire.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/c_NumberSolitaire.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:16:14 GMT</pubDate></item><item><title><![CDATA[b_RGB거리]]></title><description><![CDATA[ 좌우와 색이 같아서는 안된다.
입력 빨초파로칠햇을때 비용이 각나옴
브루드 포스
dp 좌우3방향 컨트롤해야할듯?
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://hongcoding.tistory.com/123" target="_self">https://hongcoding.tistory.com/123</a>
사람들은천재다...
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/b_rgb거리.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/b_RGB거리.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:16:11 GMT</pubDate></item><item><title><![CDATA[c_MaxNonoverlappingSegments]]></title><description><![CDATA[선분 N개가 한줄에 위치
이미 end 가 앞인순으로 나열되어있음
A : 시작 ,B: 끝 ,끝점을 기준으로 정렬
겹치는 경우 겹치지 않는경우
A[I] ≤ A[J] ≤ B[I] 또는 A[J] ≤ A[I] ≤ B[J]
최대로 겹치지않는 세트를 구한다.각 선들마다 겹치는 선을구한다음에
겹치는선이 적은순으로 정렬해서 선택한다.
퍼포 엄청구리고 답도틀림. 내생각에는 sort시에 length뿐만아니라 index순의 조건을 추가해야한다고생각한다function solution(A, B) { let line = [] let end = [] for(let i =0;i&lt;A.length;i++){ line.push([i]) end.push(B[i]) let toggle = false for(let j =0;j&lt;i;j++){ if(!toggle &amp;&amp; end[j]&gt;=A[i]) toggle= true; if(toggle){ line[j].push(i); line[i].push(j); } } } line.sort((a,b)=&gt;a.length-b.length) let used = new Set([...line[0]]); let ans = 1; for(let i =1;i&lt;A.length;i++){ if(!used.has(line[i][0])){ ans++; used = new Set([...used,...line[i]]) } } return ans
}
걍끝점이랑 시작점이랑 겹치지않는수를 count하면된다.function solution(A, B) { const N = A.length; let res = 1; if (N &lt;= 1) { return N; } let start = 0; for (let i = 1; i &lt; N; i++) { if (B[start] &lt; A[i]) { res++; start = i; } } return res;
}
시작점기준으로정렬을 안해도된다! ex
1-3
4-5 끝점 3 &gt; 5
2-5 안됨1-3
2-5 끝점 겹침 적용ㄴㄴ 3
4-5 끝점 3 &gt; 5]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/c_maxnonoverlappingsegments.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/c_MaxNonoverlappingSegments.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:15:14 GMT</pubDate></item><item><title><![CDATA[b_평범한배낭_12865]]></title><description><![CDATA[최대 k무게 넣을수 있을때 최대로 가치있게 즐기고픔입력
믈픔수, 최대무게
무게 , 가치하나씩 넣는다고하고 생각하면된다..
이제생각할때 물건하나씩 넣는다고생각한다
그리고 이전에 넣은물건이 있는지 무게가 가장큰 dp부터확인을 쭉하고
물건에 넣은 무게가 있으면 거기에다가 현재넣을 물건을 비교해서 최대값을 해당무게가 가진다.
여기서 젤 중요했던것이 무게가 가장 큰 dp부터확인한다이다.
적은 dp부터확인하면 이미더한값에서 또더해서 개수를 중복되게 더해진다.O(n * k)import sys # n:물건, k : limit무게
n, k = map(int,sys.stdin.readline().strip().split())
weight = [] worth = [] # 가치
bag =[0] * (k+1) # 물건개수만큼 for문 == 물건을하나씩넣어봣을때의 가치를잼
for _ in range(n): w, v=map(int,sys.stdin.readline().strip().split()) if w &lt; k+1: for i in range(k+1,0,-1): 는무게 if i+w&lt;=k and bag[i] != 0: tmpw = i + w if tmpw &lt;k+1: bag[tmpw] = max(bag[tmpw],bag[i]+v) bag[w] = max(bag[w],v) # 처음이면 무적건v갯죵 # print(w,bag) print(max(bag)) <img src="600-알고리즘-&amp;-코딩테스트/problem/assets/b_평범한배낭_12865-20240906191158114.png" target="_self">]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/b_평범한배낭_12865.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/b_평범한배낭_12865.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:13:47 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[b_집합_11723]]></title><description><![CDATA[내답
집합으로 단순구현하였는데 틀렷다.import sys input = sys.stdin.readline
N = int(input().strip())
arr = set([])
output = ""
for _ in range(N): data=input().strip() if data == "all": arr = set( [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"]) elif data == "empty": arr.clear() else: op,num = data.split() if op == "add": arr.add(num) elif op == "check": output += ("1\n" if num in arr else "0\n") elif op == "remove": if num in arr: arr.remove(num) elif op == "toggle": if num in arr: arr.remove(num) else: arr.add(num) print(output) print합쳐서해서메모리초과난듯용;;import sys input = sys.stdin.readline
N = int(input().strip())
s = 0b0
output = ""
for _ in range(N): data=input().strip() # print("s",bin(s)) if data == "all": s = 0b111111111111111111111 elif data == "empty": s = 0b0 else: op,num = data.split() num = int(num) if op == "add": s = s | (0b1&lt;&lt;num) elif op == "check": if s &amp; (0b1&lt;&lt;num): print(1) else: print(0) elif op == "remove": s= s &amp; ~(0b1&lt;&lt;num) elif op == "toggle": s = s ^ (0b1&lt;&lt;num)
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/b_집합_11723.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/b_집합_11723.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:13:40 GMT</pubDate></item><item><title><![CDATA[b_주유소_13305]]></title><description><![CDATA[N개 도시
도시마다 리터당 가격이다름
왼 to 오쉬움import sys
import math
sys.stdin.readline()
v =list(map(int,sys.stdin.readline().strip().split()))
n =list(map(int,sys.stdin.readline().strip().split())) small = math.inf
total = 0
for i in range(len(n)): small = min(small,n[i]) if i &gt;= len(v): continue total += (small * v[i]) print(total)
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/b_주유소_13305.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/b_주유소_13305.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:13:36 GMT</pubDate></item><item><title><![CDATA[b_읽어버린괄호_1541]]></title><description><![CDATA[dp로해야한다고생각햇다. 그것도 아마 될것은 같지만..
+인걸 먼저import sys
S = sys.stdin.readline().strip().split('-') # - 기준으로 괄호를 치면 최소로 만들 수 있음
temp = []
for i in S: # 각 요소에 대해 cnt = 0 for j in i.split('+'): # +로 짼 요소들을 cnt += int(j) # 더하고 temp.append(cnt) # 모아주자
# 모아준 temp들을 맨 앞 인덱스 제외하고 전부 빼면 최소값
result = temp[0]
for i in temp[1:]: result -= i
print(result)
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/b_읽어버린괄호_1541.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/b_읽어버린괄호_1541.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:13:30 GMT</pubDate></item><item><title><![CDATA[b_우주신과의교감_1774]]></title><description><![CDATA[우주신과 황선자씨랑교신해야함(바로 교신할필요없음)
일부 우주신은 이미황선자씨와 교신할수있음
짧은 통로를 좋아함
우주신 개수 N,이미연결된 통로 Mimport sys
input = sys.stdin.readline
n,m= map(int,input().strip().split())
parents = [i for i in range(n+1)]
nodes = [] # 번호, y, x
edges = [] # 비용, 번호1, 번호2 def find_parent(n): if parents[n] !=n: parents[n] = find_parent(parents[n]) return parents[n] for i in range(n): y,x = map(int,input().strip().split()) nodes.append((i+1,y,x)) def union_p(n1,n2): np1 = find_parent(n1) np2 = find_parent(n2) if np1 != np2: if np1&lt;np2: parents[np2] = np1 else: parents[np1] = np2 return True return False for i in range(m): n1,n2 = map(int,input().strip().split()) union_p(n1,n2) for i in range(n): n1 = nodes[i] for j in range(i+1,n): n2 = nodes[j] cost=((n1[1]-n2[1])**2 + (n1[2]-n2[2])**2) ** 0.5 edges.append((round(cost,2),n1[0],n2[0])) edges.sort()
anw = 0
for e in edges: c,n1,n2 = e if union_p(n1,n2): anw +=c print(format(anw, ".2f"))
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/b_우주신과의교감_1774.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/b_우주신과의교감_1774.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:13:26 GMT</pubDate></item><item><title><![CDATA[b_오목_2615]]></title><description><![CDATA[오목 (5개만 ㅇㅈ해드림)
ㅇㅈ되는 오목중 왼쪽 &gt; 같으면 위 에있는 인덱스 뽑아내샘
둘이 동시에 이기는 경우는 없음
방향을 사방으로가는게 아니라 방향중 첫스타트가 왼쪽이 되는걸 먼저 돌려야함
이후에 확인할때 방문햇음으로 확인하면 겹치는게 문제생길 수 있으므로 가려는 방향과 음수인 반대값에 이미 같은값이있으면 방문햇음으로 판단하면 됨
import sys
import math
import heapq farr = []
input =list( map(int,sys.stdin.readline().strip().split()))
xlen = len(input)
while input: farr.append(input) input = list(map(int,sys.stdin.readline().strip().split()))
# for fa in farr:
# print(fa) ylen = len(farr)
# print(xlen,ylen) def isInArr(y,x): if y &gt;=0 and ylen&gt;y and x&gt;=0 and xlen&gt;x: return True return False def dfs(tarr,dy,dx,y,x,depth): if depth&gt;=6 : return 6 ty = y + dy tx = x + dx # print(ty,tx,depth) if isInArr(ty,tx): if tarr[y][x]!= tarr[ty][tx]: return depth return dfs(tarr,dy,dx,ty,tx,depth+1) return depth
# 한방향으로 가니까 중복될 리가 없음용
def visiting(): moves = [[1,0],[1,1],[0,1],[-1,1]] # 대칭인건 지워도됨 for i in range(ylen): for j in range(xlen): if farr[i][j] !=0: for my,mx in moves: # print("dfs",i,j,my,mx,'---') cv = farr[i][j] dv = farr[i-my][j-mx] if isInArr(i-my,j-mx) else -1 # 반대방향에 이미같은게 있으면 계산된거 if cv != dv: d=dfs(farr,my,mx,i,j,1) # print("dfs end",d) if d == 5: return f"{farr[i][j]}\n{i+1} {j+1}" return 0
result = visiting()
print(result)
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/b_오목_2615.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/b_오목_2615.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:13:19 GMT</pubDate></item><item><title><![CDATA[b_예산_2512]]></title><description><![CDATA[if 모든요청이 다 ㄱㅊ &gt; 모두다 요청한대로
else 특정한 정수상한액 설정 그이상이면 상한액 이하면 요청한대로입력
지방수
요청수들
총예슨이진탐색냄새가 솔솔난다.먼가 딱 맞지않으면 이진탐색이다.(내생각에) 역시 맞음ㅋimport sys
sys.stdin.readline()
cities = list(map(int,sys.stdin.readline().strip().split()))
budget = int(sys.stdin.readline().strip())
cities.sort(reverse=True) def set_limit(start,end): if start &gt; end: return end # 정렬된 mid = (start+end)//2 b_sum = 0 for b in cities: if b&gt;mid: b_sum+=mid else: b_sum+=b if b_sum == budget: return mid elif b_sum &gt; budget: # 소요되는 금액이 예산보다많음 return set_limit(start,mid-1) else: return set_limit(mid+1,end) requires = sum(cities)
if budget &gt;= requires: print(cities[0])
else: ans = set_limit(0,cities[0]) # 상한선 필요 print(ans)
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/b_예산_2512.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/b_예산_2512.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:13:02 GMT</pubDate></item><item><title><![CDATA[b_연산자 끼워넣기_14888]]></title><description><![CDATA[입력
수개수
수 배열
덧셈 뺄셈 곱셈 나눗샘 개수전형적인 백트래킹문제다.import sys
import math k = int(sys.stdin.readline().strip())
arr = list(map(int,sys.stdin.readline().strip().split()))
oper= list(map(int,sys.stdin.readline().strip().split()))
max_v = -math.inf
min_v = math.inf # 1, 첫숫자로시작
def solve(step,sum_v,oper): global max_v global min_v # print(step,sum_v,oper,max_v,min_v) if step &gt;= len(arr): # print("탈출",sum_v) if max_v&lt; sum_v: max_v = int(sum_v) if min_v &gt; sum_v: min_v = int(sum_v) # print(max_v,min_v) return for i in range(len(oper)): if oper[i] &lt;= 0 : continue oper[i] -=1 if i == 0 : solve(step+1,sum_v+arr[step],oper) elif i == 1: solve(step+1,sum_v-arr[step],oper) elif i == 2: solve(step+1,sum_v*arr[step],oper) elif i == 3: tmp = 0 if sum_v &lt; 0: tmp = -((-sum_v)//arr[step]) else: tmp = (sum_v)//arr[step] solve(step+1,tmp,oper) oper[i] +=1 solve(1,arr[0],oper)
print(max_v)
print(min_v)
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/b_연산자-끼워넣기_14888.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/b_연산자 끼워넣기_14888.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:12:59 GMT</pubDate></item><item><title><![CDATA[b_에디터_1406]]></title><description><![CDATA[커서 앞 뒤 중간. n+1 공간에 위치해있음
L : 커서 왼쪽으로
D : 커서 오른쪽으로
B : 커서 왼쪽에 있는 문자를 삭제
P: $문자를 왼쪽에 추가
초기에 커서는 맨앞에시간초과 에러가 떳다..
걍 배열을 두고 중간에 값을 insert하고 삭제하는 식으로 구현을 했다. &lt;&lt; 둘다 시간 복잡도 O(n)이 걸린다.커서기준으로 left right queue로 나눠야함.beforeimport sys words = list(sys.stdin.readline().strip())
# 기본적으로 문자의 index와 커서가 같으면
# 해당 문자 앞에있는 것. 마지막커서는 문자의 길이임
words_len = len(words)
now_cur = words_len
def editor(arr,com): global now_cur if com[0] == 'L': if now_cur &gt; 0: now_cur -= 1 elif com[0] == 'D': if now_cur &lt; words_len: now_cur += 1 elif com[0] == 'B': if now_cur &gt; 0: del arr[now_cur-1:now_cur] now_cur -= 1 else: _ , v=com.split() arr[now_cur:now_cur] = [v] now_cur += 1 k = int(sys.stdin.readline().strip())
input = []
for _ in range(k): input.append(sys.stdin.readline().strip()) for i in input: editor(words,i) print("".join(words)) correct answerimport sys
from collections import deque
words = list(sys.stdin.readline().strip())
left = deque(words)
right = deque([])
# 기본적으로 문자의 index와 커서가 같으면
# 해당 문자 앞에있는 것. 마지막커서는 문자의 길이임 def editor(com): global now_cur if com[0] == 'L': if left: right.appendleft(left.pop()) elif com[0] == 'D': if right: left.append(right.popleft()) elif com[0] == 'B': if left: left.pop() else: _ , v=com.split() left.append(v) k = int(sys.stdin.readline().strip())
input = []
for _ in range(k): input.append(sys.stdin.readline().strip()) for i in input: editor(i) print("".join(left+right)) ]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/b_에디터_1406.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/b_에디터_1406.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:12:57 GMT</pubDate></item><item><title><![CDATA[b_쉬운 최단거리_14940]]></title><description><![CDATA[import sys
from collections import deque
N,M = map(int,input().strip().split())
arr = []
destination = []
for i in range(N): line = list(map(int,input().strip().split())) try: x=line.index(2) destination = [i,x] line[x] = 0 except: pass arr.append(line) def checkCanMove(y,x): if y&lt;0 or x&lt;0: return False if y&gt;= len(arr) or x&gt;=len(arr[0]): return False if arr[y][x]&lt;1: return False return True que = deque([destination])
# print(que)
move = [[0,1],[0,-1],[1,0],[-1,0]]
while que: y,x = que.popleft() val = arr[y][x] # print(y,x,val) for m in move: ny = y + m[0] nx = x + m[1] if checkCanMove(ny,nx): arr[ny][nx] = val-1 que.append([ny,nx]) for line in arr: output = "" for l in line: if l &lt; 0: l = -l elif l &gt; 0: l = -1 output += str(l)+' ' print(output) ]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/b_쉬운-최단거리_14940.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/b_쉬운 최단거리_14940.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:12:50 GMT</pubDate></item><item><title><![CDATA[b_수레움직이기_250134]]></title><description><![CDATA[따라갈때문제가생김 무적건빨간색 먼저 움직이는 로직임."""
n*m크기
시작&gt;도착
각턴마다 상하좌우중인접한 한칸으로 움직여야함
방문햇던곳갈수없음
도착시 고정
수레끼리 자라바꿀수없음(부딪히면안됨)
dfs같은데용?
"""
import math
import traceback def solution(maze): answer = [math.inf,len(maze)*len(maze[0])]# 빈칸 0 / 방문 빨,파 1,2/ def goBox(red_pos,blu_pos,red_dep,blu_dep,red_fin,blu_fin): # print(red_pos,blu_pos,red_dep,blu_dep,red_fin,blu_fin) turn = max(red_dep,blu_dep) red_clear = red_pos[0] == red_fin[0] and red_pos[1] == red_fin[1] blu_clear = blu_pos[0] == blu_fin[0] and blu_pos[1] == blu_fin[1] if turn&gt;answer[1]: return if red_clear and blu_clear: # print("도착!",red_pos,blu_pos,turn) if turn &lt; answer[0]: answer[0] = turn return moves = [[0,1],[0,-1],[1,0],[-1,0]] for m in moves: if (red_dep&lt;=blu_dep or blu_clear) and not red_clear: tmp=ava_move(maze,red_pos,m,True) # 이동콛 if tmp: # red가움직임... bef,ny,nx = tmp if not (ny == blu_pos[0] and nx == blu_pos[1]): maze[ny][nx] = [1,bef[1]] # 이동처리 goBox([ny,nx],blu_pos,red_dep+1,blu_dep,red_fin,blu_fin) maze[ny][nx]= bef # 움직임 복귀 if (red_dep&gt;blu_dep or red_clear) and not blu_clear: tmp=ava_move(maze,blu_pos,m,False) if tmp: # blu가움직임... bef,ny,nx = tmp if not (ny == red_pos[0] and nx == red_pos[1]): maze[ny][nx] = [bef[0],1] # 이동처리 goBox(red_pos,[ny,nx],red_dep,blu_dep+1,red_fin,blu_fin) maze[ny][nx]= bef # 움직임 복귀 return red_pos,blu_pos = False,False red_fin,blu_fin = False,False for i in range(len(maze)): for j in range(len(maze[0])): if maze[i][j] != 5: if maze[i][j] == 1: maze[i][j] = [1,0] red_pos = [i,j] elif maze[i][j] == 2: maze[i][j] = [0,1] blu_pos = [i,j] else: if maze[i][j] == 3: red_fin = [i,j] elif maze[i][j] == 4: blu_fin = [i,j] maze[i][j] = [0,0] # print(red_pos,blu_pos) goBox(red_pos,blu_pos,0,0,red_fin,blu_fin); return 0 if math.inf==answer[0] else answer[0] def ava_move(maze,pos,move,isRed): y,x=pos dy,dx=move ny = y + dy nx = x + dx if ny&lt;0 or nx &lt;0 or ny&gt;len(maze)-1 or nx&gt;len(maze[0])-1: # 범위안에도 없음 return False val = maze[ny][nx] if val == 5 or (isRed and val[0] == 1) or (not isRed and val[1] == 1): return False # 움직일 순잇음용 if isRed: return [val,ny,nx] else: return [val,ny,nx] # 가능하움직임 벽 ㄴㄴ 격자 ㄴㄴ 방문한곳 ㄴㄴ
둘다먼저 움직일 수있음 but
계산횟수가 많아짐 예를들어
2&gt;3턴넘어갈때 """
n*m크기
시작&gt;도착
각턴마다 상하좌우중인접한 한칸으로 움직여야함
방문햇던곳갈수없음
도착시 고정
수레끼리 자라바꿀수없음(부딪히면안됨)
dfs같은데용?
"""
import math
import traceback def solution(maze): answer = [math.inf,len(maze)*len(maze[0])]# 빈칸 0 / 방문 빨,파 1,2/ def goBox(red_pos,blu_pos,red_dep,blu_dep,red_fin,blu_fin): print(red_pos,blu_pos,red_dep,blu_dep,red_fin,blu_fin) turn = max(red_dep,blu_dep) red_clear = red_pos[0] == red_fin[0] and red_pos[1] == red_fin[1] blu_clear = blu_pos[0] == blu_fin[0] and blu_pos[1] == blu_fin[1] if turn&gt;answer[1] or turn&gt;=answer[0]: return if red_clear and blu_clear: print("도착!",red_pos,blu_pos,turn) if turn &lt; answer[0]: answer[0] = turn return moves = [[0,1],[0,-1],[1,0],[-1,0]] for m in moves: if ((blu_dep-red_dep&gt;=0 and blu_dep-red_dep&lt;2) or blu_clear) and not red_clear: tmp=ava_move(maze,red_pos,m,True) # 이동콛 if tmp: # red가움직임... bef,ny,nx = tmp if not (ny == blu_pos[0] and nx == blu_pos[1]): maze[ny][nx] = [1,bef[1]] # 이동처리 goBox([ny,nx],blu_pos,red_dep+1,blu_dep,red_fin,blu_fin) maze[ny][nx]= bef # 움직임 복귀 if ((red_dep-blu_dep&gt;=0 and red_dep-blu_dep&lt;2) or red_clear) and not blu_clear: tmp=ava_move(maze,blu_pos,m,False) if tmp: # blu가움직임... bef,ny,nx = tmp if not (ny == red_pos[0] and nx == red_pos[1]): maze[ny][nx] = [bef[0],1] # 이동처리 goBox(red_pos,[ny,nx],red_dep,blu_dep+1,red_fin,blu_fin) maze[ny][nx]= bef # 움직임 복귀 return red_pos,blu_pos = False,False red_fin,blu_fin = False,False for i in range(len(maze)): for j in range(len(maze[0])): if maze[i][j] != 5: if maze[i][j] == 1: maze[i][j] = [1,0] red_pos = [i,j] elif maze[i][j] == 2: maze[i][j] = [0,1] blu_pos = [i,j] else: if maze[i][j] == 3: red_fin = [i,j] elif maze[i][j] == 4: blu_fin = [i,j] maze[i][j] = [0,0] # print(red_pos,blu_pos) goBox(red_pos,blu_pos,0,0,red_fin,blu_fin); return 0 if math.inf==answer[0] else answer[0] def ava_move(maze,pos,move,isRed): y,x=pos dy,dx=move ny = y + dy nx = x + dx if ny&lt;0 or nx &lt;0 or ny&gt;len(maze)-1 or nx&gt;len(maze[0])-1: # 범위안에도 없음 return False val = maze[ny][nx] if val == 5 or (isRed and val[0] == 1) or (not isRed and val[1] == 1): return False # 움직일 순잇음용 if isRed: return [val,ny,nx] else: return [val,ny,nx] # 가능하움직임 벽 ㄴㄴ 격자 ㄴㄴ 방문한곳 ㄴㄴ ]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/b_수레움직이기_250134.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/b_수레움직이기_250134.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:12:46 GMT</pubDate></item><item><title><![CDATA[b_비슷한단어_2607]]></title><description><![CDATA[구성이 같다 : 두단어가 같은 문자 ,각문자마다 개수도같음
비슷하다 : 한문자를 더하거나 빼거나 하나를 다른문자하나로 바꾼경우.집합으로 하면 될 것같다 응안대 각 글자별로 개수 새야해서 딕셔너리로 했음
길이의 개수가 작은경우에대한 조건이 부족햇음
길이가 작은경우 무조건 하나의 문자를 추가해야하기에
기존 문자에서 다 해결을 봐야함.import sys n = int(sys.stdin.readline().strip())
sta_l = 0
stand = {}
ans = 0
for i in range(n): tmp = sys.stdin.readline().strip() if i == 0: for t in tmp: if t in stand: stand[t] +=1 else: stand[t] =1 sta_l = len(tmp) # print("stand",stand,sta_l) else: t_stand = stand.copy() wrong = 0 dif = sta_l - len(tmp) if dif &lt;2 and dif&gt;-2: for t in tmp: if t in t_stand and t_stand[t] &gt;0: t_stand[t]-=1 else: if dif == 1: wrong+=1 wrong+=1 if wrong&gt;1: break if wrong&lt;2: # print("비슷",tmp) ans +=1
print(ans) ]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/b_비슷한단어_2607.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/b_비슷한단어_2607.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:12:15 GMT</pubDate></item><item><title><![CDATA[b_비밀번호발음하기_4659]]></title><description><![CDATA[발음 가능한 패스워드를 만들어야함
aeiou 포함시켜야함
모음 자음 3개연속오면안됨
같은글자 연속 불가 but ee oo허용
import sys moem = ['a','e','i','o','u']
def check(value): # 연속된 케이스 채크 mtime = 0 jtime = 0 before = "" toggle = False for v in value: if before == v and before != 'e' and before != 'o': return False if v in moem: mtime +=1 jtime = 0 toggle = True else: jtime +=1 mtime = 0 if mtime&gt;2 or jtime &gt;2 : return False before = v if toggle: return True return False
input = ""
ans = ""
while input != 'end': input = sys.stdin.readline().strip() if input =='end': break if check(input): ans += f"&lt;{input}&gt; is acceptable.\n" else: ans += f"&lt;{input}&gt; is not acceptable.\n" print(ans.strip())
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/b_비밀번호발음하기_4659.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/b_비밀번호발음하기_4659.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:12:09 GMT</pubDate></item><item><title><![CDATA[b_돌게임_9655]]></title><description><![CDATA[둘이서 즐기는게임~
돌 n개, 1개 or 3개 가져갈 수 있음.
마지막 돌가져가면 이김둘이한번에 돌을가지고갈 수 있는 2, 4, 6
이다
이건 베스킨라빈스 게임이랑 비슷하다.
두번째 사람이 의도적으로 4를 맞출 수 있다.
나머지가 1,3이면 먼저한사람이 이기고 나머지가 0,2면 다른사람이 이긴다.import sys n = int(sys.stdin.readline().strip())
m = n%4
if m == 1 or m ==3: print('SK')
else: print('CY')
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/b_돌게임_9655.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/b_돌게임_9655.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:11:57 GMT</pubDate></item><item><title><![CDATA[b_공유기설치_2110]]></title><description><![CDATA[집 N개
집 같은 좌표 ㄴㄴ
공유기 C개 설치하려고함
최대한 많은곳에서 와이파이 사용하려고함
가장인접한 공유기 사이의 거리를 가장크게하려고함dp라고생각했다. 응아니얌
어디에 공유기 둘것인지 지정하지말고
공유기 사이를 거리를 지정해야한다start = 1 # 공유기 거리 최소
end = arr[-1] - arr[0] # 공유기 거리 최대
result = 0 # 재귀로 적절한 두 공유기 사이의 거리를 찾는다
while (start &lt;= end): mid = (start + end) // 2 # 현재 공유기 거리 current = arr[0] count = 1 # 공유기 설치 몇 대 할 수 있는지 체크 for i in range(1, len(arr)): if arr[i] &gt;= current + mid: count += 1 current = arr[i] # 공유기 설치 수가 목표 보다 크면 공유기 사이 거리 늘림 if count &gt;= C: start = mid + 1 result = mid # 공유기 설치 수가 목표 보다 작으면 공유기 사이 거리 줄임 else: end = mid - 1 print(result)
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/b_공유기설치_2110.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/b_공유기설치_2110.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:11:55 GMT</pubDate></item><item><title><![CDATA[b_스위치켜고끄기_1244]]></title><description><![CDATA[스위치 개수
1 ~ 스위치개수 이하 자연수
1 on ,0 off
if 남, 스위치 번호가 받은 수의 배수면 스위치 상태를 바꿈
if 여, 스위치 번호 == 받은수 중심으로 좌우 대칭이면서 가장 많은 스위치를 포함한 구간의 스위치 상태를 바꿈 자기자신도 바꿈걍구현 비트연산자 토글할때 xor 즉 연산자 ^를 쓰면된다는 걸 알았다.import sys
swi_n=int(sys.stdin.readline().strip()) # 스위치 수
switches = list(map(int,sys.stdin.readline().strip().split()))
stu_n = int(sys.stdin.readline().strip()) def change_switches(arr,stu_g,stu_s): if stu_g == 1: # 남자 for i in range(len(arr)): if (i+1)%stu_s == 0: arr[i] ^= 1 else : # 여자 stu_s -= 1 # 이제부턴 인덱스쓸꺼라 ㄱㅊ arr[stu_s] ^= 1 for i in range(1,stu_s+1): left = stu_s - i right = stu_s + i if -1 &lt;left and right&lt;len(arr): if arr[left] == arr[right]: arr[left] ^= 1 arr[right] ^= 1 else: break else: break while stu_n&gt;0: student = list(map(int,sys.stdin.readline().strip().split())) stu_n -= 1 change_switches(switches,student[0],student[1]) ans = ""
start = 0
swit_leng =len(switches)
while start&lt;swit_leng: end = start+20 if end&gt;swit_leng: end = swit_leng ans+=(' '.join(map(str,switches[start:end]))) ans+='\n' start += 20
print(ans)
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/b_스위치켜고끄기_1244.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/b_스위치켜고끄기_1244.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:11:51 GMT</pubDate></item><item><title><![CDATA[p_완전 범죄_389480]]></title><description><![CDATA[흔적누적시 붙잡힘
A가 가장 누적해서 적게 남기는 경우를 골라라1차답
시간초과 - 점수40점def solution(info, n, m): result = [n] hasA = [False] def steal(l_n,l_m,start): # print(l_n,l_m,start) if l_n&lt;=0 or l_m&lt;=0: return if start&gt;= len(info): # print(result) hasA[0] = True # print("&gt;&gt;",l_n,l_m) if result[0] &gt; n - l_n: result[0] = n - l_n return a,b = info[start] steal(l_n-a,l_m,start+1)# 왼쪽꺼 훔침 steal(l_n,l_m-b,start+1) # 오른쪽 꺼 훔침 # print("----") steal(n,m,0) return result[0] if hasA[0] else -1
2차답
5개면
왼왼왼왼왼
오왼왼왼왼
4개의 데이터를
뒤에서부터
(a,b)
dp 2차원 dp일것같긴하다ai답def solution(info, n, m): # DP 테이블 초기화 dp = [[[float('inf')] * (m + 1) for _ in range(n + 1)] for _ in range(len(info) + 1)] dp[0][0][0] = 0 # 기본 케이스: 물건이 없을 때, 흔적도 없음 # 각 물건에 대해 반복 for i in range(1, len(info) + 1): a_trace, b_trace = info[i - 1] for a in range(n + 1): for b in range(m + 1): # A가 물건을 훔치는 경우 if a &gt;= a_trace: dp[i][a][b] = min(dp[i][a][b], dp[i-1][a-a_trace][b] + a_trace) # B가 물건을 훔치는 경우 if b &gt;= b_trace: dp[i][a][b] = min(dp[i][a][b], dp[i-1][a][b-b_trace]) # A의 최소 흔적 개수 찾기 min_a_traces = min(dp[len(info)][a][b] for a in range(n) for b in range(m)) print(dp) return min_a_traces if min_a_traces != float('inf') else -1 다른사람 풀이답def solution(info, n, m): INF = 100000 size = len(info) dp = [[INF] * m for _ in range(size + 1)] dp[0][0] = 0 for i in range(1, size + 1): a, b = info[i-1] for j in range(m): # A 선택 dp[i][j] = min(dp[i][j], dp[i-1][j] + a) # B 선택 if j + b &lt; m: dp[i][j + b] = min(dp[i][j + b], dp[i-1][j]) min_value = min(dp[size]) return -1 if min_value &gt;= n else min_value ]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/p_완전-범죄_389480.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/p_완전 범죄_389480.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:11:32 GMT</pubDate></item><item><title><![CDATA[t_거스름돈_87]]></title><description><![CDATA[동전 500,100,50,10일때 거슬러줘야할 동전의 최소 개수큰화패단위부터 greedy하게 돌려줌.
큰단위가 작은 단위의 배수이다. 500은 100의 배수 100은 50의 배수 ...등
이 조건이 어긋나면 그리디하면안됨
ex) 500 400 100이면 500은 400의 배수가 아니기에 greedy를 쓰면 답이틀림 800일경우 greedy -&gt; 500,100,100,100
정답 -&gt; 400,400 ]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/t_거스름돈_87.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/t_거스름돈_87.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:09:12 GMT</pubDate></item><item><title><![CDATA[t_큰수의법칙_92]]></title><description><![CDATA[배열이 있을때 합이 가장 클 때의 결과를 출력
입력 : N M K
M: M번 더 할 수 있음
K : K번 연속으로 수를 사용할 수 있음 import sys k,n,m = map(int, sys.stdin.readline().split())
arr = list(map(int, sys.stdin.readline().split())) arr.sort(reverse=True) sum = 0
flag = True while n &gt; 0: if flag: if n&lt;m: m=n sum += arr[0]*m n -= m flag=False else: sum += arr[1] n -= 1 flag= True print(sum)
걍 눈속임을 준문제 사실상 0과 1 번째 밖에 안 필요함.
예외 없음. 길이가 2이상이고 연속해서 사용하는횟수가 제한된거지]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/t_큰수의법칙_92.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/t_큰수의법칙_92.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:09:12 GMT</pubDate></item><item><title><![CDATA[s_나무공격]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://softeer.ai/practice/9657" target="_self">https://softeer.ai/practice/9657</a>import sys n,m = map(int,sys.stdin.readline().strip().split())
arr = []
allN = 0
for _ in range(n): tmp = sys.stdin.readline().strip().split().count('1') arr.append(tmp) allN += tmp
for _ in range(2): s,e = map(int,sys.stdin.readline().strip().split()) for i in range(s-1,e): if arr[i] &gt; 0: arr[i] -= 1 allN -= 1 print(allN)
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/s_나무공격.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/s_나무공격.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:09:12 GMT</pubDate></item><item><title><![CDATA[t_1로만들기_217]]></title><description><![CDATA[4가지 연산이 주어 졌을때 연산을 최소화해서 1을 만들고자함
연산횟수 구하세용이게 다이나믹프로그래밍로 풀어라는 방법이 안주어졌다면 햇갈렷을 것 같다. 그리디로 하면 틀린다.
ans이라는 이전 계산 스탭들을 저장하는 배열을 만들어서 활용했다.from collections import deque n = int(input.strip()) arr = deque([n])
ans = [-1] * (n+1)
ans[n] = 0 def cal(v, step): if v % 5 == 0: arr.append(v//5) ans[v//5]=step+1 if v % 3 == 0: arr.append(v//3) ans[v//3]=step+1 if v % 2 == 0: arr.append(v//2) ans[v//2]=step+1 arr.append(v-1) ans[v-1]=step+1 while ans[1] &lt; 0 and len(arr)&gt;0: tmp = arr.popleft() cal(tmp,ans[tmp]) print(ans[1])
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/t_1로만들기_217.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/t_1로만들기_217.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:09:12 GMT</pubDate></item><item><title><![CDATA[kt_누적합]]></title><description><![CDATA[import java.io.*;
import java.util.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine().strip()); List&lt;String&gt; arr = new ArrayList&lt;&gt;(Arrays.asList(br.readLine().strip().split(" "))); int padN = 2; if(n&gt;1){ while(padN&lt;n){ padN = padN * 2; } padN -= n; for(int i =0;i&lt;padN;i++){ arr.add("0"); } } // System.out.println(arr); String output = ""; do{ output = String.join(" ",arr) +" \n" + output; List&lt;String&gt; narr= new ArrayList&lt;&gt;(); int tmp = 0; for (int i = 0 ; i&lt;arr.size(); i++){ int a = Integer.parseInt(arr.get(i)); tmp += a; if(i%2==1){ narr.add(String.valueOf(tmp)); tmp = 0; } } arr = narr; // System.out.println(narr); }while(arr.size()&gt;1); output = String.join(" ",arr) +" \n" + output; System.out.println(output); }
}
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/kt_누적합.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/kt_누적합.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:09:12 GMT</pubDate></item><item><title><![CDATA[t_미로탈출_152]]></title><description><![CDATA[n * m 미로
start 1,1 // 출구 n,m
괴물 o : 0 , 괴물 x : 1
최소 개수, 시작칸과 마지막 칸 포함common한 bfs문제였다.import sys
from collections import deque
n,m = map(int, sys.stdin.readline().split())
arr = []
for i in range(n): arr.append(list(map(int,sys.stdin.readline().strip()))) # y,x
ways = [[-1,0],[1,0],[0,-1],[0,1]] # now
ny = 0
nx = 0 def bfs(y,x): q = deque([[y,x]]) arr[y][x] = -1 while len(q)&gt;0: ty,tx = q.popleft() step = arr[ty][tx] for w in ways: dy = ty + w[0] dx = tx + w[1] if dy&gt;-1 and dx&gt; -1 and dy&lt;n and dx&lt;m: if arr[dy][dx] &gt; 0: q.append([dy,dx]) arr[dy][dx] = step-1 bfs(0,0)
print(-arr[n-1][m-1]) ]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/t_미로탈출_152.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/t_미로탈출_152.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:09:12 GMT</pubDate></item><item><title><![CDATA[kt_n을 보는 시각]]></title><description><![CDATA[import sys a = sys.stdin.readline().strip() cnt60 = 0
for i in range(60): # 60 단위에서는 몇 번볼수잇나 if a in str(i): cnt60 += 1 cnt24 = 0
for i in range(24): if a in str(i): cnt24 += 1
# print(cnt60,cnt24)
h = cnt24 * 60 * 60
m = (24-cnt24) * cnt60 * 60
s = (24-cnt24) * (60-cnt60) * cnt60
answer = h + m + s
print(answer)
// don't place package name. import java.io.*; import java.util.*; // don't change 'Main' class name and 'public' accessor. public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String a = br.readLine(); int cnt60 = 0; for(int i = 0; i&lt; 60; i++){ String si = String.valueOf(i); if(si.contains(a)){ cnt60 += 1; } } int cnt24 = 0; for(int i =0 ;i&lt;24; i++){ String si = String.valueOf(i); if(si.contains(a)){ cnt24 += 1; } } int h = cnt24 * 60 * 60; int m = (24-cnt24) * cnt60 * 60; int s = (24-cnt24) * (60-cnt60) * cnt60; System.out.println(h+m+s); }
}
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/kt_n을-보는-시각.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/kt_n을 보는 시각.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:09:12 GMT</pubDate></item><item><title><![CDATA[g_거리두기]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://codingbutterfly.tistory.com/31" target="_self">https://codingbutterfly.tistory.com/31</a>]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/g_거리두기.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/g_거리두기.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:09:12 GMT</pubDate></item><item><title><![CDATA[t_숫자카드게임_96]]></title><description><![CDATA[n,m형태의 2차원배열
행선택 &gt; 가장 낮은 카드 뽑음
이때 가장 높은 수를 뽑고싶음해설할게없음.import sys n,m = map(int, sys.stdin.readline().split())
max_num = 0
for i in range(0,n): tmp = min(map(int, sys.stdin.readline().split())) if max_num &lt; tmp: max_num=tmp print(max_num)
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/t_숫자카드게임_96.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/t_숫자카드게임_96.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:09:12 GMT</pubDate></item><item><title><![CDATA[kt_효율적인 화패 구성]]></title><description><![CDATA[어떤 나라에는 가치가 서로 다른 N가지 동전이 있습니다. 이 동전들을 이용해서 가치의 합이 M이 되게 하는 동전 개수의 최솟값을 구하는 프로그램을 작성하세요. 예를 들어 가치가 2, 3인 단위의 동전이 있을 때는 가치 15를 만들기 위해 가치 3짜리 동전 5개를 사용하는 것이 동전의 개수가 가장 최소가 됩니다.그리디 5원3원가정coin 인덱스가 무게를 넘을지를 생각하지 못햇다. ㅋㅋimport sys from collections import deque
input = sys.stdin.readline def solve(): n,m = map(int,input().strip().split()) arr = [10001] * (m + 1) coin = [] for _ in range(n): k = int(input().strip()) if k == m: return 1 if k &gt; m : continue arr[k] = 1 coin.append(k) for i in range(m+1): if arr[i] != 0 : for c in coin: ni = i + c if ni&lt;=m: arr[ni] = min(arr[ni],arr[i]+1) return arr[m] if arr[m]&lt;10001 else -1 print(solve())
import sys from collections import deque
input = sys.stdin.readline def solve(): n,m = map(int,input().strip().split()) coins = [] for _ in range(n): k = int(input().strip()) if k == m: return 1 if k &gt; m : continue coins.append(k) q = deque(list(map(lambda x:(x,1),coins))) while len(q) &gt; 0: v, step = q.popleft() for a in coins: tmp = v + a if tmp == m: return step+1 elif tmp &lt; m: q.append((tmp,step+1)) return -1 print(solve()) ``` ```python
import sys from collections import deque
input = sys.stdin.readline def solve(): n,m = map(int,input().strip().split()) coins = [] visited = set() for _ in range(n): k = int(input().strip()) if k == m: return 1 if k &gt; m : continue coins.append(k) visited.add(k) q = deque(list(map(lambda x:(x,1),coins))) # print(q) while len(q) &gt; 0: v, step = q.popleft() # print(q) for a in coins: tmp = v + a if tmp in visited: continue if tmp == m: return step+1 elif tmp &lt; m: visited.add(tmp) q.append((tmp,step+1)) return -1 print(solve())
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/kt_효율적인-화패-구성.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/kt_효율적인 화패 구성.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:09:12 GMT</pubDate></item><item><title><![CDATA[b_등수구하기_1205]]></title><description><![CDATA[각노래마다 랭킹리스트.
100, 90, 90, 80일 때 각각의 등수는 1, 2, 2, 4등
몇등인지.
랭킹리스트에올라갈 수 없을정도로 작음 -1
입력
점수수 , 새로운점수, 랭킹리스트 올라갈수 있는 수
랭킹리스트단순 구현import sys
n, ns, p = map(int,sys.stdin.readline().strip().split())
scores = list(map(int,sys.stdin.readline().strip().split()))
# 점수수 , 새로운점수, 랭킹리스트 올라갈수 있는 수
# 랭킹리스트
lens = len(scores) if lens &gt;= p and scores[lens-1]&gt;=ns: # 랭킹이 꽉차있고 마지막놈보다 작거나같을때 print(-1)
else: scores.append(ns) scores.sort(reverse=True) ans=scores.index(ns) print(ans+1)
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/b_등수구하기_1205.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/b_등수구하기_1205.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:09:12 GMT</pubDate></item><item><title><![CDATA[b_임스미니게임_25757]]></title><description><![CDATA[Y : 2 ,F :3 , O:4
인원수가 맞아야함
여러번 같은사람과 플레이불가
최대 몇번 게임가능?걍구현문제임import sys
n,m = sys.stdin.readline().strip().split()
num = 0
if m == 'Y': num= 1
elif m == 'F': num = 2
else: num = 3
arr = set([])
while True: input = sys.stdin.readline().strip() if input =='': break arr.add(input) print(len(arr)//num) ]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/b_임스미니게임_25757.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/b_임스미니게임_25757.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:09:12 GMT</pubDate></item><item><title><![CDATA[t_게임개발_118]]></title><description><![CDATA[n * m 직사각형 , 육지 0 바다1
바다 갈수없음, 상하좌우 이동가능
반시계 90도
가본칸없음 &gt; 전진, else 1
다갈수없음, 방향유지한채 뒤로한칸후 1번순서로이동 뒤에가 바다일시 stop 나는 여기서 check_valid라고 arr안에 존재하는지 제한을 주었다.
여기서는 근데 외각이 항상 바다로 되어있다고 햇으므로 필요있진않았지만 있는게좋을듯^.^import sys
# y,x
ways = [[-1,0],[0,1],[1,0],[0,-1]]
# 0이 육지다 북동남서순
# 0 육지 1 바다 -1 가본곳
# 실제로 갈건 반시계방향 &gt; -1씩해야함
# 캐릭터가 방문한 칸수
col,row = map(int, sys.stdin.readline().split())
ny, nx, nway = map(int, sys.stdin.readline().split())
arr =[]
for c in range(col): arr.append(list(map(int, sys.stdin.readline().split()))) def check_valid(y,x): return x &gt;-1 and y &gt; -1 and x&lt;row and y &lt; col
arr[ny][nx] = -1
cnt = 1
miss = 0
while True: print(ny,nx,nway,miss,cnt) nway -= 1 if nway&lt;0: nway += 4 tmpy = ny + ways[nway][0] tmpx = nx + ways[nway][1] if check_valid(tmpy,tmpx): if arr[tmpy][tmpx] == 0: arr[tmpy][tmpx] = -1 ny = tmpy nx = tmpx miss = 0 cnt +=1 continue miss +=1 if miss &gt; 3: # 바라본 방향을 유지한 채 뒤로간다. ny -= ways[nway][0] nx -= ways[nway][1] if check_valid(ny,nx): if arr[ny][nx] != 1: miss = 0 continue break print(cnt)
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/t_게임개발_118.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/t_게임개발_118.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:09:12 GMT</pubDate></item><item><title><![CDATA[p_도넛과막대그래프_258711]]></title><description><![CDATA[정점번호, 도넛,막대,8자
막대 조건 : 시작 노드가 input이없다.
최종노드가 outpu이없다
정점 : input 없고 output많은것
'생성된 정점'은 나가는 간선의 수가 2 이상이고, 들어오는 간선의 수가 0이다.
'막대 모양 그래프'의 수는 나가는 간선의 수가 0, 들어오는 간선의 수가 1인 노드의 개수와 같다.
'8자 모양 그래프'의 수는 나가는 간선의 수가 2, 들어오는 간선의 수도 2인 노드의 개수와 같다.
'도넛 모양 그래프'는 '생성된 정점'의 나가는 간선의 수에서 막대 모양 그래프와 8자 모양 그래프의 개수를 빼서 구한다.
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@mino0121/ProgrammersPython-%EB%8F%84%EB%84%9B%EA%B3%BC-%EB%A7%89%EB%8C%80%EA%B7%B8%EB%9E%98%ED%94%84" target="_self">https://velog.io/@mino0121/ProgrammersPython-%EB%8F%84%EB%84%9B%EA%B3%BC-%EB%A7%89%EB%8C%80%EA%B7%B8%EB%9E%98%ED%94%84</a>도넛 모양 그래프, 막대 모양 그래프, 8자 모양 그래프가 여러 개 있습니다. 이 그래프들과 무관한 정점을 하나 생성한 뒤, 각 도넛 모양 그래프, 막대 모양 그래프, 8자 모양 그래프의 임의의 정점 하나로 향하는 간선들을 연결했습니다.이말을 확실히 봐야만했엇다.]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/p_도넛과막대그래프_258711.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/p_도넛과막대그래프_258711.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:09:12 GMT</pubDate></item><item><title><![CDATA[t_왕실의나이트_115]]></title><description><![CDATA[8 * 8 체스판
말형태로이동가능 가로세로 2,1 or 1,2
행 1-8 , 열 a-h
a1형태로 입력8개의 경우의수가 있음 (기본적으로는)import sys
# x a-h
# y 1-8
max = 8
input = sys.stdin.readline().strip() x = ord(input[0])-ord('a')
y = int(input[1])-1
cnt = 0 way = [[1,2],[-1,2],[1,-2],[-1,-2],[2,1],[-2,1],[2,-1],[-2,-1]]
for tmx,tmy in way: tx = x+tmx ty = y+tmy if tx &gt; -1 and ty &gt; -1 and tx &lt; max and ty&lt; max: cnt+=1 print(cnt)
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/t_왕실의나이트_115.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/t_왕실의나이트_115.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:09:12 GMT</pubDate></item><item><title><![CDATA[p_스킬트리_49993]]></title><link>600-알고리즘-&amp;-코딩테스트/problem/p_스킬트리_49993.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/p_스킬트리_49993.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:09:12 GMT</pubDate></item><item><title><![CDATA[t_상하좌우_110]]></title><description><![CDATA[n * n 정사각형
시작좌표 1,1 상하좌우의 이동문자를 통해 도착하는 목적지를 찾아라별거없음import sys
now = [1,1]
max = int(sys.stdin.readline().strip())
arr = sys.stdin.readline().split()
# y,x
way = { 'R' : [0,1], 'L' : [0,-1], 'U' : [-1,0], 'D' : [1,0]
}
for a in arr: ny = way[a][0] + now[0] nx = way[a][1] + now[1] if(ny&lt;=max and nx &lt;= max and ny&gt;0 and nx &gt;0): now = [ny,nx] print(now)
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/t_상하좌우_110.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/t_상하좌우_110.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:09:12 GMT</pubDate></item><item><title><![CDATA[c_TieRopes]]></title><description><![CDATA[0 &lt;= L &lt; N 번 로프가 일열로 바닥에
길이 배열 A[L]
인접한 로프 묶을 수 있음
k 보다 같거나 큰로프를 최대한많이 만들때의 개수작으면 차피 사용못하니깐 우측꺼에 연결한다고 가정한다.
그러면겁나쉽게풀림function solution(K, A) { let ans = 0 for(let i = 0 ; i&lt; A.length; i++){ if(A[i]&gt;=K){ ans++; }else{ if(i!==A.length-1){ A[i+1] += A[i] } } } return ans
}
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/c_tieropes.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/c_TieRopes.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:09:12 GMT</pubDate></item><item><title><![CDATA[t_음료수얼려먹기_149]]></title><description><![CDATA[n * m
구멍 뚤린부분 0, 칸막이 1
상하좌우 붙어있는경우 연결되어있는 것으로 간주.
얼음의 덩어리 개수가 몇갠가bfs가 더 올바르게 보인다.(복잡도가 더 떨어질듯)from collections import deque
import sys
arr = []
while True: tmp = list(map(int, sys.stdin.readline().strip())) if len(tmp)&lt;1: break arr.append(tmp)
# y,x
# 상하좌우
ways= [[-1,0],[1,0],[0,-1],[0,1]]
ylimit = len(arr)
xlimit = len(arr[0])
cnt = 0 # visit = -1
def bfs(y,x): q = deque([[y,x]]) while len(q)&gt;0: ny,nx = q.popleft() arr[ny][nx]=-1 for way in ways: ty = ny + way[0] tx = nx + way[1] if ty&gt;-1 and tx &gt; -1 and ty &lt; ylimit and tx &lt; xlimit: if arr[ty][tx] ==0: q.append([ty,tx]) for y in range(ylimit): for x in range(xlimit): if arr[y][x] == 0: bfs(y,x) cnt +=1 print(cnt)
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/t_음료수얼려먹기_149.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/t_음료수얼려먹기_149.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:09:12 GMT</pubDate></item><item><title><![CDATA[kt_태국택시]]></title><link>600-알고리즘-&amp;-코딩테스트/problem/kt_태국택시.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/kt_태국택시.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:09:12 GMT</pubDate></item><item><title><![CDATA[t_시각_113]]></title><description><![CDATA[정수 n입력시 0시 0분 0초부터 n시 59분 59초까지 중 3이 포함되는 경우의 수걍 무작정돌면서 가지치기하는식으로 코드를 짜봤다 .
but 3이 포함되는 경우가 한정적이니, 이경우를 미리생각해서 숫자로 식을 구할수도 잇을듯하다.import sys
limit = int(sys.stdin.readline().strip()) # h 0-23 m 0-59 s 0-59
# h&gt; 3,13,23 60*60
# m &gt; 3,13,23 - 53 5 60개
h = 0
m = 0
s = 0 count = 0 for h in range(0,limit+1): if '3' in str(h): count += 60*60 continue for m in range(0,60): if '3' in str(m): count += 60 continue for s in range(0,60): if '3' in str(s): count += 1 continue print(count) ]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/t_시각_113.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/t_시각_113.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:09:12 GMT</pubDate></item><item><title><![CDATA[t_떡볶이떡만들기_201]]></title><description><![CDATA[적어도 M만큼의 떡을 챙겨야함 == M이딱안맞을 수 있음높이가 가장높은것기준을 end로 잡고 이진탐색을하면될듯하다.
탈출조건 : 합이 M보다 작음
햇갈린 point : 탈출조건일때 Return값을 end를 줘야하나
탈출조건에 갔다는건 딱 맞는 값을 못 찾았다는것.
그렇다고 하면 start는 만족하는값을 충족시키지못하고 end는 만족하는값을 넘는 값이다. therefore end를 리턴해줘야함
실전에서는 실수를 줄이기 위해서 떡양이 충분할때 계속 result값에 기록하는 편이 좋을 듯.import sys n, m = map(int, sys.stdin.readline().strip().split())
arr = list(map(int, sys.stdin.readline().strip().split())) def cal_sum(v): sum = 0 for a in arr: tmp = a - v if tmp&gt;0: sum +=tmp return sum # end def search(start,end): if start&gt;end: return end mid = (start+end)//2 sum = cal_sum(mid) if m == sum : return mid elif m &lt; sum: # sum이 크다 = 자르는 길이가 작다 return search(mid+1,end) return search(start,mid-1) print(search(0,max(arr))) ]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/t_떡볶이떡만들기_201.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/t_떡볶이떡만들기_201.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:09:12 GMT</pubDate></item><item><title><![CDATA[c_MinAbsSum]]></title><description><![CDATA[배열 A(정수로 구성),S(-1,1로구성)
최소화.. 양끝에 절대값이잇음ㅋㅋㅋㅋdp 문제인걸몰랏으면 브루드 포스를햇을거임
틀렷음. 웨? let minRes = Infinity
function solution(A) { brud(A,0,0) return minRes
} function brud(A,step,sum){ if(step&gt;=A.length){ let absSum=Math.abs(sum) if(minRes&gt;=absSum){ minRes=absSum } return minRes===0 } for(let i=0;i&lt;A.length;i++){ if(brud(A,step+1,sum-A[i])||brud(A,step+1,sum+A[i])){ //0이나왓으므로종료한다. return true } }
}
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/c_minabssum.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/c_MinAbsSum.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:09:12 GMT</pubDate></item><item><title><![CDATA[t_팀결성_298]]></title><description><![CDATA[학생들에게 0부터 n까지 번호를 부여함
모든학생은 처음에는 서로다른팀
두가지 연산만 가능함. 팀합치기 &amp; 같은팀 여부확인
if 같은팀 여부확인 연산일때 결과들을 출력함
연산 a학생 b학생 0:합치기 1:같은팀여부확인걍 문제부터 유니온파인드 쓰라고 적혀져있는 문제라 방법은 딱히 고민하지 않아도된다.input = input.strip().split('\n')
n,m = map(int, input[0].split()) parents = [0] * (n+1)
for i in range(n+1): parents[i] = i def find_parent(parents,x): if parents[x] != x: parents[x] = find_parent(parents,parents[x]) return parents[x] arr = []
for i in range(1, m+1): f,a,b = map(int,input[i].split()) pa = find_parent(parents,a) pb = find_parent(parents,b) if f == 0: if pa &lt; pb: parents[pb] = pa else: parents[pa] = pb else: if pa != pb: print("NO") else: print("YES") ]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/t_팀결성_298.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/t_팀결성_298.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:09:12 GMT</pubDate></item><item><title><![CDATA[t_1이될때까지_99]]></title><description><![CDATA[n이 1이 되야함 아래의 과정을 통해..
N -1을한다
N/k를 한다(나누어떨어질때만 가능)
나누는게 더 극단적이니 나누는것 &gt; 빼는것을 고려해볼듯하다.
N-1이니 나누는것보다 N-1이 더 빠를 가능성은 없다
그리고 N/k의 값은 N-1로도 모두 구현이 가능하다.
THEREFORE GREEDYimport sys
n,m = map(int, sys.stdin.readline().split()) cnt = 0
while n&gt;1: tmp = n%m if tmp == 0: n //= m cnt += 1 else: n -= tmp cnt += tmp print(cnt)
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/t_1이될때까지_99.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/t_1이될때까지_99.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:09:12 GMT</pubDate></item><item><title><![CDATA[p_비밀코드해독_388352]]></title><description><![CDATA[
백트래킹
5개 정답코드
질문에몇개가 맞는지 나옴
이질문에 해당하는 정답코드를 구하삼요 정답코드 될수잇는거 다구해서 질문에 맞는걸 거르기
5중 for문
import itertools 이용
list(itertools.combinations(range(1, n + 1), 5))
백트래킹,브루드포스 &lt;&lt; 나의 코드임
처음에 탈출 조건을잘못둬서에러가났음
depth &gt;= n or cnt == 5 이렇게 하면 오류가남
왜냐면 check는질문지에 맞는지를 체크하는거지5개인지체크하는게아님result=0으로두고 계속 더하면됨요def solution(n, q, ans): arr = [0]*n answer = brute(arr,0,0,n,q,ans) return answer def brute(arr,depth,cnt,n,q,ans): result = 0 if cnt &gt; 5: return 0 if cnt == 5: if check(arr,q,ans): # + check # print("suc",arr) return 1 # print("fail",arr) return 0 if depth &gt;= n: return 0 for i in range(depth,n): arr[i] = 1 # 방문처리 result += brute(arr,i+1,cnt+1,n,q,ans) # print(result,i,cnt) arr[i] = 0 return result def check(arr,q,ans): for i in range(len(q)): cnt = 0 for j in range(5): if arr[q[i][j]-1] == 1: cnt +=1 if ans[i] != cnt: return False return True
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/p_비밀코드해독_388352.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/p_비밀코드해독_388352.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:09:12 GMT</pubDate></item><item><title><![CDATA[b_특정한최단경로]]></title><description><![CDATA[1 &gt; N 두정점 u,v 거처야함
1 &gt; u &gt; v &gt; N
1 &gt; v &gt; u &gt; N여러경로에 대한 최단거리를 알아야하기에 플루이드 워셜이 낫다고 판단햇다.맞는데 시간초과가 뜬다. n^3이라서그런듯. 경로가 쨋든 정해저잇기만한다면 걍 다익스트라쓰는것이 나은가보다.import sys
import math
import heapq
input = sys.stdin.readline N,E= map(int,input().strip().split())
graph = [[math.inf]*(N+1) for _ in range(N+1)] for i in range(E): n1,n2,c = map(int,input().strip().split()) graph[n1][n2] = c graph[n2][n1] = c
v1,v2 = map(int,input().strip().split())
for i in range(1,N+1): for j in range(i,N+1): for k in range(1,N+1): graph[k][k] = 0 graph[i][j] = min(graph[i][j],graph[i][k]+graph[k][j]) graph[j][i]=graph[i][j] result = min(graph[1][v1] +graph[v1][v2]+graph[v2][N],graph[1][v2] +graph[v2][v1]+graph[v1][N])
print(result)
역시 킹갓 힙으로해야..[]import sys
import math
import heapq
input = sys.stdin.readline N,E= map(int,input().strip().split())
graph = [[] for _ in range(N+1)]# 간선담을..
dist1 = [math.inf] * (N+1) # 1에서 무언다도착햇을때 최단거리
dist2 = [math.inf] * (N+1) # v1에서 무언가 도착햇을때 최단거리
dist3 = [math.inf] * (N+1) # v2에서 무언가 도착햇을때 최단거리 for i in range(E): n1,n2,c = map(int,input().strip().split()) graph[n1].append((c,n2)) graph[n2].append((c,n1)) # print(graph)
v1,v2 = map(int,input().strip().split()) def dij(start,dist): dist[start] = 0 heap = [] heapq.heappush(heap,(0,start)) while heap: d,now=heapq.heappop(heap) if dist[now]&lt;d: continue for c,n in graph[now]: # 인접노드 현재 거리에 이동한 거리더하기 cost = d + c if cost &lt; dist[n]: # 연결하고 인접한..거힙에추가 dist[n] = cost heapq.heappush(heap,(cost,n)) dij(1,dist1)
dij(v1,dist2)
dij(v2,dist3)
result= min(dist1[v1]+dist2[v2]+dist3[N],dist1[v2]+dist2[N]+dist3[v1])
if result == math.inf: result = -1
print(result)
]]></description><link>600-알고리즘-&amp;-코딩테스트/problem/b_특정한최단경로.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/problem/b_특정한최단경로.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 16:09:12 GMT</pubDate></item><item><title><![CDATA[bfs,dfs]]></title><description><![CDATA[알아야할 lib
from collections import deque
&nbsp;한쪽경로의 끝을 확인할때 쓰임, 나는 이게 어떤 뭉탱이랑 구별되는지 같은거에 주로 썼음 스택(재귀)로 구현
재귀도 스택형식임 그래프로 눈에 보이는건 deque으로 처리할 만함 방문처리
백트래킹 : 방문처리후 돌고 방문처리를 다시 안함 걍 다도는 것 &nbsp;최단거리 구할 때(제일 먼저 push되는게 최단거리) / 같은 깊이를 비교할때 / 어떤 턴마다 확장되는 문제에서 많이 쓰였음 큐를 이용하여 구현
while과함께하여 큐가 빌 때까지 도는게 일반적
]]></description><link>600-알고리즘-&amp;-코딩테스트/theory/bfs,dfs.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/theory/bfs,dfs.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 15:59:44 GMT</pubDate></item><item><title><![CDATA[graph]]></title><description><![CDATA[<img alt="assets/graph-20240831020857057.png" src="600-알고리즘-&amp;-코딩테스트/assets/graph-20240831020857057.png" target="_self" style="width: 200px; max-width: 100%;">
거리와 가중치는 같은말임
인접 리스트 방식 2차원배열로 나타내는 형식 각 index는 node임 그 값은 노드사이의 거리를 나타냄
안이어졌으면 infinite import math math.inf 인접행렬 방식 각 index를 기준으로 인접한 node의 거리를 적음
(node,거리)
[ [(1,7),(2,5)] , [(0,7)] , [(0,5)]] ]]></description><link>600-알고리즘-&amp;-코딩테스트/theory/graph.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/theory/graph.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 15:59:41 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[최소신장트리]]></title><description><![CDATA[
신장트리 : 하나의 그래프가 있을때 모든 노드를 포함하면서 사이클이 없는 그래프
크루스칼은 최소신장트리(mst)를 구할때 사용함 크리스칼 알고리즘을 이용!!
정렬 기준이 edge이다!!
최소신장트리로 분할할라면 최소신장트리를하나만들고 젤큰간선을 없애면된다
예로 다리를 최소한의 비용으로 놓아야하지만 다 놓아야할 때
간선을 비용에 따라 오름차순으로 정렬한다
사이클발생하는지 확인하고 발생하지 않을 시 mst에 포함시킨다. 이때 unionfind # 입력형식 a,b,c
# 저장형식 edges.append((c,a,b)) 비용을 앞으로
# node 개수 v
parent = [0] * (v+1)
sum_cost = 0
edges.sort() def find_parent(parent,n): if parent[n] != n: parent[n] = find_parent(parent,parent[n]) return parent[n] for e in edges: c , a,b = e pa = find_parent(parent,a) pb = find_parent(parent,b) if pa != pb: sum_cost += c # 루트노드의 부모끼리 연결해야함 if pa &lt; pb: parent[pb] = pa else: parent[pa] = pb ]]></description><link>600-알고리즘-&amp;-코딩테스트/theory/최소신장트리.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/theory/최소신장트리.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 15:59:36 GMT</pubDate></item><item><title><![CDATA[정렬]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://hsp1116.tistory.com/33" target="_self">https://hsp1116.tistory.com/33</a>계수정렬버블정렬
등..]]></description><link>600-알고리즘-&amp;-코딩테스트/theory/정렬.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/theory/정렬.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 15:59:34 GMT</pubDate></item><item><title><![CDATA[이진탐색]]></title><description><![CDATA[
조건 값이 딱 떨어지지 않을 때 탐색범위가 매우 클때
시작과 끝점 중간점 3가지의 포인트를 가지고 데이터를 반복적으로 비교하는것.
탐색범위 : 1천만 이상일때 권함 O(logN)
구현방식 : 재귀# 이진 탐색 소스코드 구현(재귀 함수) def binary_search(array, target, start, end): if start &gt; end: return None mid = (start + end) // 2 # 찾은 경우 중간점 인덱스 반환 if array[mid] = = target: return mid # 중간점의 값보다 찾고자 하는 값이 작은 경우 왼쪽 확인 elif array[mid] &gt; target: return binary_search(array, target, start, mid - 1) # 중간점의 값보다 찾고자 하는 값이 큰 경우 오른쪽 확인 else: return binary_search(array, target, mid + 1, end) # n(원소의 개수)과 target(찾고자 하는 문자열)을 입력받기
n, target = list(map(int, input().split())) # 전체 원소 입력받기 array = list(map(int, input().split()))
# 이진 탐색 수행 결과 출력 result = binary_search(array, target, 0, n - 1) if result = = None: print("원소가 존재하지 않습니다.") else: print(result + 1)
]]></description><link>600-알고리즘-&amp;-코딩테스트/theory/이진탐색.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/theory/이진탐색.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 15:59:27 GMT</pubDate></item><item><title><![CDATA[유니온파인드]]></title><description><![CDATA[서로소집합을 찾는, 혹은 그래프끼리 연결되어있지 않는것을 찾는 알고리즘
부모를 먼저자기자신으로 초기화
루트노드를 찾아서 기록한다.
def find_parent(parent,x): # 루트노드가 아니라면 if parent[x]!= x: parent[x] = find_parent(parent,parent[x]) # 부모의 부모를찾는다 return parent[x] #간선이 있을 시 연결
def union_parent(parent,a,b): a = find_parent(parent,a) b = find_parent(parent,b) if a &lt; b: # 작은분이 우선루트노드 parent[b] = a else: parent[a] = b # 노드개수만큼 부모테이블 있어야하고 각 부모테이블의 기본값으로 자기자신으로 해야함
무방향그래프에서의 사이클 판별할때 이용가능하다
간선의 각각 노드의 부모노드가 같을때 사이클이 발생한다.
방향이있을때는 dfs로 판별가능하다.if find_parent(parent, a) = = find_parent(parent, b): cycle = True break
]]></description><link>600-알고리즘-&amp;-코딩테스트/theory/유니온파인드.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/theory/유니온파인드.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 15:59:22 GMT</pubDate></item><item><title><![CDATA[위상정렬]]></title><description><![CDATA[
방향 그래프의 노드를 방향성에 거스르지 않고 순서대로 나열하는 것
예시 : Like 커리큘럼
진입차수가 0인 노드를 큐에 넣는다
큐가 빌때까지 큐에서 원소를 커내 해당노드에서 출발하는 간선을 제거한다.
새롭게 진입차수가 0이 된 노드를 큐에 넣는다. from collections import deque # v 는 노드개수
# graph[node].append(연결된노드)
inde = [0] * (v+1) # 노드에 대한 진입차수 def topology_sort(): result = [] q = deque() # 진입차수가 0인거 큐에 삽입 for i in range(1,n+1): if inde[i] == 0: q.append(i) while q: now = q.popleft() result.append(now) #now 에서 출발한 간선에 대해서 진입차수 제거 for i in graph[now]: inde[i] -= 1 if inde[i] == 0: q.append(i) ]]></description><link>600-알고리즘-&amp;-코딩테스트/theory/위상정렬.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/theory/위상정렬.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 15:59:19 GMT</pubDate></item><item><title><![CDATA[슬라이딩윈도우]]></title><description><![CDATA[aka Caterpillar Method]]></description><link>600-알고리즘-&amp;-코딩테스트/theory/슬라이딩윈도우.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/theory/슬라이딩윈도우.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 15:59:13 GMT</pubDate></item><item><title><![CDATA[비트 연산,비트마스킹]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://un-gaemii.tistory.com/6" target="_self">https://un-gaemii.tistory.com/6</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://yiyj1030.tistory.com/267" target="_self">https://yiyj1030.tistory.com/267</a><br>
<a class="internal-link" data-href="구현.md" href="600-알고리즘-&amp;-코딩테스트/theory/구현.html" target="_self" rel="noopener nofollow">구현</a>]]></description><link>600-알고리즘-&amp;-코딩테스트/theory/비트-연산,비트마스킹.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/theory/비트 연산,비트마스킹.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 15:59:09 GMT</pubDate></item><item><title><![CDATA[비용이있는 최단경로]]></title><description><![CDATA[여기서의 비용은 간선의 크기,또는 가중치이라고 불린다.
양의 가중치여야함
안 방문한 노드중 가장 비용이 적은 간선을 선택 방문한 노드는 최단거리가 확정이됨 특정지점에서 다른 노드들까지의 최단거리 1 to N 출발노드 있음 일종의 <a data-href="그리디" href="600-알고리즘-&amp;-코딩테스트/theory/그리디.html" class="internal-link" target="_self" rel="noopener nofollow">그리디</a> 배열 사용 import math input = sys.stdin.readline
n,m = map(int,input().split()) # 노드 개수,간선
start = int(input())
# 그래프에 대한 정보를 담는 노드
graph = [[] for i in range(n+1)]
visited = [False]*(n+1)
# 시작 노드에 대한 최단 거리를 저장하는 리스트
distance = [math.inf]*(n+1) # 그래프 입력
for _ in range(m) a,b,c = map(int,input().split()) # a &gt; b , 비용은 c graph[a].append((b,c)) def get_smallest(): minV = math.inf node = 0 # 최단거리의 노드 for i in range(1,n+1): if not visited[i] and distance[i]&lt; minV: minV = distance[i] node = i return node def dijkstra(start): distance[start] = 0 visited[start] = True # 시작 노드와 연결된 노드의 거리를 입력 for j in graph[start]: distance[j[0]]=j[1] for i in range(n-1): now = get_smallest() visited[now] = True # 가장 짧은 노드 꺼내서 다른 연결된 노드를 확인하고 거리를 업데이트한다 for j in graph[now]: cost = distance[now] + j[1] if cost &lt; distance[j[0]]: distance[j[0]] = cost 우선순위큐(힙) 사용 우선순위큐는 내부적으로 최소힙 최대힙을 이용한다.
현재 가장 가까운 노드를 저장하기위해서 우선순위 큐사용
위에서의 getsmallest의 함수가 필요없음
import heapq
# 그래프 입력 까지 같음
def dijkstra(start): q = [] # 거리, 노드로 입력받음 heapq.heappush(q,(0,start)) distance[start] = 0 while q: dist, now = heapq.heappop(q) # 이전에 입력된 거리가 더 짧다 == 처리된 적이 있는 노드 if distance[now] &lt; dist: continue #인접한 노드확인 for i in graph[now]: cost = dist + i[1] if cost &lt; distance[i[0]] : distance[i[0]] = cost heapq.heappush(q,(cost,i[0])) import sys
input = sys.stdin.readline
INF = int(1e9) # 무한을 의미하는 값으로 10억을 설정 # 노드의 개수, 간선의 개수를 입력받기
n, m = map(int, input().split())
# 모든 간선에 대한 정보를 담는 리스트 만들기
edges = []
# 최단 거리 테이블을 모두 무한으로 초기화
distance = [INF] * (n + 1) # 모든 간선 정보를 입력받기
for _ in range(m): a, b, c = map(int, input().split()) # a번 노드에서 b번 노드로 가는 비용이 c라는 의미 edges.append((a, b, c)) def bf(start): # 시작 노드에 대해서 초기화 distance[start] = 0 # 전체 n - 1번의 라운드(round)를 반복 for i in range(n): # 매 반복마다 "모든 간선"을 확인하며 for j in range(m): cur_node = edges[j][0] next_node = edges[j][1] edge_cost = edges[j][2] # 현재 간선을 거쳐서 다른 노드로 이동하는 거리가 더 짧은 경우 if distance[cur_node] != INF and distance[next_node] &gt; distance[cur_node] + edge_cost: distance[next_node] = distance[cur_node] + edge_cost # n번째 라운드에서도 값이 갱신된다면 음수 순환이 존재 if i == n - 1: return True return False # 벨만 포드 알고리즘을 수행
negative_cycle = bf(1) # 1번 노드가 시작 노드 if negative_cycle: print("-1")
else: # 1번 노드를 제외한 다른 모든 노드로 가기 위한 최단 거리를 출력 for i in range(2, n + 1): # 도달할 수 없는 경우, -1을 출력 if distance[i] == INF: print("-1") # 도달할 수 있는 경우 거리를 출력 else: print(distance[i]) 모든지점에서 다른 모든지점까지의 최단경로 N to N
출발점이여러개다!! 플로이드워셜
시간 복잡도 3중반복문.. 2차원배열로 자기자신은 0 없는 간선은 inf, 있는 간선은 값을 넣음
a,b,c가 노드, a&gt; b일대와 a&gt; c , c&gt; b일때 머가 더 가까운지 비교해서 기입.
import math
n,m = map(int, input().split())
# 이차원 배열
graph = [[math.inf] * (n+1) for _ in range(n+1)] # 자기자신은 0으로
for a in range(1,n+1): graph[a][a] = 0 # 간선에 대한 정보 업데이트
for _ in range(m) a,b,c = map(int,input().split()) # 노드, 노드 ,비용 graph[a][b] = c for k in range(1,n+1): for a in range(1,n+1): for b in range(1,n+1): graph[a][b] = min(graph[a][b],graph[a][k]+graph[k][b])
]]></description><link>600-알고리즘-&amp;-코딩테스트/theory/비용이있는-최단경로.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/theory/비용이있는 최단경로.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 15:59:00 GMT</pubDate></item><item><title><![CDATA[그리디]]></title><description><![CDATA[
현재 상황에서 지금 당장 좋은것을 고르는 방법!
해법이 정당한지 검토해야함당장 눈에 보이는 더좋은것이 덜좋은 방법이랑 결론적으로 같은 지한번생각해보는게 좋은듯. 현재의 조건이 미래의 선택에 영향을 주지 않는다 ]]></description><link>600-알고리즘-&amp;-코딩테스트/theory/그리디.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/theory/그리디.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 15:36:12 GMT</pubDate></item><item><title><![CDATA[다이나믹프로그래밍]]></title><description><![CDATA[중복되는 연산을 줄이고 한번계산한 문제를 다시 계산치 않도록한다
탑다운 : 큰문제해결위해 작은문제를 호출 보통 재귀로
메모리제이션 방식이라고함
recursion depth : 재귀함수 깊이 오류 발생가능 보텀업 : 작은문제에서 순서대로 차근차근 해결 단순반복문,
DP테이블을 통해서 결과 저장 점화식을 세워보는 것도 좋은 것 같다.
선택하느냐 마느냐 특정 지점에 올때까지 최대값(주어진조건)
배낭문제 st : 최대값을가지면서 특정값미만이어야함 제한된 용량 내에서 가치를 최대화하는 문제
1처럼햇을때 계속 최대치를 추구하게되면 되는데 안되는경우가 발생할수잇음
특정값을 배열로가져서 특정값이 되는경우중 최대값을 구하면됨 중복적인 연산이 많음
dfs,bfs,재귀 로가능하지만 시간초과가 나는경우(케이스가 너무많은경우)
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.youtube.com/watch?v=0bqfTzpWySY" target="_self">https://www.youtube.com/watch?v=0bqfTzpWySY</a>단일 배열에서 가장 긴 “증가하는” 수열을 찾을 때 사용하며, 순서가 중요한 문제에 적합합니다.
이전수열중에 나보다 작은것중에 가장 숫자가큰(연속된다는 값이 큰) 것 +1두 개의 배열이나 문자열에서 공통적으로 나타나는 가장 긴 부분 수열을 찾는 데 사용하며, 두 데이터를 비교하고 공통 패턴을 찾는 데 적합합니다.]]></description><link>600-알고리즘-&amp;-코딩테스트/theory/다이나믹프로그래밍.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/theory/다이나믹프로그래밍.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 15:36:09 GMT</pubDate></item><item><title><![CDATA[📖 600 알고리즘 & 코딩테스트]]></title><description><![CDATA[알고리즘 &amp; 코딩테스트 관련 학습 내용을 담는 토픽입니다.
<a data-href="📚 601 구현 &amp; 완전탐색" href="99-settings/1-topics/📚-601-구현-&amp;-완전탐색.html" class="internal-link" target="_self" rel="noopener nofollow">📚 601 구현 &amp; 완전탐색</a>
<br><a data-href="📚 602 그리디" href="99-settings/1-topics/📚-602-그리디.html" class="internal-link" target="_self" rel="noopener nofollow">📚 602 그리디</a>
<br><a data-href="📚 603 다이나믹프로그래밍" href="99-settings/1-topics/📚-603-다이나믹프로그래밍.html" class="internal-link" target="_self" rel="noopener nofollow">📚 603 다이나믹프로그래밍</a>
<br><a data-href="📚 604 최단경로" href="99-settings/1-topics/📚-604-최단경로.html" class="internal-link" target="_self" rel="noopener nofollow">📚 604 최단경로</a>
<br><a data-href="📚 605 비트연산 &amp; 비트마스킹" href="99-settings/1-topics/📚-605-비트연산-&amp;-비트마스킹.html" class="internal-link" target="_self" rel="noopener nofollow">📚 605 비트연산 &amp; 비트마스킹</a>
<br><a data-href="📚 606 세그먼트트리" href="99-settings/1-topics/📚-606-세그먼트트리.html" class="internal-link" target="_self" rel="noopener nofollow">📚 606 세그먼트트리</a>
<br><a data-href="📚 607 슬라이딩윈도우" href="99-settings/1-topics/📚-607-슬라이딩윈도우.html" class="internal-link" target="_self" rel="noopener nofollow">📚 607 슬라이딩윈도우</a>
<br><a data-href="📚 608 위상정렬" href="99-settings/1-topics/📚-608-위상정렬.html" class="internal-link" target="_self" rel="noopener nofollow">📚 608 위상정렬</a>
<br><a data-href="📚 609 유니온파인드" href="99-settings/1-topics/📚-609-유니온파인드.html" class="internal-link" target="_self" rel="noopener nofollow">📚 609 유니온파인드</a>
<br><a data-href="📚 610 이진탐색" href="99-settings/1-topics/📚-610-이진탐색.html" class="internal-link" target="_self" rel="noopener nofollow">📚 610 이진탐색</a>
<br><a data-href="📚 611 정렬" href="99-settings/1-topics/📚-611-정렬.html" class="internal-link" target="_self" rel="noopener nofollow">📚 611 정렬</a>
<br><a data-href="📚 612 최소신장트리" href="99-settings/1-topics/📚-612-최소신장트리.html" class="internal-link" target="_self" rel="noopener nofollow">📚 612 최소신장트리</a>
<br><a data-href="📚 613 BFS &amp; DFS" href="99-settings/1-topics/📚-613-bfs-&amp;-dfs.html" class="internal-link" target="_self" rel="noopener nofollow">📚 613 BFS &amp; DFS</a>
<br><a data-href="📚 614 그래프" href="99-settings/1-topics/📚-614-그래프.html" class="internal-link" target="_self" rel="noopener nofollow">📚 614 그래프</a>
<br><a data-href="📚 615 정렬알고리즘" href="99-settings/1-topics/📚-615-정렬알고리즘.html" class="internal-link" target="_self" rel="noopener nofollow">📚 615 정렬알고리즘</a>
<br><a data-href="📚 616 Python" href="99-settings/1-topics/📚-616-python.html" class="internal-link" target="_self" rel="noopener nofollow">📚 616 Python</a>
<br><a data-href="📚 617 Java" href="99-settings/1-topics/📚-617-java.html" class="internal-link" target="_self" rel="noopener nofollow">📚 617 Java</a>
]]></description><link>99-settings/1-topics/📖-600-알고리즘-&amp;-코딩테스트.html</link><guid isPermaLink="false">99-Settings/1-Topics/📖 600 알고리즘 &amp; 코딩테스트.md</guid><pubDate>Mon, 08 Sep 2025 15:34:30 GMT</pubDate></item><item><title><![CDATA[📚 615 정렬알고리즘]]></title><description><![CDATA[계수정렬, 위상정렬 등 일반적인 정렬 알고리즘 관련 내용
<a data-href="📖 600 알고리즘 &amp; 코딩테스트" href="99-settings/1-topics/📖-600-알고리즘-&amp;-코딩테스트.html" class="internal-link" target="_self" rel="noopener nofollow">📖 600 알고리즘 &amp; 코딩테스트</a>
]]></description><link>99-settings/1-topics/📚-615-정렬알고리즘.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 615 정렬알고리즘.md</guid><pubDate>Mon, 08 Sep 2025 15:34:30 GMT</pubDate></item><item><title><![CDATA[구현]]></title><description><![CDATA[완전탐색(브루드포스), 시물레이션(한단계씩하는 것)재귀]]></description><link>600-알고리즘-&amp;-코딩테스트/theory/구현.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/theory/구현.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 15:20:33 GMT</pubDate></item><item><title><![CDATA[세그먼트트리]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.youtube.com/watch?v=1d9sqmuLy-o&amp;t=476s" target="_self">https://www.youtube.com/watch?v=1d9sqmuLy-o&amp;t=476s</a>
이진트리여야함
리프노드만 원본
종류 트리의 구간합을 구하는경우
배열을 구간합으로 구하는경우 이때 배열의 각값은 리프노드가된다.
이때 질의 인덱스를 세그먼트 트리인덱스로 바꿔야한다 질의인덱스+ 2^k -1 고로 리프노드 로 트리를 초기화해야함리프노트로 초기화할때 배열의 크기
리프노드가 N개일 때 배열의 크기: start_index % 2== 1일 때 해당 노드를 선택한다. // 자식노드임 end_index % 2== 0일 때 해당 노드를 선택한다. //부모노드임 start_index depth 변경: start_index = (start_index + 1) / 2 연산을 실행한다. //부모노드로이동 end_index depth 변경: end_index = (end_index - 1) / 2 연산을 실행한다. //부모노드로 이동 1~4를 반복하다가 end_index &lt; start_index가 되면 종료한다.
사람들은존나천재가틀림없다.]]></description><link>600-알고리즘-&amp;-코딩테스트/theory/세그먼트트리.html</link><guid isPermaLink="false">600-알고리즘 &amp; 코딩테스트/theory/세그먼트트리.md</guid><dc:creator><![CDATA[Jeon MinJi]]></dc:creator><pubDate>Mon, 08 Sep 2025 15:18:52 GMT</pubDate></item><item><title><![CDATA[📖 800 프로젝트]]></title><description><![CDATA[진행한 프로젝트 관련 내용]]></description><link>99-settings/1-topics/📖-800-프로젝트.html</link><guid isPermaLink="false">99-Settings/1-Topics/📖 800 프로젝트.md</guid><pubDate>Mon, 08 Sep 2025 14:37:20 GMT</pubDate></item><item><title><![CDATA[📖 900 기타]]></title><description><![CDATA[어디에도 분류되지 않는 기타 토픽들]]></description><link>99-settings/1-topics/📖-900-기타.html</link><guid isPermaLink="false">99-Settings/1-Topics/📖 900 기타.md</guid><pubDate>Mon, 08 Sep 2025 14:33:20 GMT</pubDate></item><item><title><![CDATA[🏷️ 레퍼런스]]></title><description><![CDATA[명령어, API, 문법 정리 관련 내용]]></description><link>99-settings/2-index/🏷️-레퍼런스.html</link><guid isPermaLink="false">99-Settings/2-Index/🏷️ 레퍼런스.md</guid><pubDate>Mon, 08 Sep 2025 14:21:10 GMT</pubDate></item><item><title><![CDATA[🏷️ 실습]]></title><description><![CDATA[코딩, 구현, 실제 적용 관련 내용]]></description><link>99-settings/2-index/🏷️-실습.html</link><guid isPermaLink="false">99-Settings/2-Index/🏷️ 실습.md</guid><pubDate>Mon, 08 Sep 2025 14:21:10 GMT</pubDate></item><item><title><![CDATA[🏷️ 이론]]></title><description><![CDATA[개념, 원리, 이론적 배경 관련 내용]]></description><link>99-settings/2-index/🏷️-이론.html</link><guid isPermaLink="false">99-Settings/2-Index/🏷️ 이론.md</guid><pubDate>Mon, 08 Sep 2025 14:21:10 GMT</pubDate></item><item><title><![CDATA[📖 200 웹 개발]]></title><description><![CDATA[웹 개발 관련 학습 내용을 담는 토픽입니다.
<a data-href="📚 201 React" href="99-settings/1-topics/📚-201-react.html" class="internal-link" target="_self" rel="noopener nofollow">📚 201 React</a>
<br><a data-href="📚 202 Vue.js" href="99-settings/1-topics/📚-202-vue.js.html" class="internal-link" target="_self" rel="noopener nofollow">📚 202 Vue.js</a>
<br><a data-href="📚 203 Next.js" href="99-settings/1-topics/📚-203-next.js.html" class="internal-link" target="_self" rel="noopener nofollow">📚 203 Next.js</a>
<br><a data-href="📚 204 Node.js" href="99-settings/1-topics/📚-204-node.js.html" class="internal-link" target="_self" rel="noopener nofollow">📚 204 Node.js</a>
<br><a data-href="📚 205 웹팩 &amp; 빌드" href="99-settings/1-topics/📚-205-웹팩-&amp;-빌드.html" class="internal-link" target="_self" rel="noopener nofollow">📚 205 웹팩 &amp; 빌드</a>
<br><a data-href="📚 206 상태관리" href="99-settings/1-topics/📚-206-상태관리.html" class="internal-link" target="_self" rel="noopener nofollow">📚 206 상태관리</a>
<br><a data-href="📚 207 CSS &amp; 스타일링" href="99-settings/1-topics/📚-207-css-&amp;-스타일링.html" class="internal-link" target="_self" rel="noopener nofollow">📚 207 CSS &amp; 스타일링</a>
<br><a data-href="📚 208 웹 렌더링" href="99-settings/1-topics/📚-208-웹-렌더링.html" class="internal-link" target="_self" rel="noopener nofollow">📚 208 웹 렌더링</a>
<br><a data-href="📚 209 3D 웹" href="99-settings/1-topics/📚-209-3d-웹.html" class="internal-link" target="_self" rel="noopener nofollow">📚 209 3D 웹</a>
<br><a data-href="📚 210 Electron &amp; Tauri" href="99-settings/1-topics/📚-210-electron-&amp;-tauri.html" class="internal-link" target="_self" rel="noopener nofollow">📚 210 Electron &amp; Tauri</a>
]]></description><link>99-settings/1-topics/📖-200-웹-개발.html</link><guid isPermaLink="false">99-Settings/1-Topics/📖 200 웹 개발.md</guid><pubDate>Mon, 08 Sep 2025 14:07:39 GMT</pubDate></item><item><title><![CDATA[📚 102 딥러닝]]></title><description><![CDATA[딥러닝 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 100 데이터 분석 &amp; AI" href="99-settings/1-topics/📖-100-데이터-분석-&amp;-ai.html" class="internal-link" target="_self" rel="noopener nofollow">📖 100 데이터 분석 &amp; AI</a>
]]></description><link>99-settings/1-topics/📚-102-딥러닝.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 102 딥러닝.md</guid><pubDate>Mon, 08 Sep 2025 14:07:39 GMT</pubDate></item><item><title><![CDATA[📖 100 데이터 분석 & AI]]></title><description><![CDATA[데이터 분석과 인공지능 관련 학습 내용을 담는 토픽입니다.
<a data-href="📚 101 머신러닝" href="99-settings/1-topics/📚-101-머신러닝.html" class="internal-link" target="_self" rel="noopener nofollow">📚 101 머신러닝</a>
<br><a data-href="📚 102 딥러닝" href="99-settings/1-topics/📚-102-딥러닝.html" class="internal-link" target="_self" rel="noopener nofollow">📚 102 딥러닝</a>
<br><a data-href="📚 103 데이터 모델링" href="99-settings/1-topics/📚-103-데이터-모델링.html" class="internal-link" target="_self" rel="noopener nofollow">📚 103 데이터 모델링</a>
<br><a data-href="📚 104 통계 분석" href="99-settings/1-topics/📚-104-통계-분석.html" class="internal-link" target="_self" rel="noopener nofollow">📚 104 통계 분석</a>
<br><a data-href="📚 105 캐글" href="99-settings/1-topics/📚-105-캐글.html" class="internal-link" target="_self" rel="noopener nofollow">📚 105 캐글</a>
<br><a data-href="📚 106 LLM &amp; AI" href="99-settings/1-topics/📚-106-llm-&amp;-ai.html" class="internal-link" target="_self" rel="noopener nofollow">📚 106 LLM &amp; AI</a>
<br><a data-href="📚 107 인공신경망" href="99-settings/1-topics/📚-107-인공신경망.html" class="internal-link" target="_self" rel="noopener nofollow">📚 107 인공신경망</a>
<br><a data-href="📚 108 의사결정나무" href="99-settings/1-topics/📚-108-의사결정나무.html" class="internal-link" target="_self" rel="noopener nofollow">📚 108 의사결정나무</a>
<br><a data-href="📚 109 연관성 분석" href="99-settings/1-topics/📚-109-연관성-분석.html" class="internal-link" target="_self" rel="noopener nofollow">📚 109 연관성 분석</a>
]]></description><link>99-settings/1-topics/📖-100-데이터-분석-&amp;-ai.html</link><guid isPermaLink="false">99-Settings/1-Topics/📖 100 데이터 분석 &amp; AI.md</guid><pubDate>Mon, 08 Sep 2025 14:07:39 GMT</pubDate></item><item><title><![CDATA[📖 300 백엔드 개발]]></title><description><![CDATA[백엔드 개발 관련 학습 내용을 담는 토픽입니다.
<a data-href="📚 301 Spring" href="99-settings/1-topics/📚-301-spring.html" class="internal-link" target="_self" rel="noopener nofollow">📚 301 Spring</a>
<br><a data-href="📚 302 Django" href="99-settings/1-topics/📚-302-django.html" class="internal-link" target="_self" rel="noopener nofollow">📚 302 Django</a>
<br><a data-href="📚 303 FastAPI" href="99-settings/1-topics/📚-303-fastapi.html" class="internal-link" target="_self" rel="noopener nofollow">📚 303 FastAPI</a>
<br><a data-href="📚 304 Express.js" href="99-settings/1-topics/📚-304-express.js.html" class="internal-link" target="_self" rel="noopener nofollow">📚 304 Express.js</a>
<br><a data-href="📚 305 데이터베이스" href="99-settings/1-topics/📚-305-데이터베이스.html" class="internal-link" target="_self" rel="noopener nofollow">📚 305 데이터베이스</a>
<br><a data-href="📚 306 API 설계" href="99-settings/1-topics/📚-306-api-설계.html" class="internal-link" target="_self" rel="noopener nofollow">📚 306 API 설계</a>
<br><a data-href="📚 307 인증 &amp; 보안" href="99-settings/1-topics/📚-307-인증-&amp;-보안.html" class="internal-link" target="_self" rel="noopener nofollow">📚 307 인증 &amp; 보안</a>
]]></description><link>99-settings/1-topics/📖-300-백엔드-개발.html</link><guid isPermaLink="false">99-Settings/1-Topics/📖 300 백엔드 개발.md</guid><pubDate>Mon, 08 Sep 2025 14:07:39 GMT</pubDate></item><item><title><![CDATA[📚 401 Docker & Kubernetes]]></title><description><![CDATA[Docker &amp; Kubernetes 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 400 인프라 &amp; 아키텍처" href="99-settings/1-topics/📖-400-인프라-&amp;-아키텍처.html" class="internal-link" target="_self" rel="noopener nofollow">📖 400 인프라 &amp; 아키텍처</a>
]]></description><link>99-settings/1-topics/📚-401-docker-&amp;-kubernetes.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 401 Docker &amp; Kubernetes.md</guid><pubDate>Mon, 08 Sep 2025 14:07:37 GMT</pubDate></item><item><title><![CDATA[📚 202 Vue.js]]></title><description><![CDATA[Vue.js 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 200 웹 개발" href="99-settings/1-topics/📖-200-웹-개발.html" class="internal-link" target="_self" rel="noopener nofollow">📖 200 웹 개발</a>
]]></description><link>99-settings/1-topics/📚-202-vue.js.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 202 Vue.js.md</guid><pubDate>Mon, 08 Sep 2025 14:07:37 GMT</pubDate></item><item><title><![CDATA[📚 501 Flutter]]></title><description><![CDATA[Flutter 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 500 모바일 개발" href="99-settings/1-topics/📖-500-모바일-개발.html" class="internal-link" target="_self" rel="noopener nofollow">📖 500 모바일 개발</a>
]]></description><link>99-settings/1-topics/📚-501-flutter.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 501 Flutter.md</guid><pubDate>Mon, 08 Sep 2025 14:07:37 GMT</pubDate></item><item><title><![CDATA[📚 301 Spring]]></title><description><![CDATA[Spring 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 300 백엔드 개발" href="99-settings/1-topics/📖-300-백엔드-개발.html" class="internal-link" target="_self" rel="noopener nofollow">📖 300 백엔드 개발</a>
]]></description><link>99-settings/1-topics/📚-301-spring.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 301 Spring.md</guid><pubDate>Mon, 08 Sep 2025 14:07:37 GMT</pubDate></item><item><title><![CDATA[📚 302 Django]]></title><description><![CDATA[Django 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 300 백엔드 개발" href="99-settings/1-topics/📖-300-백엔드-개발.html" class="internal-link" target="_self" rel="noopener nofollow">📖 300 백엔드 개발</a>
]]></description><link>99-settings/1-topics/📚-302-django.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 302 Django.md</guid><pubDate>Mon, 08 Sep 2025 14:07:37 GMT</pubDate></item><item><title><![CDATA[📚 101 머신러닝]]></title><description><![CDATA[머신러닝 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 100 데이터 분석 &amp; AI" href="99-settings/1-topics/📖-100-데이터-분석-&amp;-ai.html" class="internal-link" target="_self" rel="noopener nofollow">📖 100 데이터 분석 &amp; AI</a>
]]></description><link>99-settings/1-topics/📚-101-머신러닝.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 101 머신러닝.md</guid><pubDate>Mon, 08 Sep 2025 14:07:37 GMT</pubDate></item><item><title><![CDATA[📖 700 컴퓨터 과학]]></title><description><![CDATA[컴퓨터 과학 관련 학습 내용을 담는 토픽입니다.
<a data-href="📚 701 디자인패턴" href="99-settings/1-topics/📚-701-디자인패턴.html" class="internal-link" target="_self" rel="noopener nofollow">📚 701 디자인패턴</a>
<br><a data-href="📚 702 네트워크" href="99-settings/1-topics/📚-702-네트워크.html" class="internal-link" target="_self" rel="noopener nofollow">📚 702 네트워크</a>
<br><a data-href="📚 703 데이터베이스" href="99-settings/1-topics/📚-703-데이터베이스.html" class="internal-link" target="_self" rel="noopener nofollow">📚 703 데이터베이스</a>
<br><a data-href="📚 704 운영체제" href="99-settings/1-topics/📚-704-운영체제.html" class="internal-link" target="_self" rel="noopener nofollow">📚 704 운영체제</a>
<br><a data-href="📚 705 보안" href="99-settings/1-topics/📚-705-보안.html" class="internal-link" target="_self" rel="noopener nofollow">📚 705 보안</a>
<br><a data-href="📚 706 시스템 설계" href="99-settings/1-topics/📚-706-시스템-설계.html" class="internal-link" target="_self" rel="noopener nofollow">📚 706 시스템 설계</a>
]]></description><link>99-settings/1-topics/📖-700-컴퓨터-과학.html</link><guid isPermaLink="false">99-Settings/1-Topics/📖 700 컴퓨터 과학.md</guid><pubDate>Mon, 08 Sep 2025 14:07:37 GMT</pubDate></item><item><title><![CDATA[📚 201 React]]></title><description><![CDATA[React 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 200 웹 개발" href="99-settings/1-topics/📖-200-웹-개발.html" class="internal-link" target="_self" rel="noopener nofollow">📖 200 웹 개발</a>
]]></description><link>99-settings/1-topics/📚-201-react.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 201 React.md</guid><pubDate>Mon, 08 Sep 2025 14:07:37 GMT</pubDate></item><item><title><![CDATA[📖 500 모바일 개발]]></title><description><![CDATA[모바일 개발 관련 학습 내용을 담는 토픽입니다.
<a data-href="📚 501 Flutter" href="99-settings/1-topics/📚-501-flutter.html" class="internal-link" target="_self" rel="noopener nofollow">📚 501 Flutter</a>
<br><a data-href="📚 502 Android" href="99-settings/1-topics/📚-502-android.html" class="internal-link" target="_self" rel="noopener nofollow">📚 502 Android</a>
<br><a data-href="📚 503 Dart" href="99-settings/1-topics/📚-503-dart.html" class="internal-link" target="_self" rel="noopener nofollow">📚 503 Dart</a>
<br><a data-href="📚 504 Riverpod" href="99-settings/1-topics/📚-504-riverpod.html" class="internal-link" target="_self" rel="noopener nofollow">📚 504 Riverpod</a>
<br><a data-href="📚 505 상태관리" href="99-settings/1-topics/📚-505-상태관리.html" class="internal-link" target="_self" rel="noopener nofollow">📚 505 상태관리</a>
<br><a data-href="📚 506 네트워킹" href="99-settings/1-topics/📚-506-네트워킹.html" class="internal-link" target="_self" rel="noopener nofollow">📚 506 네트워킹</a>
<br><a data-href="📚 507 빌드 &amp; 배포" href="99-settings/1-topics/📚-507-빌드-&amp;-배포.html" class="internal-link" target="_self" rel="noopener nofollow">📚 507 빌드 &amp; 배포</a>
]]></description><link>99-settings/1-topics/📖-500-모바일-개발.html</link><guid isPermaLink="false">99-Settings/1-Topics/📖 500 모바일 개발.md</guid><pubDate>Mon, 08 Sep 2025 14:07:37 GMT</pubDate></item><item><title><![CDATA[🏷️ 에러 해결]]></title><description><![CDATA[Error solving related contents]]></description><link>99-settings/2-index/🏷️-에러-해결.html</link><guid isPermaLink="false">99-Settings/2-Index/🏷️ 에러 해결.md</guid><pubDate>Mon, 08 Sep 2025 14:07:30 GMT</pubDate></item><item><title><![CDATA[🏷️ 회사]]></title><description><![CDATA[Company work related contents]]></description><link>99-settings/2-index/🏷️-회사.html</link><guid isPermaLink="false">99-Settings/2-Index/🏷️ 회사.md</guid><pubDate>Mon, 08 Sep 2025 14:07:30 GMT</pubDate></item><item><title><![CDATA[🏷️ 데일리 노트]]></title><description><![CDATA[Daily note related contents]]></description><link>99-settings/2-index/🏷️-데일리-노트.html</link><guid isPermaLink="false">99-Settings/2-Index/🏷️ 데일리 노트.md</guid><pubDate>Mon, 08 Sep 2025 14:07:30 GMT</pubDate></item><item><title><![CDATA[🏷️ 최적화]]></title><description><![CDATA[성능 최적화, 코드 최적화, 시스템 최적화 관련 내용]]></description><link>99-settings/2-index/🏷️-최적화.html</link><guid isPermaLink="false">99-Settings/2-Index/🏷️ 최적화.md</guid><pubDate>Mon, 08 Sep 2025 14:07:30 GMT</pubDate></item><item><title><![CDATA[🏷️ 학습]]></title><description><![CDATA[개발 학습 과정, 강의, 튜토리얼, 실습 등]]></description><link>99-settings/2-index/🏷️-학습.html</link><guid isPermaLink="false">99-Settings/2-Index/🏷️ 학습.md</guid><pubDate>Mon, 08 Sep 2025 14:07:30 GMT</pubDate></item><item><title><![CDATA[🏷️ 리뷰]]></title><description><![CDATA[코드 리뷰, 기술 리뷰, 도서 리뷰 등]]></description><link>99-settings/2-index/🏷️-리뷰.html</link><guid isPermaLink="false">99-Settings/2-Index/🏷️ 리뷰.md</guid><pubDate>Mon, 08 Sep 2025 14:07:30 GMT</pubDate></item><item><title><![CDATA[🏷️ 프로젝트]]></title><description><![CDATA[Project related contents (사이드 프로젝트, 블로그, 오픈소스 등)]]></description><link>99-settings/2-index/🏷️-프로젝트.html</link><guid isPermaLink="false">99-Settings/2-Index/🏷️ 프로젝트.md</guid><pubDate>Mon, 08 Sep 2025 14:07:30 GMT</pubDate></item><item><title><![CDATA[🏷️ TODO]]></title><description><![CDATA[할 일 관리 및 작업 계획 관련 내용]]></description><link>99-settings/2-index/🏷️-todo.html</link><guid isPermaLink="false">99-Settings/2-Index/🏷️ TODO.md</guid><pubDate>Mon, 08 Sep 2025 14:07:30 GMT</pubDate></item><item><title><![CDATA[🏷️ 도구]]></title><description><![CDATA[개발 도구, IDE, 라이브러리, 프레임워크 사용법 등]]></description><link>99-settings/2-index/🏷️-도구.html</link><guid isPermaLink="false">99-Settings/2-Index/🏷️ 도구.md</guid><pubDate>Mon, 08 Sep 2025 14:07:30 GMT</pubDate></item><item><title><![CDATA[🏷️ 취업]]></title><description><![CDATA[Job hunting related contents (면접, 자기소개서, 프로젝트 분석 등)]]></description><link>99-settings/2-index/🏷️-취업.html</link><guid isPermaLink="false">99-Settings/2-Index/🏷️ 취업.md</guid><pubDate>Mon, 08 Sep 2025 14:07:30 GMT</pubDate></item><item><title><![CDATA[🏷️ 자격증]]></title><description><![CDATA[Certificate related contents (빅분기, SQLD, ADSP, DA 등)]]></description><link>99-settings/2-index/🏷️-자격증.html</link><guid isPermaLink="false">99-Settings/2-Index/🏷️ 자격증.md</guid><pubDate>Mon, 08 Sep 2025 14:07:30 GMT</pubDate></item><item><title><![CDATA[📚 108 의사결정나무]]></title><description><![CDATA[의사결정나무 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 100 데이터 분석 &amp; AI" href="99-settings/1-topics/📖-100-데이터-분석-&amp;-ai.html" class="internal-link" target="_self" rel="noopener nofollow">📖 100 데이터 분석 &amp; AI</a>
]]></description><link>99-settings/1-topics/📚-108-의사결정나무.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 108 의사결정나무.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 109 연관성 분석]]></title><description><![CDATA[연관성 분석 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 100 데이터 분석 &amp; AI" href="99-settings/1-topics/📖-100-데이터-분석-&amp;-ai.html" class="internal-link" target="_self" rel="noopener nofollow">📖 100 데이터 분석 &amp; AI</a>
]]></description><link>99-settings/1-topics/📚-109-연관성-분석.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 109 연관성 분석.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 203 Next.js]]></title><description><![CDATA[Next.js 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 200 웹 개발" href="99-settings/1-topics/📖-200-웹-개발.html" class="internal-link" target="_self" rel="noopener nofollow">📖 200 웹 개발</a>
]]></description><link>99-settings/1-topics/📚-203-next.js.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 203 Next.js.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 407 네트워크 & 보안]]></title><description><![CDATA[네트워크 &amp; 보안 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 400 인프라 &amp; 아키텍처" href="99-settings/1-topics/📖-400-인프라-&amp;-아키텍처.html" class="internal-link" target="_self" rel="noopener nofollow">📖 400 인프라 &amp; 아키텍처</a>
]]></description><link>99-settings/1-topics/📚-407-네트워크-&amp;-보안.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 407 네트워크 &amp; 보안.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 602 그리디]]></title><description><![CDATA[그리디 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 600 알고리즘 &amp; 코딩테스트" href="99-settings/1-topics/📖-600-알고리즘-&amp;-코딩테스트.html" class="internal-link" target="_self" rel="noopener nofollow">📖 600 알고리즘 &amp; 코딩테스트</a>
]]></description><link>99-settings/1-topics/📚-602-그리디.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 602 그리디.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 402 AWS & 클라우드]]></title><description><![CDATA[AWS &amp; 클라우드 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 400 인프라 &amp; 아키텍처" href="99-settings/1-topics/📖-400-인프라-&amp;-아키텍처.html" class="internal-link" target="_self" rel="noopener nofollow">📖 400 인프라 &amp; 아키텍처</a>
]]></description><link>99-settings/1-topics/📚-402-aws-&amp;-클라우드.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 402 AWS &amp; 클라우드.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 208 웹 렌더링]]></title><description><![CDATA[웹 렌더링 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 200 웹 개발" href="99-settings/1-topics/📖-200-웹-개발.html" class="internal-link" target="_self" rel="noopener nofollow">📖 200 웹 개발</a>
]]></description><link>99-settings/1-topics/📚-208-웹-렌더링.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 208 웹 렌더링.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 405 모니터링 & 로깅]]></title><description><![CDATA[모니터링 &amp; 로깅 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 400 인프라 &amp; 아키텍처" href="99-settings/1-topics/📖-400-인프라-&amp;-아키텍처.html" class="internal-link" target="_self" rel="noopener nofollow">📖 400 인프라 &amp; 아키텍처</a>
]]></description><link>99-settings/1-topics/📚-405-모니터링-&amp;-로깅.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 405 모니터링 &amp; 로깅.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 207 CSS & 스타일링]]></title><description><![CDATA[CSS &amp; 스타일링 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 200 웹 개발" href="99-settings/1-topics/📖-200-웹-개발.html" class="internal-link" target="_self" rel="noopener nofollow">📖 200 웹 개발</a>
]]></description><link>99-settings/1-topics/📚-207-css-&amp;-스타일링.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 207 CSS &amp; 스타일링.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 304 Express.js]]></title><description><![CDATA[Express.js 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 300 백엔드 개발" href="99-settings/1-topics/📖-300-백엔드-개발.html" class="internal-link" target="_self" rel="noopener nofollow">📖 300 백엔드 개발</a>
]]></description><link>99-settings/1-topics/📚-304-express.js.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 304 Express.js.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 616 Python]]></title><description><![CDATA[Python 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 600 알고리즘 &amp; 코딩테스트" href="99-settings/1-topics/📖-600-알고리즘-&amp;-코딩테스트.html" class="internal-link" target="_self" rel="noopener nofollow">📖 600 알고리즘 &amp; 코딩테스트</a>
]]></description><link>99-settings/1-topics/📚-616-python.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 616 Python.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 702 네트워크]]></title><description><![CDATA[네트워크 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 700 컴퓨터 과학" href="99-settings/1-topics/📖-700-컴퓨터-과학.html" class="internal-link" target="_self" rel="noopener nofollow">📖 700 컴퓨터 과학</a>
]]></description><link>99-settings/1-topics/📚-702-네트워크.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 702 네트워크.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 305 데이터베이스]]></title><description><![CDATA[데이터베이스 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 300 백엔드 개발" href="99-settings/1-topics/📖-300-백엔드-개발.html" class="internal-link" target="_self" rel="noopener nofollow">📖 300 백엔드 개발</a>
]]></description><link>99-settings/1-topics/📚-305-데이터베이스.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 305 데이터베이스.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 408 스케일링]]></title><description><![CDATA[스케일링 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 400 인프라 &amp; 아키텍처" href="99-settings/1-topics/📖-400-인프라-&amp;-아키텍처.html" class="internal-link" target="_self" rel="noopener nofollow">📖 400 인프라 &amp; 아키텍처</a>
]]></description><link>99-settings/1-topics/📚-408-스케일링.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 408 스케일링.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 404 마이크로서비스]]></title><description><![CDATA[마이크로서비스 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 400 인프라 &amp; 아키텍처" href="99-settings/1-topics/📖-400-인프라-&amp;-아키텍처.html" class="internal-link" target="_self" rel="noopener nofollow">📖 400 인프라 &amp; 아키텍처</a>
]]></description><link>99-settings/1-topics/📚-404-마이크로서비스.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 404 마이크로서비스.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 205 웹팩 & 빌드]]></title><description><![CDATA[웹팩 &amp; 빌드 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 200 웹 개발" href="99-settings/1-topics/📖-200-웹-개발.html" class="internal-link" target="_self" rel="noopener nofollow">📖 200 웹 개발</a>
]]></description><link>99-settings/1-topics/📚-205-웹팩-&amp;-빌드.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 205 웹팩 &amp; 빌드.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 703 데이터베이스]]></title><description><![CDATA[데이터베이스 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 700 컴퓨터 과학" href="99-settings/1-topics/📖-700-컴퓨터-과학.html" class="internal-link" target="_self" rel="noopener nofollow">📖 700 컴퓨터 과학</a>
]]></description><link>99-settings/1-topics/📚-703-데이터베이스.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 703 데이터베이스.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 612 최소신장트리]]></title><description><![CDATA[최소신장트리 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 600 알고리즘 &amp; 코딩테스트" href="99-settings/1-topics/📖-600-알고리즘-&amp;-코딩테스트.html" class="internal-link" target="_self" rel="noopener nofollow">📖 600 알고리즘 &amp; 코딩테스트</a>
]]></description><link>99-settings/1-topics/📚-612-최소신장트리.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 612 최소신장트리.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 611 정렬]]></title><description><![CDATA[정렬 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 600 알고리즘 &amp; 코딩테스트" href="99-settings/1-topics/📖-600-알고리즘-&amp;-코딩테스트.html" class="internal-link" target="_self" rel="noopener nofollow">📖 600 알고리즘 &amp; 코딩테스트</a>
]]></description><link>99-settings/1-topics/📚-611-정렬.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 611 정렬.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 603 다이나믹프로그래밍]]></title><description><![CDATA[다이나믹프로그래밍 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 600 알고리즘 &amp; 코딩테스트" href="99-settings/1-topics/📖-600-알고리즘-&amp;-코딩테스트.html" class="internal-link" target="_self" rel="noopener nofollow">📖 600 알고리즘 &amp; 코딩테스트</a>
]]></description><link>99-settings/1-topics/📚-603-다이나믹프로그래밍.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 603 다이나믹프로그래밍.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 106 LLM & AI]]></title><description><![CDATA[LLM &amp; AI 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 100 데이터 분석 &amp; AI" href="99-settings/1-topics/📖-100-데이터-분석-&amp;-ai.html" class="internal-link" target="_self" rel="noopener nofollow">📖 100 데이터 분석 &amp; AI</a>
]]></description><link>99-settings/1-topics/📚-106-llm-&amp;-ai.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 106 LLM &amp; AI.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 610 이진탐색]]></title><description><![CDATA[이진탐색 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 600 알고리즘 &amp; 코딩테스트" href="99-settings/1-topics/📖-600-알고리즘-&amp;-코딩테스트.html" class="internal-link" target="_self" rel="noopener nofollow">📖 600 알고리즘 &amp; 코딩테스트</a>
]]></description><link>99-settings/1-topics/📚-610-이진탐색.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 610 이진탐색.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 103 데이터 모델링]]></title><description><![CDATA[데이터 모델링 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 100 데이터 분석 &amp; AI" href="99-settings/1-topics/📖-100-데이터-분석-&amp;-ai.html" class="internal-link" target="_self" rel="noopener nofollow">📖 100 데이터 분석 &amp; AI</a>
]]></description><link>99-settings/1-topics/📚-103-데이터-모델링.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 103 데이터 모델링.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 104 통계 분석]]></title><description><![CDATA[통계 분석 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 100 데이터 분석 &amp; AI" href="99-settings/1-topics/📖-100-데이터-분석-&amp;-ai.html" class="internal-link" target="_self" rel="noopener nofollow">📖 100 데이터 분석 &amp; AI</a>
]]></description><link>99-settings/1-topics/📚-104-통계-분석.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 104 통계 분석.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 105 캐글]]></title><description><![CDATA[캐글 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 100 데이터 분석 &amp; AI" href="99-settings/1-topics/📖-100-데이터-분석-&amp;-ai.html" class="internal-link" target="_self" rel="noopener nofollow">📖 100 데이터 분석 &amp; AI</a>
]]></description><link>99-settings/1-topics/📚-105-캐글.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 105 캐글.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 608 위상정렬]]></title><description><![CDATA[위상정렬 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 600 알고리즘 &amp; 코딩테스트" href="99-settings/1-topics/📖-600-알고리즘-&amp;-코딩테스트.html" class="internal-link" target="_self" rel="noopener nofollow">📖 600 알고리즘 &amp; 코딩테스트</a>
]]></description><link>99-settings/1-topics/📚-608-위상정렬.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 608 위상정렬.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 701 디자인패턴]]></title><description><![CDATA[디자인패턴 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 700 컴퓨터 과학" href="99-settings/1-topics/📖-700-컴퓨터-과학.html" class="internal-link" target="_self" rel="noopener nofollow">📖 700 컴퓨터 과학</a>
]]></description><link>99-settings/1-topics/📚-701-디자인패턴.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 701 디자인패턴.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 607 슬라이딩윈도우]]></title><description><![CDATA[슬라이딩윈도우 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 600 알고리즘 &amp; 코딩테스트" href="99-settings/1-topics/📖-600-알고리즘-&amp;-코딩테스트.html" class="internal-link" target="_self" rel="noopener nofollow">📖 600 알고리즘 &amp; 코딩테스트</a>
]]></description><link>99-settings/1-topics/📚-607-슬라이딩윈도우.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 607 슬라이딩윈도우.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 204 Node.js]]></title><description><![CDATA[Node.js 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 200 웹 개발" href="99-settings/1-topics/📖-200-웹-개발.html" class="internal-link" target="_self" rel="noopener nofollow">📖 200 웹 개발</a>
]]></description><link>99-settings/1-topics/📚-204-node.js.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 204 Node.js.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 706 시스템 설계]]></title><description><![CDATA[시스템 설계 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 700 컴퓨터 과학" href="99-settings/1-topics/📖-700-컴퓨터-과학.html" class="internal-link" target="_self" rel="noopener nofollow">📖 700 컴퓨터 과학</a>
]]></description><link>99-settings/1-topics/📚-706-시스템-설계.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 706 시스템 설계.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 506 네트워킹]]></title><description><![CDATA[모바일 네트워킹 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 500 모바일 개발" href="99-settings/1-topics/📖-500-모바일-개발.html" class="internal-link" target="_self" rel="noopener nofollow">📖 500 모바일 개발</a>
]]></description><link>99-settings/1-topics/📚-506-네트워킹.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 506 네트워킹.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 303 FastAPI]]></title><description><![CDATA[FastAPI 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 300 백엔드 개발" href="99-settings/1-topics/📖-300-백엔드-개발.html" class="internal-link" target="_self" rel="noopener nofollow">📖 300 백엔드 개발</a>
]]></description><link>99-settings/1-topics/📚-303-fastapi.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 303 FastAPI.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 503 Dart]]></title><description><![CDATA[Dart 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 500 모바일 개발" href="99-settings/1-topics/📖-500-모바일-개발.html" class="internal-link" target="_self" rel="noopener nofollow">📖 500 모바일 개발</a>
]]></description><link>99-settings/1-topics/📚-503-dart.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 503 Dart.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 604 최단경로]]></title><description><![CDATA[최단경로 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 600 알고리즘 &amp; 코딩테스트" href="99-settings/1-topics/📖-600-알고리즘-&amp;-코딩테스트.html" class="internal-link" target="_self" rel="noopener nofollow">📖 600 알고리즘 &amp; 코딩테스트</a>
]]></description><link>99-settings/1-topics/📚-604-최단경로.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 604 최단경로.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 609 유니온파인드]]></title><description><![CDATA[유니온파인드 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 600 알고리즘 &amp; 코딩테스트" href="99-settings/1-topics/📖-600-알고리즘-&amp;-코딩테스트.html" class="internal-link" target="_self" rel="noopener nofollow">📖 600 알고리즘 &amp; 코딩테스트</a>
]]></description><link>99-settings/1-topics/📚-609-유니온파인드.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 609 유니온파인드.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 206 상태관리]]></title><description><![CDATA[상태관리 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 200 웹 개발" href="99-settings/1-topics/📖-200-웹-개발.html" class="internal-link" target="_self" rel="noopener nofollow">📖 200 웹 개발</a>
]]></description><link>99-settings/1-topics/📚-206-상태관리.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 206 상태관리.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 209 3D 웹]]></title><description><![CDATA[3D 웹 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 200 웹 개발" href="99-settings/1-topics/📖-200-웹-개발.html" class="internal-link" target="_self" rel="noopener nofollow">📖 200 웹 개발</a>
]]></description><link>99-settings/1-topics/📚-209-3d-웹.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 209 3D 웹.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 505 상태관리]]></title><description><![CDATA[모바일 상태관리 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 500 모바일 개발" href="99-settings/1-topics/📖-500-모바일-개발.html" class="internal-link" target="_self" rel="noopener nofollow">📖 500 모바일 개발</a>
]]></description><link>99-settings/1-topics/📚-505-상태관리.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 505 상태관리.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 606 세그먼트트리]]></title><description><![CDATA[세그먼트트리 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 600 알고리즘 &amp; 코딩테스트" href="99-settings/1-topics/📖-600-알고리즘-&amp;-코딩테스트.html" class="internal-link" target="_self" rel="noopener nofollow">📖 600 알고리즘 &amp; 코딩테스트</a>
]]></description><link>99-settings/1-topics/📚-606-세그먼트트리.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 606 세그먼트트리.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 614 그래프]]></title><description><![CDATA[그래프 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 600 알고리즘 &amp; 코딩테스트" href="99-settings/1-topics/📖-600-알고리즘-&amp;-코딩테스트.html" class="internal-link" target="_self" rel="noopener nofollow">📖 600 알고리즘 &amp; 코딩테스트</a>
]]></description><link>99-settings/1-topics/📚-614-그래프.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 614 그래프.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 605 비트연산 & 비트마스킹]]></title><description><![CDATA[비트연산 &amp; 비트마스킹 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 600 알고리즘 &amp; 코딩테스트" href="99-settings/1-topics/📖-600-알고리즘-&amp;-코딩테스트.html" class="internal-link" target="_self" rel="noopener nofollow">📖 600 알고리즘 &amp; 코딩테스트</a>
]]></description><link>99-settings/1-topics/📚-605-비트연산-&amp;-비트마스킹.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 605 비트연산 &amp; 비트마스킹.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 507 빌드 & 배포]]></title><description><![CDATA[모바일 빌드 &amp; 배포 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 500 모바일 개발" href="99-settings/1-topics/📖-500-모바일-개발.html" class="internal-link" target="_self" rel="noopener nofollow">📖 500 모바일 개발</a>
]]></description><link>99-settings/1-topics/📚-507-빌드-&amp;-배포.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 507 빌드 &amp; 배포.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 107 인공신경망]]></title><description><![CDATA[인공신경망 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 100 데이터 분석 &amp; AI" href="99-settings/1-topics/📖-100-데이터-분석-&amp;-ai.html" class="internal-link" target="_self" rel="noopener nofollow">📖 100 데이터 분석 &amp; AI</a>
]]></description><link>99-settings/1-topics/📚-107-인공신경망.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 107 인공신경망.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 601 구현 & 완전탐색]]></title><description><![CDATA[구현 &amp; 완전탐색 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 600 알고리즘 &amp; 코딩테스트" href="99-settings/1-topics/📖-600-알고리즘-&amp;-코딩테스트.html" class="internal-link" target="_self" rel="noopener nofollow">📖 600 알고리즘 &amp; 코딩테스트</a>
]]></description><link>99-settings/1-topics/📚-601-구현-&amp;-완전탐색.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 601 구현 &amp; 완전탐색.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 617 Java]]></title><description><![CDATA[Java 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 600 알고리즘 &amp; 코딩테스트" href="99-settings/1-topics/📖-600-알고리즘-&amp;-코딩테스트.html" class="internal-link" target="_self" rel="noopener nofollow">📖 600 알고리즘 &amp; 코딩테스트</a>
]]></description><link>99-settings/1-topics/📚-617-java.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 617 Java.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 502 Android]]></title><description><![CDATA[Android 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 500 모바일 개발" href="99-settings/1-topics/📖-500-모바일-개발.html" class="internal-link" target="_self" rel="noopener nofollow">📖 500 모바일 개발</a>
]]></description><link>99-settings/1-topics/📚-502-android.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 502 Android.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 210 Electron & Tauri]]></title><description><![CDATA[Electron &amp; Tauri 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 200 웹 개발" href="99-settings/1-topics/📖-200-웹-개발.html" class="internal-link" target="_self" rel="noopener nofollow">📖 200 웹 개발</a>
]]></description><link>99-settings/1-topics/📚-210-electron-&amp;-tauri.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 210 Electron &amp; Tauri.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 306 API 설계]]></title><description><![CDATA[API 설계 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 300 백엔드 개발" href="99-settings/1-topics/📖-300-백엔드-개발.html" class="internal-link" target="_self" rel="noopener nofollow">📖 300 백엔드 개발</a>
]]></description><link>99-settings/1-topics/📚-306-api-설계.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 306 API 설계.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 403 시스템 설계]]></title><description><![CDATA[시스템 설계 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 400 인프라 &amp; 아키텍처" href="99-settings/1-topics/📖-400-인프라-&amp;-아키텍처.html" class="internal-link" target="_self" rel="noopener nofollow">📖 400 인프라 &amp; 아키텍처</a>
]]></description><link>99-settings/1-topics/📚-403-시스템-설계.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 403 시스템 설계.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 307 인증 & 보안]]></title><description><![CDATA[인증 &amp; 보안 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 300 백엔드 개발" href="99-settings/1-topics/📖-300-백엔드-개발.html" class="internal-link" target="_self" rel="noopener nofollow">📖 300 백엔드 개발</a>
]]></description><link>99-settings/1-topics/📚-307-인증-&amp;-보안.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 307 인증 &amp; 보안.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 504 Riverpod]]></title><description><![CDATA[Riverpod 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 500 모바일 개발" href="99-settings/1-topics/📖-500-모바일-개발.html" class="internal-link" target="_self" rel="noopener nofollow">📖 500 모바일 개발</a>
]]></description><link>99-settings/1-topics/📚-504-riverpod.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 504 Riverpod.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 406 CI-CD]]></title><description><![CDATA[CI/CD 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 400 인프라 &amp; 아키텍처" href="99-settings/1-topics/📖-400-인프라-&amp;-아키텍처.html" class="internal-link" target="_self" rel="noopener nofollow">📖 400 인프라 &amp; 아키텍처</a>
]]></description><link>99-settings/1-topics/📚-406-ci-cd.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 406 CI-CD.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 613 BFS & DFS]]></title><description><![CDATA[BFS &amp; DFS 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 600 알고리즘 &amp; 코딩테스트" href="99-settings/1-topics/📖-600-알고리즘-&amp;-코딩테스트.html" class="internal-link" target="_self" rel="noopener nofollow">📖 600 알고리즘 &amp; 코딩테스트</a>
]]></description><link>99-settings/1-topics/📚-613-bfs-&amp;-dfs.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 613 BFS &amp; DFS.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[📚 704 운영체제]]></title><description><![CDATA[운영체제 관련 학습 내용을 담는 토픽입니다.
<a data-href="📖 700 컴퓨터 과학" href="99-settings/1-topics/📖-700-컴퓨터-과학.html" class="internal-link" target="_self" rel="noopener nofollow">📖 700 컴퓨터 과학</a>
]]></description><link>99-settings/1-topics/📚-704-운영체제.html</link><guid isPermaLink="false">99-Settings/1-Topics/📚 704 운영체제.md</guid><pubDate>Mon, 08 Sep 2025 14:07:26 GMT</pubDate></item><item><title><![CDATA[nodejs nginx vite tomcat]]></title><description><![CDATA[ Nginx가 들어온 요청을 Node.js 서버로 전달(프록시)하는 구조이지,
Nginx가 Node.js 위에서 돌아가는 것은 아닙니다 따라서 nginx는 독립적으로 실행 가능함 정적 파일 서비스에는nginx으로만으로도 충분함 정적 웹사이트: Nginx만으로 충분히 서버를 띄우고 서비스할 수 있습니다. 동적 웹사이트: Nginx는 프록시 또는 로드밸런서 역할을 하고, 실제 동적 처리는 별도의 백엔드 서버가 담당합니다. 프론트엔드 개발 서버: 개발 중에 빠른 HMR(Hot Module Replacement)과 모듈 제공을 위해 Node.js 기반의 개발 서버를 띄웁니다.
번들러: 프로덕션(배포) 시에는 소스 코드를 최적화된 정적 파일로 번들링합니다.
Node.js 필요: Vite 자체는 Node.js 환경에서 실행되므로, Vite를 사용하려면 시스템에 Node.js가 설치되어 있어야 합니다<a data-tooltip-position="top" aria-label="https://josephine10.hashnode.dev/difference-between-vite-nodejs-and-solidjs" rel="noopener nofollow" class="external-link is-unresolved" href="https://josephine10.hashnode.dev/difference-between-vite-nodejs-and-solidjs" target="_self">2</a><a data-tooltip-position="top" aria-label="https://vite.dev/guide/features" rel="noopener nofollow" class="external-link is-unresolved" href="https://vite.dev/guide/features" target="_self">4</a>.
<br>Vite는 개발 서버를 내장하고 있으며, 개발 중에 소스 파일을 브라우저에 바로 제공하고, 코드 변경 시 실시간으로 반영하는(HMR) 기능을 제공합니다<a data-tooltip-position="top" aria-label="https://ko.vite.dev/guide/" rel="noopener nofollow" class="external-link is-unresolved" href="https://ko.vite.dev/guide/" target="_self">1</a><a data-tooltip-position="top" aria-label="https://bo5mi.tistory.com/265" rel="noopener nofollow" class="external-link is-unresolved" href="https://bo5mi.tistory.com/265" target="_self">2</a><a data-tooltip-position="top" aria-label="https://1ilsang.dev/posts/vite-dev-server" rel="noopener nofollow" class="external-link is-unresolved" href="https://1ilsang.dev/posts/vite-dev-server" target="_self">3</a><a data-tooltip-position="top" aria-label="https://velog.io/@joeyoungmin/vite" rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@joeyoungmin/vite" target="_self">4</a><a data-tooltip-position="top" aria-label="https://js-web.tistory.com/29" rel="noopener nofollow" class="external-link is-unresolved" href="https://js-web.tistory.com/29" target="_self">5</a><a data-tooltip-position="top" aria-label="https://blog.naver.com/eirene100999/223529479819?recommendTrackingCode=2" rel="noopener nofollow" class="external-link is-unresolved" href="https://blog.naver.com/eirene100999/223529479819?recommendTrackingCode=2" target="_self">8</a><a data-tooltip-position="top" aria-label="https://blog.hectodata.co.kr/bonjour-vite/" rel="noopener nofollow" class="external-link is-unresolved" href="https://blog.hectodata.co.kr/bonjour-vite/" target="_self">9</a>. <br>공식 문서와 여러 자료에서 Vite의 주요 기능으로&nbsp;"개발 서버" 제공을 명확히 언급하고 있습니다. "Vite(프랑스어로 '빠르다')는 빠르고 간결한 모던 웹 프로젝트 개발 경험에 초점을 맞춰 탄생한 빌드 툴입니다. 크게 두 가지 부분으로 구성되어 있습니다: 네이티브 ES 모듈을 통해 소스 파일을 제공하는 개발서버...<a data-tooltip-position="top" aria-label="https://ko.vite.dev/guide/" rel="noopener nofollow" class="external-link is-unresolved" href="https://ko.vite.dev/guide/" target="_self">1</a> <br>Vite를 실행하면 Node.js 기반의 HTTP 서버가 실제로 뜨고, 이 서버가 개발 중에 클라이언트(브라우저)와 통신합니다<a data-tooltip-position="top" aria-label="https://1ilsang.dev/posts/vite-dev-server" rel="noopener nofollow" class="external-link is-unresolved" href="https://1ilsang.dev/posts/vite-dev-server" target="_self">3</a><a data-tooltip-position="top" aria-label="https://js-web.tistory.com/29" rel="noopener nofollow" class="external-link is-unresolved" href="https://js-web.tistory.com/29" target="_self">5</a><a data-tooltip-position="top" aria-label="https://blog.naver.com/eirene100999/223529479819?recommendTrackingCode=2" rel="noopener nofollow" class="external-link is-unresolved" href="https://blog.naver.com/eirene100999/223529479819?recommendTrackingCode=2" target="_self">8</a><a data-tooltip-position="top" aria-label="https://blog.hectodata.co.kr/bonjour-vite/" rel="noopener nofollow" class="external-link is-unresolved" href="https://blog.hectodata.co.kr/bonjour-vite/" target="_self">9</a>. Tomcat은 자바 기반 웹 애플리케이션을 실행하는&nbsp;서블릿 컨테이너(Java Servlet Container)입니다.
주로&nbsp;Java Servlet과 JSP(JavaServer Pages)를 실행하며, Java로 작성된 동적 웹 애플리케이션을 구동합니다.
Tomcat은 HTTP 요청을 받아 Java 코드를 실행하고, 그 결과를 웹 브라우저에 응답합니다.
<br>즉, Tomcat은&nbsp;동적 웹 컨텐츠(예: 로그인, 데이터베이스 연동 등) 처리가 주 목적입니다<a data-tooltip-position="top" aria-label="https://www.logicmonitor.com/blog/what-is-apache-tomcat-server-and-how-does-it-work" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.logicmonitor.com/blog/what-is-apache-tomcat-server-and-how-does-it-work" target="_self">1</a><a data-tooltip-position="top" aria-label="https://www.simplilearn.com/what-is-tomcat-article" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.simplilearn.com/what-is-tomcat-article" target="_self">5</a>.
<br>WAS 내부에서&nbsp;서블릿과 JSP의 생명주기 관리, 요청/응답 처리, 보안, 스레드 관리 등을 담당하는 핵심 컴포넌트입니다<a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Web_container" rel="noopener nofollow" class="external-link is-unresolved" href="https://en.wikipedia.org/wiki/Web_container" target="_self">2</a><a data-tooltip-position="top" aria-label="https://velog.io/@mooh2jj/WAS%EB%8A%94-%EC%84%9C%EB%B8%94%EB%A6%BF-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%ED%8C%8C%ED%97%A4%EC%B9%98%EA%B8%B0" rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@mooh2jj/WAS%EB%8A%94-%EC%84%9C%EB%B8%94%EB%A6%BF-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%ED%8C%8C%ED%97%A4%EC%B9%98%EA%B8%B0" target="_self">3</a><a data-tooltip-position="top" aria-label="https://bny9164.tistory.com/56" rel="noopener nofollow" class="external-link is-unresolved" href="https://bny9164.tistory.com/56" target="_self">4</a><a data-tooltip-position="top" aria-label="https://m42-orion.tistory.com/157" rel="noopener nofollow" class="external-link is-unresolved" href="https://m42-orion.tistory.com/157" target="_self">5</a>. 즉,&nbsp;Java Servlet/JSP 등 웹 컴포넌트의 실행 환경을 제공하는 부분입니다.
WAS는 서블릿 컨테이너를 반드시 포함하고 있습니다.
]]></description><link>200-웹개발/nodejs-nginx-vite-tomcat.html</link><guid isPermaLink="false">200-웹개발/nodejs nginx vite tomcat.md</guid><pubDate>Tue, 12 Aug 2025 03:44:45 GMT</pubDate></item><item><title><![CDATA[시ㄹ행과정]]></title><description><![CDATA[docker-compose up -d
여러 컨테이너를 각각의 이미지로 만들고,
한 번의 명령으로 모두 실행 및 관리할 수 있다는 뜻이 맞습니다.
docker-compose stop
정지
authidentity/src/main/java/aivle/
├── domain/ # 도메인 계층
│ ├── entity/ # 엔티티
│ ├── repository/ # 리포지토리
│ ├── command/ # 커맨드
│ ├── event/ # 이벤트
│ └── valueobject/ # 값 객체
└── infra/ # 인프라 계층 ├── controller/ # 컨트롤러 ├── processor/ # 프로세서 ├── event/ # 이벤트 └── policy/ # 정
docker exec kafka kafka-console-consumer --bootstrap-server localhost:9092 --topic aivle --from-beginningkafka-topics.sh --delete --zookeeper zookeeper:2181 --topic aivledocker exec kafka kafka-topics --bootstrap-server localhost:9092 --delete --topic aivledocker exec kafka kafka-topics --create --bootstrap-server localhost:9092 --topic aivle --partitions 1 --replication-factor 1카프카컨테이너에 들어가기
도커아이디확인
docker ps
docker exec -it 40cb1c7184b2 /bin/bash
kafka라는 이름의 Docker 컨테이너 안에서, kafka-console-consumer 명령을 실행하여 localhost:9092에 있는 Kafka 클러스터의 aivle 토픽에 저장된 메시지를 처음부터 모두 읽어서 출력하라.
cd infra
docker-compose up -d
각 서비스별로 개별 실행하거나, 전체를 한번에 실행:개별 실행:# 각 서비스 디렉토리에서
cd admintask
mvn spring-boot:run cd ../monthlysubscriptionmanagement mvn spring-boot:run # ... 나머지 서비스들도 동일
전체 한번에 실행:docker-compose -f build-docker-compose.yml up
cd gateway
mvn spring-boot:run
cd frontend
npm install
npm run serve Gateway: 8088
각 마이크로서비스: 8082~8091
Kafka: 9092
프론트엔드: 8080 (기본)
정의된 곳:
README.md - 전체 실행 가이드
infra/docker-compose.yml - Kafka 설정
build-docker-compose.yml - 전체 서비스 Docker 실행 설정
init.sh - 초기 설정 스크립트
가장 간단한 방법은 build-docker-compose.yml로 전체 실행하는 거야.공통 패턴: repository().saveAndFlush(this)&nbsp;- 저장과 동시에 flush 저장된 엔티티를 변수에 할당 (id가 설정된 객체) 저장된 엔티티로 이벤트 생성 이렇게 하면 모든 엔티티에서&nbsp;id가 제대로 설정된 후에 이벤트가 생성되어&nbsp;JSON에 모든 필드가 포함됩니다.flush전에 실행해서<a rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@codren/JPA-save-%EC%99%80-saveAndFlush-%EC%9D%98-%EC%B0%A8%EC%9D%B4" target="_self">https://velog.io/@codren/JPA-save-%EC%99%80-saveAndFlush-%EC%9D%98-%EC%B0%A8%EC%9D%B4</a>애네 pubsub구현을 내가아는 pubsub패턴으로구현하는ㄴ지 찾아봐야겟다이 saveandflush가 디폴트가되어야하지않냐롬복지우고다시실행하면됨ㅋ왜? 실화임??말안되네그냥 X-는&nbsp;비표준 헤더를 나타내는 표준 RFC 6648에서 정의된 관례 표준 HTTP 헤더와 구분하기 위함 보통 Gateway의 config 부분에서는 이런 것들을 설정해:// JWT 설정
@Value("${jwt.secret}")
private String jwtSecret; @Value("${jwt.expiration}")
private Long jwtExpiration; // 보안 경로 설정
@Value("${security.protected-paths}")
private List&lt;String&gt; protectedPaths; // CORS 설정
@Value("${cors.allowed-origins}")
private List&lt;String&gt; allowedOrigins;
// 서비스 디스커버리 설정
@Value("${eureka.client.service-url.defaultZone}")
private String eurekaUrl; // 로드밸런서 설정
@Value("${ribbon.ConnectTimeout}")
private Integer connectTimeout;
// 로그 레벨
@Value("${logging.level.gateway}")
private String logLevel; // 메트릭 설정
@Value("${management.endpoints.web.exposure.include}")
private String metricsEndpoints;
// 타임아웃 설정
@Value("${spring.cloud.gateway.httpclient.connect-timeout}")
private Integer connectTimeout; @Value("${spring.cloud.gateway.httpclient.response-timeout}")
private Integer responseTimeout;
// 필터 순서
@Value("${gateway.filter.order}")
private Integer filterOrder; // 필터 활성화 여부
@Value("${gateway.filter.enabled}")
private Boolean filterEnabled;
// 환경 구분
@Value("${spring.profiles.active}")
private String activeProfile; // 환경별 서비스 URL
@Value("${service.url.${spring.profiles.active}}")
private String serviceUrl;
// SSL/TLS 설정
@Value("${server.ssl.enabled}")
private Boolean sslEnabled; // 헤더 설정
@Value("${gateway.headers.allowed}")
private List&lt;String&gt; allowedHeaders;
// 캐시 설정
@Value("${gateway.cache.enabled}")
private Boolean cacheEnabled; @Value("${gateway.cache.ttl}")
private Integer cacheTtl;
// 레이트 리미터 설정
@Value("${gateway.rate-limit.enabled}")
private Boolean rateLimitEnabled; @Value("${gateway.rate-limit.requests-per-second}")
private Integer requestsPerSecond;
// 서킷브레이커 설정
@Value("${resilience4j.circuitbreaker.enabled}")
private Boolean circuitBreakerEnabled; @Value("${resilience4j.circuitbreaker.failure-rate-threshold}")
private Integer failureRateThreshold;
// 현재 JWT 관련
@Value("${jwt.secret}")
private String jwtSecret; @Value("${security.protected-paths}")
private List&lt;String&gt; protectedPaths; // 추가하면 좋을 것들
@Value("${gateway.timeout.connect:5000}")
private Integer connectTimeout; @Value("${gateway.timeout.read:10000}")
private Integer readTimeout; @Value("${gateway.cors.enabled:true}")
private Boolean corsEnabled; @Value("${gateway.logging.enabled:true}")
private Boolean loggingEnabled;
이런 설정들을 yml 파일에서 관리하면 환경별로 다른 설정을 쉽게 적용할 수 있어!]]></description><link>300-백엔드개발/시ㄹ행과정.html</link><guid isPermaLink="false">300-백엔드개발/시ㄹ행과정.md</guid><pubDate>Mon, 28 Jul 2025 01:42:56 GMT</pubDate></item><item><title><![CDATA[result]]></title><description><![CDATA[릿지, xgbm
feature , 앙상블기준선택feature : features = ['bid_qty', 'volume', 'buy_qty', 'sell_qty','ask_qty','X598', 'X344','X363', 'X405', 'X321', 'X175', 'X179', 'X197', 'X22', 'X181', 'X28', 'X169', 'X198', 'X173', 'X338', 'X587', 'X450', 'X97', 'X52', 'X444', 'X297', 'X138', 'X572', 'X343', 'X438', 'X459', 'X758', 'X25']전체다 &amp; 평균
R2: 0.5544
RMSE: 0.6757
피어슨 상관계수: 0.8200선택 &amp; 평균
R2: 0.4379
RMSE: 0.7589
피어슨 상관계수: 0.7980전체다 &amp; 평균 &amp; 시간순 split선택 &amp; 평균 &amp; 시간순 split]]></description><link>100-데이터분석-&amp;-ai/캐글/result.html</link><guid isPermaLink="false">100-데이터분석 &amp; AI/캐글/result.md</guid><pubDate>Wed, 23 Jul 2025 12:53:47 GMT</pubDate></item><item><title><![CDATA[주식,코인 시계열 데이터 분석에서 Ridge, XGBoost 추천 옵션 및 전략]]></title><description><![CDATA[주식이나 코인 등 시계열(financial time series) 데이터 분석에 Ridge 회귀와 XGBoost, 그리고 이 두 모델의 앙상블을 사용할 때 유용한 옵션과 실전 팁을 정리합니다.
특징 생성 과거 값(lag), 이동평균, 변화율 등 시계열 특성 반영 피처 생성이 중요함. 예: lag_1, lag_7, rolling_mean_5 등 정규화/표준화 Ridge는 가중치 페널티 특성상 표준화(StandardScaler) 필수<a data-tooltip-position="top" aria-label="https://wire.insiderfinance.io/adaptive-time-series-forecasting-with-rolling-ridge-regression-a82f4a718471" rel="noopener nofollow" class="external-link is-unresolved" href="https://wire.insiderfinance.io/adaptive-time-series-forecasting-with-rolling-ridge-regression-a82f4a718471" target="_self">1</a><a data-tooltip-position="top" aria-label="https://abouttrading.substack.com/p/lets-use-ridge-regression-to-predict" rel="noopener nofollow" class="external-link is-unresolved" href="https://abouttrading.substack.com/p/lets-use-ridge-regression-to-predict" target="_self">2</a>. 윈도우 학습(rolling/expanding window) <br>일정 기간의 과거 데이터만으로 반복 학습(rolling window) 권장<a data-tooltip-position="top" aria-label="https://wire.insiderfinance.io/adaptive-time-series-forecasting-with-rolling-ridge-regression-a82f4a718471" rel="noopener nofollow" class="external-link is-unresolved" href="https://wire.insiderfinance.io/adaptive-time-series-forecasting-with-rolling-ridge-regression-a82f4a718471" target="_self">1</a>. 데이터가 시간 흐름에 따라 변화한다면 "online/rolling fitting" 추천. 타깃(종속변수) 분포 주가/코인 수익률(returns)로 예측하는 것이 일반적. 시계열 교차검증 순서 지키는 TimeSeriesSplit 지원. 옵션 예시
alpha(정규화 강도): 옵티마이즈(Tuning) 필요 fit_intercept=True (기본값) solver='auto' 피처 엔지니어링 <br>시계열 데이터를 Supervised Learning 형태(슬라이딩 윈도우, lag, 이동평균 등)로 변환해야 함<a data-tooltip-position="top" aria-label="https://www.machinelearningmastery.com/xgboost-for-time-series-forecasting/" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.machinelearningmastery.com/xgboost-for-time-series-forecasting/" target="_self">3</a><a data-tooltip-position="top" aria-label="https://machinelearningmastery.com/xgboost-for-time-series-forecasting/" rel="noopener nofollow" class="external-link is-unresolved" href="https://machinelearningmastery.com/xgboost-for-time-series-forecasting/" target="_self">4</a><a data-tooltip-position="top" aria-label="https://www.kdnuggets.com/2023/08/leveraging-xgboost-timeseries-forecasting.html" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.kdnuggets.com/2023/08/leveraging-xgboost-timeseries-forecasting.html" target="_self">5</a>. <br>기술적 지표(예: EMA, MACD, RSI 등) 활용 효과적<a data-tooltip-position="top" aria-label="https://arxiv.org/html/2407.11786v1" rel="noopener nofollow" class="external-link is-unresolved" href="https://arxiv.org/html/2407.11786v1" target="_self">6</a>. Objective objective='reg:squarederror' (회귀용, 평균제곱오차 최소화) 시간순서 준수 훈련·검증 데이터 분할시 미래 데이터로 예측하지 않게 순서를 지킬 것 Validation 방식 <br>KFold보다 Walk-Forward Validation(rolling forecast origin) 권장<a data-tooltip-position="top" aria-label="https://machinelearningmastery.com/xgboost-for-time-series-forecasting/" rel="noopener nofollow" class="external-link is-unresolved" href="https://machinelearningmastery.com/xgboost-for-time-series-forecasting/" target="_self">4</a>. 중요 하이퍼파라미터 n_estimators, max_depth, learning_rate, subsample, colsample_bytree, gamma, lambda, alpha 등 과적합 방지 early_stopping_rounds 사용 <br>Regularization(lambda, alpha) 조정<a data-tooltip-position="top" aria-label="https://arxiv.org/html/2407.11786v1" rel="noopener nofollow" class="external-link is-unresolved" href="https://arxiv.org/html/2407.11786v1" target="_self">6</a> Ridge와 XGBoost의 출력 스케일이 다르면 표준화 필요 (Ridge는 표준화된 입력 권장, XGBoost는 중요하지 않지만 맞춰주면 해로울 것 없음) 두 모델 예측값 단순 평균(soft voting) 혹은 가중 평균 동일 특징 파생(같은 피처 엔지니어링 중요) 시간누적 예측 등에서는 첫출력 → 다음 입력 반복 방식(autoregressive)도 고려 <br>Ridge: 경향성(Trend)·선형 특성 추출에 강점<a data-tooltip-position="top" aria-label="https://wire.insiderfinance.io/adaptive-time-series-forecasting-with-rolling-ridge-regression-a82f4a718471" rel="noopener nofollow" class="external-link is-unresolved" href="https://wire.insiderfinance.io/adaptive-time-series-forecasting-with-rolling-ridge-regression-a82f4a718471" target="_self">1</a><a data-tooltip-position="top" aria-label="https://abouttrading.substack.com/p/lets-use-ridge-regression-to-predict" rel="noopener nofollow" class="external-link is-unresolved" href="https://abouttrading.substack.com/p/lets-use-ridge-regression-to-predict" target="_self">2</a> XGBoost: 복잡/비선형 구조·급격한 변동(Spike)에 대응 가능 <br>둘의 앙상블: 장기 트렌드와 단기 변동성을 모두 반영할 수 있어 금융 시계열에 적합<a data-tooltip-position="top" aria-label="https://arxiv.org/html/2506.22055v1" rel="noopener nofollow" class="external-link is-unresolved" href="https://arxiv.org/html/2506.22055v1" target="_self">7</a> <br>검증 방법은 반드시 시간 순서를 지키는 방식(Walk-Forward, Expanding Window) 사용해야 예측 성능이 실제에 가깝게 평가됨<a data-tooltip-position="top" aria-label="https://machinelearningmastery.com/xgboost-for-time-series-forecasting/" rel="noopener nofollow" class="external-link is-unresolved" href="https://machinelearningmastery.com/xgboost-for-time-series-forecasting/" target="_self">4</a>. <br>다양한 기술적 지표 및 외부 요인(뉴스, 거래량 등) 추가 시 성능 향상 가능<a data-tooltip-position="top" aria-label="https://arxiv.org/html/2407.11786v1" rel="noopener nofollow" class="external-link is-unresolved" href="https://arxiv.org/html/2407.11786v1" target="_self">6</a><a data-tooltip-position="top" aria-label="https://dl.acm.org/doi/fullHtml/10.1145/3605423.3605462" rel="noopener nofollow" class="external-link is-unresolved" href="https://dl.acm.org/doi/fullHtml/10.1145/3605423.3605462" target="_self">8</a>. 주가/코인 같이 예측의 난이도가 높은 시계열에서는 feature engineering, 하이퍼파라미터 튜닝, 선형+비선형 모델 앙상블이 모두 중요합니다. <br>XGBoost + LSTM 등 하이브리드 모델, explainable AI 적용 사례도 최근 연구에서 많이 활용되고 있습니다<a data-tooltip-position="top" aria-label="https://arxiv.org/html/2506.22055v1" rel="noopener nofollow" class="external-link is-unresolved" href="https://arxiv.org/html/2506.22055v1" target="_self">7</a>. <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://wire.insiderfinance.io/adaptive-time-series-forecasting-with-rolling-ridge-regression-a82f4a718471" target="_self">https://wire.insiderfinance.io/adaptive-time-series-forecasting-with-rolling-ridge-regression-a82f4a718471</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://abouttrading.substack.com/p/lets-use-ridge-regression-to-predict" target="_self">https://abouttrading.substack.com/p/lets-use-ridge-regression-to-predict</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.machinelearningmastery.com/xgboost-for-time-series-forecasting/" target="_self">https://www.machinelearningmastery.com/xgboost-for-time-series-forecasting/</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://machinelearningmastery.com/xgboost-for-time-series-forecasting/" target="_self">https://machinelearningmastery.com/xgboost-for-time-series-forecasting/</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.kdnuggets.com/2023/08/leveraging-xgboost-timeseries-forecasting.html" target="_self">https://www.kdnuggets.com/2023/08/leveraging-xgboost-timeseries-forecasting.html</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://arxiv.org/html/2407.11786v1" target="_self">https://arxiv.org/html/2407.11786v1</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://arxiv.org/html/2506.22055v1" target="_self">https://arxiv.org/html/2506.22055v1</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://dl.acm.org/doi/fullHtml/10.1145/3605423.3605462" target="_self">https://dl.acm.org/doi/fullHtml/10.1145/3605423.3605462</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://arxiv.org/html/2411.18339v1" target="_self">https://arxiv.org/html/2411.18339v1</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.sciencedirect.com/science/article/pii/S1568494625006544" target="_self">https://www.sciencedirect.com/science/article/pii/S1568494625006544</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/MunjPatel/Adaptive-Time-Series-Forecasting-with-Rolling-Ridge-Regression" target="_self">https://github.com/MunjPatel/Adaptive-Time-Series-Forecasting-with-Rolling-Ridge-Regression</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://elib.bsu.by/bitstream/123456789/306226/1/176-179.pdf" target="_self">https://elib.bsu.by/bitstream/123456789/306226/1/176-179.pdf</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.linkedin.com/posts/sofienkaabar_lets-use-ridge-regression-to-predict-time-activity-7170908443690680320-8ZaC" target="_self">https://www.linkedin.com/posts/sofienkaabar_lets-use-ridge-regression-to-predict-time-activity-7170908443690680320-8ZaC</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.astesj.com/v06/i02/p80/" target="_self">https://www.astesj.com/v06/i02/p80/</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Ridge.html" target="_self">https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Ridge.html</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://cienciadedatos.net/documentos/py56-forecasting-time-series-with-xgboost" target="_self">https://cienciadedatos.net/documentos/py56-forecasting-time-series-with-xgboost</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.ibm.com/think/topics/ridge-regression" target="_self">https://www.ibm.com/think/topics/ridge-regression</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.reddit.com/r/MachineLearning/comments/1aoo7gc/d_how_does_xgboost_work_with_time_series/" target="_self">https://www.reddit.com/r/MachineLearning/comments/1aoo7gc/d_how_does_xgboost_work_with_time_series/</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.mdpi.com/1911-8074/18/2/52" target="_self">https://www.mdpi.com/1911-8074/18/2/52</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://otexts.com/fpp2/regression.html" target="_self">https://otexts.com/fpp2/regression.html</a>
]]></description><link>100-데이터분석-&amp;-ai/캐글/주식,코인-시계열-데이터-분석에서-ridge,-xgboost-추천-옵션-및-전략.html</link><guid isPermaLink="false">100-데이터분석 &amp; AI/캐글/주식,코인 시계열 데이터 분석에서 Ridge, XGBoost 추천 옵션 및 전략.md</guid><pubDate>Wed, 23 Jul 2025 12:31:56 GMT</pubDate></item><item><title><![CDATA[Untitled 1]]></title><description><![CDATA[아래 코드는 주어진 X, Y 데이터(넘파이 배열 혹은 판다스 데이터프레임을 가정)에 대해 릿지(Ridge) 회귀와 XGBoost 회귀(XGBRegressor)를 각각 학습시키고, 두 모델의 예측값 평균을 앙상블하여 R2, RMSE, 피어슨 상관계수를 출력하는 가장 기본적인 예제입니다.pythonimport numpy as np from sklearn.linear_model import Ridge from xgboost import XGBRegressor from sklearn.metrics import r2_score, mean_squared_error from scipy.stats import pearsonr # X, Y 데이터 준비 (여기에 실제 데이터 입력) np.random.seed(42) X = np.random.rand(100, 5) Y = np.random.rand(100) # 모델 정의 및 학습 ridge = Ridge() xgb = XGBRegressor(objective='reg:squarederror', random_state=42) ridge.fit(X, Y) xgb.fit(X, Y) # 예측 ridge_pred = ridge.predict(X) xgb_pred = xgb.predict(X) # 앙상블(평균) ensemble_pred = (ridge_pred + xgb_pred) / 2 # 성능 평가 r2 = r2_score(Y, ensemble_pred) rmse = mean_squared_error(Y, ensemble_pred) ** 0.5 pearson_corr, _ = pearsonr(Y, ensemble_pred) print(f'R2: {r2:.4f}') print(f'RMSE: {rmse:.4f}') print(f'피어슨 상관계수: {pearson_corr:.4f}')
실제 캐글 대회에서는 train/test 분할, 교차검증 등도 반드시 진행하세요. XGBoost 설치가 필요할 수 있습니다: pip install xgboost Ridge, XGBoost에 대한 앙상블과 대표적 평가지표 활용법은 여러 캐글 및 블로그, 공식 문서에서 확인할 수 있습니다<a data-tooltip-position="top" aria-label="https://www.kaggle.com/code/bashkeel/eda-to-ensemble-model-lasso-ridge-xgboost" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.kaggle.com/code/bashkeel/eda-to-ensemble-model-lasso-ridge-xgboost" target="_self">1</a><a data-tooltip-position="top" aria-label="https://velog.io/@kupulau/Regression-model-%EC%BD%94%EB%93%9C" rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@kupulau/Regression-model-%EC%BD%94%EB%93%9C" target="_self">2</a>. <br>성능 개선을 원한다면 그리드 서치, 스태킹 등 다양한 앙상블 기법도 활용해보세요<a data-tooltip-position="top" aria-label="https://www.kaggle.com/code/bashkeel/eda-to-ensemble-model-lasso-ridge-xgboost" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.kaggle.com/code/bashkeel/eda-to-ensemble-model-lasso-ridge-xgboost" target="_self">1</a><a data-tooltip-position="top" aria-label="https://www.kaggle.com/code/abhishek1aa/stacking-ensemble-roberta-xgboost-ridge" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.kaggle.com/code/abhishek1aa/stacking-ensemble-roberta-xgboost-ridge" target="_self">3</a>. 이 코드는 앙상블과 성능 평가의 가장 기본적인 골격을 보여줍니다. 데이터셋 특성에 따라 하이퍼파라미터 튜닝, 교차검증, 예측값 후처리 등을 추가해 실전에 맞게 최적화해주세요.
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.kaggle.com/code/bashkeel/eda-to-ensemble-model-lasso-ridge-xgboost" target="_self">https://www.kaggle.com/code/bashkeel/eda-to-ensemble-model-lasso-ridge-xgboost</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@kupulau/Regression-model-%EC%BD%94%EB%93%9C" target="_self">https://velog.io/@kupulau/Regression-model-%EC%BD%94%EB%93%9C</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.kaggle.com/code/abhishek1aa/stacking-ensemble-roberta-xgboost-ridge" target="_self">https://www.kaggle.com/code/abhishek1aa/stacking-ensemble-roberta-xgboost-ridge</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://riverzayden.tistory.com/17" target="_self">https://riverzayden.tistory.com/17</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://scikit-learn.org/stable/modules/ensemble.html" target="_self">https://scikit-learn.org/stable/modules/ensemble.html</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.kaggle.com/code/theintegratedguy/ensemble-regression" target="_self">https://www.kaggle.com/code/theintegratedguy/ensemble-regression</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://blog.csdn.net/weixin_39889597/article/details/110776483" target="_self">https://blog.csdn.net/weixin_39889597/article/details/110776483</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://xgboosting.com/xgboost-stable-predictions-via-ensemble-of-final-models/" target="_self">https://xgboosting.com/xgboost-stable-predictions-via-ensemble-of-final-models/</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.machinelearningmastery.com/xgboost-for-regression/" target="_self">https://www.machinelearningmastery.com/xgboost-for-regression/</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://stackoverflow.com/questions/20115272/calculate-coefficient-of-determination-r2-and-root-mean-square-error-rmse-fo/20115859" target="_self">https://stackoverflow.com/questions/20115272/calculate-coefficient-of-determination-r2-and-root-mean-square-error-rmse-fo/20115859</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://jaylala.tistory.com/entry/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D-with-Python-%EC%95%99%EC%83%81%EB%B8%94Ensemble-%ED%95%99%EC%8A%B5-4-XGBoost" target="_self">https://jaylala.tistory.com/entry/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D-with-Python-%EC%95%99%EC%83%81%EB%B8%94Ensemble-%ED%95%99%EC%8A%B5-4-XGBoost</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.geeksforgeeks.org/machine-learning/ensemble-methods-in-python/" target="_self">https://www.geeksforgeeks.org/machine-learning/ensemble-methods-in-python/</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.datatechnotes.com/2019/10/accuracy-check-in-python-mae-mse-rmse-r.html" target="_self">https://www.datatechnotes.com/2019/10/accuracy-check-in-python-mae-mse-rmse-r.html</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.youtube.com/watch?v=ujKt3JdI2B8" target="_self">https://www.youtube.com/watch?v=ujKt3JdI2B8</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.datacamp.com/tutorial/rmse" target="_self">https://www.datacamp.com/tutorial/rmse</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.mdpi.com/2079-8954/12/7/254" target="_self">https://www.mdpi.com/2079-8954/12/7/254</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://tyami.github.io/machine%20learning/ensemble-6-boosting-XGBoost-regression/" target="_self">https://tyami.github.io/machine%20learning/ensemble-6-boosting-XGBoost-regression/</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://stackoverflow.com/questions/893657/how-do-i-calculate-r-squared-using-python-and-numpy" target="_self">https://stackoverflow.com/questions/893657/how-do-i-calculate-r-squared-using-python-and-numpy</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.sciencedirect.com/science/article/abs/pii/S0306261922003555" target="_self">https://www.sciencedirect.com/science/article/abs/pii/S0306261922003555</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://cloud.google.com/python/docs/reference/bigframes/latest/bigframes.ml.ensemble.XGBRegressor" target="_self">https://cloud.google.com/python/docs/reference/bigframes/latest/bigframes.ml.ensemble.XGBRegressor</a>
]]></description><link>100-데이터분석-&amp;-ai/캐글/untitled-1.html</link><guid isPermaLink="false">100-데이터분석 &amp; AI/캐글/Untitled 1.md</guid><pubDate>Wed, 23 Jul 2025 11:59:31 GMT</pubDate></item><item><title><![CDATA[Untitled]]></title><description><![CDATA[
설명:&nbsp;L2 정규화 강도를 조절하는 하이퍼파라미터. 역할:&nbsp;값을 높일수록 계수를 더 많이 패널티하여 모델이 단순해짐(과적합 방지). 값이 너무 크면 과소적합 위험. 기본값:&nbsp;1.0 설명:&nbsp;절편(Intercept)을 학습할지 정하는 옵션. 값:&nbsp;True(기본값, 절편 포함), False(절편 미포함) 설명:&nbsp;입력 데이터 피처를 정규화(평균0, 분산1)할지 여부(구버전). 주의:&nbsp;최근 버전에서는 사용 중단됨.&nbsp;StandardScaler&nbsp;사용 권장. 설명:&nbsp;최적화에 사용할 알고리즘 종류 선택. 값 예시:&nbsp;‘auto’, ‘svd’, ‘cholesky’, ‘lsqr’, ‘sparse_cg’, ‘sag’, ‘saga’, ‘lbfgs’ 특징:&nbsp;데이터 크기, 희소성 등에 따라 최적 solver가 다를 수 있음. 설명:&nbsp;반복 최적화 알고리즘의 최대 반복 횟수. 기본값:&nbsp;None(알고리즘마다 다름), 필요하면 명시적으로 설정.
]]></description><link>100-데이터분석-&amp;-ai/캐글/untitled.html</link><guid isPermaLink="false">100-데이터분석 &amp; AI/캐글/Untitled.md</guid><pubDate>Tue, 22 Jul 2025 11:36:22 GMT</pubDate></item><item><title><![CDATA[eda]]></title><description><![CDATA[target : 'label'
Train columns: ['bid_qty', 'ask_qty', 'buy_qty', 'sell_qty', 'volume', 'X1', 'X2', 'X3', 'X4', 'X5', 'X6', 'X7', 'X8', 'X9', 'X10', 'X11', 'X12', 'X13', 'X14', 'X15', 'X16', 'X17', 'X18', 'X19', 'X20', 'X21', 'X22', 'X23', 'X24', 'X25', 'X26', 'X27', 'X28', 'X29', 'X30', 'X31', 'X32', 'X33', 'X34', 'X35', 'X36', 'X37', 'X38', 'X39', 'X40', 'X41', 'X42', 'X43', 'X44', 'X45', 'X46', 'X47', 'X48', 'X49', 'X50', 'X51', 'X52', 'X53', 'X54', 'X55', 'X56', 'X57', 'X58', 'X59', 'X60', 'X61', 'X62', 'X63', 'X64', 'X65', 'X66', 'X67', 'X68', 'X69', 'X70', 'X71', 'X72', 'X73', 'X74', 'X75', 'X76', 'X77', 'X78', 'X79', 'X80', 'X81', 'X82', 'X83', 'X84', 'X85', 'X86', 'X87', 'X88', 'X89', 'X90', 'X91', 'X92', 'X93', 'X94', 'X95', 'X96', 'X97', 'X98', 'X99', 'X100', 'X101', 'X102', 'X103', 'X104', 'X105', 'X106', 'X107', 'X108', 'X109', 'X110', 'X111', 'X112', 'X113', 'X114', 'X115', 'X116', 'X117', 'X118', 'X119', 'X120', 'X121', 'X122', 'X123', 'X124', 'X125', 'X126', 'X127', 'X128', 'X129', 'X130', 'X131', 'X132', 'X133', 'X134', 'X135', 'X136', 'X137', 'X138', 'X139', 'X140', 'X141', 'X142', 'X143', 'X144', 'X145', 'X146', 'X147', 'X148', 'X149', 'X150', 'X151', 'X152', 'X153', 'X154', 'X155', 'X156', 'X157', 'X158', 'X159', 'X160', 'X161', 'X162', 'X163', 'X164', 'X165', 'X166', 'X167', 'X168', 'X169', 'X170', 'X171', 'X172', 'X173', 'X174', 'X175', 'X176', 'X177', 'X178', 'X179', 'X180', 'X181', 'X182', 'X183', 'X184', 'X185', 'X186', 'X187', 'X188', 'X189', 'X190', 'X191', 'X192', 'X193', 'X194', 'X195', 'X196', 'X197', 'X198', 'X199', 'X200', 'X201', 'X202', 'X203', 'X204', 'X205', 'X206', 'X207', 'X208', 'X209', 'X210', 'X211', 'X212', 'X213', 'X214', 'X215', 'X216', 'X217', 'X218', 'X219', 'X220', 'X221', 'X222', 'X223', 'X224', 'X225', 'X226', 'X227', 'X228', 'X229', 'X230', 'X231', 'X232', 'X233', 'X234', 'X235', 'X236', 'X237', 'X238', 'X239', 'X240', 'X241', 'X242', 'X243', 'X244', 'X245', 'X246', 'X247', 'X248', 'X249', 'X250', 'X251', 'X252', 'X253', 'X254', 'X255', 'X256', 'X257', 'X258', 'X259', 'X260', 'X261', 'X262', 'X263', 'X264', 'X265', 'X266', 'X267', 'X268', 'X269', 'X270', 'X271', 'X272', 'X273', 'X274', 'X275', 'X276', 'X277', 'X278', 'X279', 'X280', 'X281', 'X282', 'X283', 'X284', 'X285', 'X286', 'X287', 'X288', 'X289', 'X290', 'X291', 'X292', 'X293', 'X294', 'X295', 'X296', 'X297', 'X298', 'X299', 'X300', 'X301', 'X302', 'X303', 'X304', 'X305', 'X306', 'X307', 'X308', 'X309', 'X310', 'X311', 'X312', 'X313', 'X314', 'X315', 'X316', 'X317', 'X318', 'X319', 'X320', 'X321', 'X322', 'X323', 'X324', 'X325', 'X326', 'X327', 'X328', 'X329', 'X330', 'X331', 'X332', 'X333', 'X334', 'X335', 'X336', 'X337', 'X338', 'X339', 'X340', 'X341', 'X342', 'X343', 'X344', 'X345', 'X346', 'X347', 'X348', 'X349', 'X350', 'X351', 'X352', 'X353', 'X354', 'X355', 'X356', 'X357', 'X358', 'X359', 'X360', 'X361', 'X362', 'X363', 'X364', 'X365', 'X366', 'X367', 'X368', 'X369', 'X370', 'X371', 'X372', 'X373', 'X374', 'X375', 'X376', 'X377', 'X378', 'X379', 'X380', 'X381', 'X382', 'X383', 'X384', 'X385', 'X386', 'X387', 'X388', 'X389', 'X390', 'X391', 'X392', 'X393', 'X394', 'X395', 'X396', 'X397', 'X398', 'X399', 'X400', 'X401', 'X402', 'X403', 'X404', 'X405', 'X406', 'X407', 'X408', 'X409', 'X410', 'X411', 'X412', 'X413', 'X414', 'X415', 'X416', 'X417', 'X418', 'X419', 'X420', 'X421', 'X422', 'X423', 'X424', 'X425', 'X426', 'X427', 'X428', 'X429', 'X430', 'X431', 'X432', 'X433', 'X434', 'X435', 'X436', 'X437', 'X438', 'X439', 'X440', 'X441', 'X442', 'X443', 'X444', 'X445', 'X446', 'X447', 'X448', 'X449', 'X450', 'X451', 'X452', 'X453', 'X454', 'X455', 'X456', 'X457', 'X458', 'X459', 'X460', 'X461', 'X462', 'X463', 'X464', 'X465', 'X466', 'X467', 'X468', 'X469', 'X470', 'X471', 'X472', 'X473', 'X474', 'X475', 'X476', 'X477', 'X478', 'X479', 'X480', 'X481', 'X482', 'X483', 'X484', 'X485', 'X486', 'X487', 'X488', 'X489', 'X490', 'X491', 'X492', 'X493', 'X494', 'X495', 'X496', 'X497', 'X498', 'X499', 'X500', 'X501', 'X502', 'X503', 'X504', 'X505', 'X506', 'X507', 'X508', 'X509', 'X510', 'X511', 'X512', 'X513', 'X514', 'X515', 'X516', 'X517', 'X518', 'X519', 'X520', 'X521', 'X522', 'X523', 'X524', 'X525', 'X526', 'X527', 'X528', 'X529', 'X530', 'X531', 'X532', 'X533', 'X534', 'X535', 'X536', 'X537', 'X538', 'X539', 'X540', 'X541', 'X542', 'X543', 'X544', 'X545', 'X546', 'X547', 'X548', 'X549', 'X550', 'X551', 'X552', 'X553', 'X554', 'X555', 'X556', 'X557', 'X558', 'X559', 'X560', 'X561', 'X562', 'X563', 'X564', 'X565', 'X566', 'X567', 'X568', 'X569', 'X570', 'X571', 'X572', 'X573', 'X574', 'X575', 'X576', 'X577', 'X578', 'X579', 'X580', 'X581', 'X582', 'X583', 'X584', 'X585', 'X586', 'X587', 'X588', 'X589', 'X590', 'X591', 'X592', 'X593', 'X594', 'X595', 'X596', 'X597', 'X598', 'X599', 'X600', 'X601', 'X602', 'X603', 'X604', 'X605', 'X606', 'X607', 'X608', 'X609', 'X610', 'X611', 'X612', 'X613', 'X614', 'X615', 'X616', 'X617', 'X618', 'X619', 'X620', 'X621', 'X622', 'X623', 'X624', 'X625', 'X626', 'X627', 'X628', 'X629', 'X630', 'X631', 'X632', 'X633', 'X634', 'X635', 'X636', 'X637', 'X638', 'X639', 'X640', 'X641', 'X642', 'X643', 'X644', 'X645', 'X646', 'X647', 'X648', 'X649', 'X650', 'X651', 'X652', 'X653', 'X654', 'X655', 'X656', 'X657', 'X658', 'X659', 'X660', 'X661', 'X662', 'X663', 'X664', 'X665', 'X666', 'X667', 'X668', 'X669', 'X670', 'X671', 'X672', 'X673', 'X674', 'X675', 'X676', 'X677', 'X678', 'X679', 'X680', 'X681', 'X682', 'X683', 'X684', 'X685', 'X686', 'X687', 'X688', 'X689', 'X690', 'X691', 'X692', 'X693', 'X694', 'X695', 'X696', 'X697', 'X698', 'X699', 'X700', 'X701', 'X702', 'X703', 'X704', 'X705', 'X706', 'X707', 'X708', 'X709', 'X710', 'X711', 'X712', 'X713', 'X714', 'X715', 'X716', 'X717', 'X718', 'X719', 'X720', 'X721', 'X722', 'X723', 'X724', 'X725', 'X726', 'X727', 'X728', 'X729', 'X730', 'X731', 'X732', 'X733', 'X734', 'X735', 'X736', 'X737', 'X738', 'X739', 'X740', 'X741', 'X742', 'X743', 'X744', 'X745', 'X746', 'X747', 'X748', 'X749', 'X750', 'X751', 'X752', 'X753', 'X754', 'X755', 'X756', 'X757', 'X758', 'X759', 'X760', 'X761', 'X762', 'X763', 'X764', 'X765', 'X766', 'X767', 'X768', 'X769', 'X770', 'X771', 'X772', 'X773', 'X774', 'X775', 'X776', 'X777', 'X778', 'X779', 'X780', 'label']
주요 선생님들이 셀랙한 feature main feature 'bid_qty', 'volume', 'buy_qty', 'sell_qty'
'ask_qty'
'X598', 'X344'
X363, X405, X321, X175, X179, X197, X22, X181, X28, X169, X198, X173, X338, X587, X450, X97, X52, X444, X297, X138, X572, X343, X438, X459, X758, X25 <a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.kaggle.com/code/johndoe2011/anyone-can-win-on-public-lb" target="_self">https://www.kaggle.com/code/johndoe2011/anyone-can-win-on-public-lb</a> [ 'X363', 'X405', 'X321', 'X175', 'X179', 'X137', 'X197', 'X22', 'X40', 'X181', 'X28', 'X169', 'X198', 'X173', 'X338', 'X288', 'X385', 'X344', 'X427', 'X587', 'X450', 'X97', 'X52', 'X444', 'X598', 'X379', 'X696', 'X297', 'X138', 'X572', 'X343', 'X586', 'X466', 'X438', 'X452', 'X459', 'X435', 'X386', 'X55', 'X341', 'X683', 'X428', 'X605', 'X445', 'X272', 'X180', 'X593', 'X680', 'X686', 'X692', 'X695', "X603", "X674", "X421", "X333", "X415", "X345", "X174", "X302", "X178", "X168", "X612", "buy_qty", "sell_qty", "volume", "bid_qty", "ask_qty", ] 기억안나시는누군가
""" 상호작용 및 기본 관계 지표
거래활성도랑, 실제로 내놨을때 얼마나팔렷나를 평가하는 척도들
"""
# 매수/매도 호가 수량의 곱. 주문서 유동성의 쌍방향 규모 예상
df['bid_ask_interaction'] = df['bid_qty'] * df['ask_qty'] # 매수 호가수량 × 실제 매수 체결량. 호가잔량과 실제 매수간 상호작용 지표
df['bid_buy_interaction'] = df['bid_qty'] * df['buy_qty']
# 매수 호가수량 × 실제 매도 체결량. 미체결 매수와 매도 거래간 연결도
df['bid_sell_interaction'] = df['bid_qty'] * df['sell_qty']
# 매도 호가수량 × 실제 매수 체결량. 미체결 매도와 매수 거래간 연결도
df['ask_buy_interaction'] = df['ask_qty'] * df['buy_qty']
# 매도 호가수량 × 실제 매도 체결량. 호가잔량과 실제 매도간 상호작용 지표
df['ask_sell_interaction'] = df['ask_qty'] * df['sell_qty']
# 실제 매수·매도 체결량의 곱. 거래 활성도의 상대 척도
df['buy_sell_interaction'] = df['buy_qty'] * df['sell_qty']
# (매도호가수량-매수호가수량)/(양 호가잔량 누적)로 유동성 불균형 지표
df['spread_indicator'] = (df['ask_qty'] - df['bid_qty']) / (df['ask_qty'] + df['bid_qty'] + 1e-8)
# 실시간 매수 체결량/매도 체결량 비율
df['buy_sell_ratio'] = df['buy_qty'] / (df['sell_qty'] + 1e-8)
# 매수호가잔량/매도호가잔량 비율
df['bid_ask_ratio'] = df['bid_qty'] / (df['ask_qty'] + 1e-8)
# 유동성
df['total_liquidity'] = df['bid_qty'] + df['ask_qty'] # 유동성 불균형도
df['liquidity_imbalance'] = (df['bid_qty'] - df['ask_qty']) / (df['total_liquidity'] + 1e-8)
# 매수 체결량/매수호가. 매수세가 호가잔량 대비 얼마나 큰지
df['normalized_buy_volume'] = df['buy_qty'] / (df['bid_qty'] + 1e-8)
# 매도 체결량/매도호가. 매도세가 호가잔량 대비 얼마나 큰지
df['normalized_sell_volume'] = df['sell_qty'] / (df['ask_qty'] + 1e-8) """
거래강도를 포함한 지표
각 매수매도의 힘과 전체 시장의 방향성과 힘이 얼마인지를 확인할 수 있음
"""
# 매도호가수량-매수호가수량)/총거래량. 유동성 대비 스프레드 지표
df['relative_spread'] = (df['ask_qty'] - df['bid_qty']) / (df['volume'] + 1e-8)
df['volume_weighted_buy'] = df['buy_qty'] * df['volume']
df['volume_weighted_sell'] = df['sell_qty'] * df['volume']
df['volume_weighted_bid'] = df['bid_qty'] * df['volume']
df['volume_weighted_ask'] = df['ask_qty'] * df['volume']
# 실시간 매수·매도 힘 균형(
df['order_flow_imbalance'] = (df['buy_qty'] - df['sell_qty']) / (df['volume'] + 1e-8)
# 볼륨을 반영한 유동성 불균형도인듯?
df['liquidity_adjusted_imbalance'] = df['order_flow_imbalance'] * df['depth_ratio']
# 매수매도 하려는 힘
df['buying_pressure'] = df['buy_qty'] / (df['volume'] + 1e-8)
df['selling_pressure'] = df['sell_qty'] / (df['volume'] + 1e-8)
# 전체 체결횟수/총거래량. 시장의 거래 활성 수준
df['trade_intensity'] = (df['buy_qty'] + df['sell_qty']) / (df['volume'] + 1e-8)
# 평균 체결 단위. 한 번 거래당 평균 체결량
df['avg_trade_size'] = df['volume'] / (df['buy_qty'] + df['sell_qty'] + 1e-8)
# 실질 순매수/매도 흐름. (매수-매도)/(매수+매도)
df['net_trade_flow'] = (df['buy_qty'] - df['sell_qty']) / (df['buy_qty'] + df['sell_qty'] + 1e-8)
# 총유동성/총거래량. 시장 유동성 깊이 척도
df['depth_ratio'] = df['total_liquidity'] / (df['volume'] + 1e-8)
df['volume_participation'] = (df['buy_qty'] + df['sell_qty']) / (df['total_liquidity'] + 1e-8)
# 시장활성지표 주문서-실제 거래의 복합 지표
df['market_activity'] = df['volume'] * df['total_liquidity'] # 체결량 차이/거래량. 시장 실효적 스프레드 근사치 df['effective_spread_proxy'] = np.abs(df['buy_qty'] - df['sell_qty']) / (df['volume'] + 1e-8)
df['realized_volatility_proxy'] = np.abs(df['order_flow_imbalance']) * df['volume'] # 매수압력 × 스프레드 지표. 매수세와 유동성 스프레드의 복합 움직임
df['pressure_spread_interaction'] = df['buying_pressure'] * df['spread_indicator'] <br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.kaggle.com/code/rosswade/drw-crypto-market-submission" target="_self">https://www.kaggle.com/code/rosswade/drw-crypto-market-submission</a> FEATURES = [ "X863", "X856", "X344", "X598", "X862", "X385", "X852", "X603", "X860", "X674", "X415", "X345", "X137", "X855", "X174", "X302", "X178", "X532", "X168", "X612", "bid_qty", "ask_qty", "buy_qty", "sell_qty", "volume","X888", "X421", "X333"
] # === NEW FEATURES ===
# 기억안나시는 누군가파트에서 다한 부분임
df['volume_weighted_sell'] = df['sell_qty'] * df['volume']
df['buy_sell_ratio'] = df['buy_qty'] / (df['sell_qty'] + 1e-8)
df['selling_pressure'] = df['sell_qty'] / (df['volume'] + 1e-8)
df['effective_spread_proxy'] = np.abs(df['buy_qty'] - df['sell_qty']) / (df['volume'] + 1e-8)
df['log_volume'] = np.log1p(df['volume'])
df['bid_ask_imbalance'] = (df['bid_qty'] - df['ask_qty']) / (df['bid_qty'] + df['ask_qty'] + 1e-8)
df['order_flow_imbalance'] = (df['buy_qty'] - df['sell_qty']) / (df['buy_qty'] + df['sell_qty'] + 1e-8)
df['liquidity_ratio'] = (df['bid_qty'] + df['ask_qty']) / (df['volume'] + 1e-8) <br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.kaggle.com/code/taylorsamarel/xgb-deep-learning-ensemble" target="_self">https://www.kaggle.com/code/taylorsamarel/xgb-deep-learning-ensemble</a> core_features = [ 'X363', 'X405', 'X321', 'X175', 'X179', 'X197', 'X22', 'X181', 'X28', 'X169', 'X198', 'X173', 'X338', 'X344', 'X587', 'X450', 'X97', 'X52', 'X444', 'X598', 'X297', 'X138', 'X572', 'X343', 'X438', 'X459', 'X758', 'X25', 'buy_qty', 'sell_qty', 'volume', 'bid_qty' ] <br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.kaggle.com/code/vishalpainjane/drw-ensemble-0-72837" target="_self">https://www.kaggle.com/code/vishalpainjane/drw-ensemble-0-72837</a> cols = [ 'X363', 'X405', 'X321', 'X175', 'X179', 'X137', 'X197', 'X22', 'X40', 'X181', 'X28', 'X169', 'X198', 'X173', 'X338', 'X288', 'X385', 'X344', 'X427', 'X587', 'X450', 'X97', 'X52', 'X444', 'X598', 'X379', 'X696', 'X297', 'X138', 'X572', 'X343', 'X586', 'X466', 'X438', 'X452', 'X459', 'X435', 'X386', 'X55', 'X341', 'X683', 'X428', 'X605', 'X445', 'X272', 'X180', 'X593', 'X680', 'X686', 'X692', 'X695', "X603", "X674", "X421", "X333", "X415", "X345", "X174", "X302", "X178", "X168", "X612", 'X298', 'X45', 'X46', 'X39', 'X752', 'X759', 'X41', 'X42', "buy_qty", "sell_qty", "volume", "bid_qty", "ask_qty", ] # Add new top important features new_features = [ 'X758', 'X296', 'X611', 'X780', 'X451', 'X25', 'X591', ] <br>
리지모델 : <a rel="noopener nofollow" class="external-link is-unresolved" href="https://wikidocs.net/152833" target="_self">https://wikidocs.net/152833</a> ]]></description><link>100-데이터분석-&amp;-ai/캐글/eda.html</link><guid isPermaLink="false">100-데이터분석 &amp; AI/캐글/eda.md</guid><pubDate>Sun, 20 Jul 2025 06:25:47 GMT</pubDate></item><item><title><![CDATA[db 영속성과 저장]]></title><description><![CDATA[Client &lt;-&gt; Controller &lt;-&gt; Service &lt;-&gt; Mapper &lt;-&gt; DB<img alt="db 영속성과 저장-1751787526152.png" src="300-백엔드개발/assets/db-영속성과-저장-1751787526152.png" target="_self">// 저장하고 flush하여 id 즉시 생성
AuthorAccount savedAccount = repository().saveAndFlush(this); // 저장된 엔티티로 이벤트 publish (id가 설정된 객체)
AuthorSignup authorSignup = new AuthorSignup(savedAccount);
authorSignup.publishAfterCommit();
my errorrepo().save(this)
해서 db에저장하고 id를 포함한 객체를 이벤트로 발행하는 로직이엇다but;;
저 saveAccount객체가 잘 넘어가지 않았다.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@codren/JPA-%EA%B0%9C%EB%85%90-%EB%B0%8F-%EC%9B%90%EB%A6%AC" target="_self">https://velog.io/@codren/JPA-%EA%B0%9C%EB%85%90-%EB%B0%8F-%EC%9B%90%EB%A6%AC</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://bnzn2426.tistory.com/145" target="_self">https://bnzn2426.tistory.com/145</a>]]></description><link>300-백엔드개발/db-영속성과-저장.html</link><guid isPermaLink="false">300-백엔드개발/db 영속성과 저장.md</guid><pubDate>Sun, 06 Jul 2025 07:39:33 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[db 영속성과 저장-1751787526152]]></title><description><![CDATA[<img src="300-백엔드개발/assets/db-영속성과-저장-1751787526152.png" target="_self">]]></description><link>300-백엔드개발/assets/db-영속성과-저장-1751787526152.html</link><guid isPermaLink="false">300-백엔드개발/assets/db 영속성과 저장-1751787526152.png</guid><pubDate>Sun, 06 Jul 2025 07:38:46 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스프링 DB 접근]]></title><description><![CDATA[
자바에서 데이터베이스에 접근할 수 있도록 하는 자바 API
low level standard임
<img alt="스프링 DB 접근-1748788030972.png" src="300-백엔드개발/assets/스프링-db-접근-1748788030972.png" target="_self">SQL 중심 기술임(직접작성해야한단소리임)
therefore DBMS에 종속속적임
아래 기술은 내부적으로 JDBC를 사용함(JPA는 대부분..)
JDBC Template JDBC를 쉽게 사용하기 위한 JDBC의 래퍼임 MyBatis SQL과 자바 객체간 매핑을 지원하는 프레임워크
개발자가 sql작성하면 mybatis가 jdbc의 부분을 처리 JPA java orm의 스텐다드임
sql안쓰고 객체중심으로 DB를 다룰 수 있게 해줌
DataNucleus JPA JDBC 사용 ㄴㄴ
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://stackoverflow.com/questions/11881548/jpa-or-jdbc-how-are-they-different" target="_self">https://stackoverflow.com/questions/11881548/jpa-or-jdbc-how-are-they-different</a> OOP &lt;-&gt; RDB 연결
객체지향과 관계형을 매핑한다
패러다임의 불일치가 존재함 RDB의 model을 entity형태로 투형함
관계를 지정하면 orm이 자동으로 sql을 생성함 dbms 종속이 적어짐 JPA의 대표 구현체 : Hibernate
장점 종속성적어짐
간단한거 구현 개쉬움
객체지향적 단점 모든 쿼리 대체불가
쿼리 괴랄하면 난이도 급상승
잘못 구현되면 속도랑 일관성이무너짐 java 의 orm 영속 : 객체 생성후 em.persist(entity)를 호출하여 영속성 컨텍스트에 들어감
비영속 : 객체생성후 영속성 컨텍스트와 관계 엄슴
준영속 : 영속성 컨텍스트에 저장되었다가 분리되어 나옴
삭제 : 객체를 삭제한 상태
persistence context<br>
<a class="internal-link" data-href="db 영속성과 저장.md" href="300-백엔드개발/db-영속성과-저장.html" target="_self" rel="noopener nofollow">db 영속성과 저장</a>
어플리케이션과 DB사이서 객체를 보관하는 가상 DB 엔티티 매니저를 통해 엔티티를 저장,조회시 엔티티 매니저는 연속성 컨텍스트에 저장하고 관리함
내부에 캐시를 갖음(이를 1차 캐시라함) Map형식임
1차에 잇으면 DB까지 조회안함 쓰기 지연을 할수 있음 미리 변경사항을 갖고잇다가 트랜잭션이 커밋되면 한번에 쿼리 날릴수잇음
DB커넥션 수와 시간을 줄일 . 수있음 영속성 컨텍스트의 변경내용을 db에 반영하는 작업(일종의 동기화 작업)
영속성 컨텍스트에 저장된 엔티티의 변경사항이 실제 db에 전달
플러시가 발생해도 1차 캐시(영속성 컨텍스트)는 그대로 유지됨
동작과정 변경감지
수정된 엔티티 등록
sql db 전송 언제 발생? 트랜젝션 커밋
(Java Persistence Query Language)로 쿼리를 실행할 때 자동으로
직접 flush() 호출 모드 auto 트랜잭션 커밋이나 쿼리 실행 시 플러시가 자동으로 동작 commit 트랜잭션 커밋 시에만 플러시가 동작 ]]></description><link>300-백엔드개발/스프링-db-접근.html</link><guid isPermaLink="false">300-백엔드개발/스프링 DB 접근.md</guid><pubDate>Sun, 06 Jul 2025 07:36:52 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[0. 머신러닝 기본]]></title><description><![CDATA[<a href=".?query=tag:root" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#root">#root</a>
AI ⊃ ML ⊃ DL ⊃ GEN AI 기존 머신러닝(딥러닝이아닌..) vs 딥러닝
기존 머신러닝(이하 머신러닝) 는 sklearn씀
딥러닝은 pytorch나 tensorflow씀 패턴 있는것 &gt; 데이터로 이용
없는것 &gt; 노이즈라 함 모델 데이터로부터 패턴을 찾아 수학적으로 정리해 놓은것
목적 : 샘플을 가지고 전체를추 모델링 가능한한 오차가 적은 모델을 만드는 과정 ML supervised(지도)
unsupervised(비지도)
reinforcement(강화) 프레임워크 pytorch
tensorflow keras : tensorflow에 통합된 고수준 신경망 API <br><a class="internal-link" data-href="머신러닝 프레임워크비교.md" href="kt에이블/머신러닝-프레임워크비교.html" target="_self" rel="noopener nofollow">머신러닝 프레임워크비교</a> 텐서 딥러닝에서 데이터 처리 기본구조
미분, gpu가속, 메모리최적화등을 지원 문제 정의 어떤 문제를 인공지능으로 해결할지 구체적으로 정의
여기서 분류 기법인지 회귀 기법인지 판단 분류 기법 : 범주형
회귀 기법 : 연속형 데이터 수집 문제 해결에 필요한 데이터를 확보 데이터 전처리 &amp; EDA <br><a class="internal-link" data-href="EDA.md" href="kt에이블/eda.html" target="_self" rel="noopener nofollow">EDA</a> 전처리 과정에서 EDA가 주로 이뤄짐
특히 이상치결측치 처리, 특성 선택등에서 이뤄짐 <br><a class="internal-link" data-href="형식 통일.md" href="kt에이블/형식-통일.html" target="_self" rel="noopener nofollow">형식 통일</a>
<br><a class="internal-link" data-href="결측치 처리.md" href="kt에이블/결측치-처리.html" target="_self" rel="noopener nofollow">결측치 처리</a>
<br><a class="internal-link" data-href="이상치 처리.md" href="kt에이블/이상치-처리.html" target="_self" rel="noopener nofollow">이상치 처리</a>
<br><a class="internal-link" data-href="스케일링, 인코딩.md" href="kt에이블/스케일링,-인코딩.html" target="_self" rel="noopener nofollow">스케일링, 인코딩</a>
<br><a class="internal-link" data-href="특성 추출, 선택 ,변환.md" href="kt에이블/특성-추출,-선택-,변환.html" target="_self" rel="noopener nofollow">특성 추출, 선택 ,변환</a>
프레임워크에 맞게 변환 <br><a class="internal-link" data-href="assets/pytorch 데이터 준비.md" href="kt에이블/assets/pytorch-데이터-준비.html" target="_self" rel="noopener nofollow">pytorch 데이터 준비</a>
<br><a class="internal-link" data-href="../Z_ETC/tensorflow 데이터준비.md" href="z_etc/tensorflow-데이터준비.html" target="_self" rel="noopener nofollow">tensorflow 데이터준비</a>
주로 shuffle하여 진행 왜? 순서로 인한 편향방지하기위해 모델 선택 및 하이퍼파라미터 튜닝 문제 특성에 맞는 머신러닝 모델(예: 선형회귀, 의사결정나무, 신경망 등)을 선택하고, 성능을 높이기 위한 하이퍼파라미터를 설정합니다. 모델 학습 전처리된 데이터를 이용해 모델을 학습시킵니다. 이때 학습 데이터와 검증 데이터를 나누어 사용합니다. 예측 및 성능 평가 테스트 데이터를 사용해 모델의 성능을 평가합니다. 정확도, 정밀도, 재현율, F1-score 등 다양한 지표를 활용합니다. 모델 배포 및 모니터링 실제 서비스에 모델을 적용(배포)하고, 데이터가 바뀔 때마다 재학습 및 성능 모니터링을 진행합니다. CRISP-DM
<br><img alt="assets/1. 딥러닝-20250410141028941.png" src="kt에이블/assets/1.-딥러닝-20250410141028941.png" target="_self" style="width: 440px; max-width: 100%;">
기업들이 이거 변형해서쓰는 기업많음용
]]></description><link>kt에이블/0.-머신러닝-기본.html</link><guid isPermaLink="false">kt에이블/0. 머신러닝 기본.md</guid><pubDate>Sat, 30 Aug 2025 15:24:02 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[date,localdate,OffsetDateTime]]></title><description><![CDATA[맞다! DateTime도 있지! 하지만 Java에서는 조금 다르게 불러요. 정리해드릴게요!Date date = new Date(); // 현재 시간
System.out.println(date); // Wed Jan 15 14:30:25 KST 2025
❌ 문제점: 가변(mutable) 객체
시간대 처리가 복잡
API가 직관적이지 않음
Java 8 이후로 deprecated
LocalDateTime now = LocalDateTime.now();
System.out.println(now); // 2025-01-15T14:30:25.123
✅ 장점: 불변 객체
직관적인 API
시간대 정보 없음 (단순함)
OffsetDateTime now = OffsetDateTime.now();
System.out.println(now); // 2025-01-15T14:30:25.123+09:00
✅ 장점: 시간대 오프셋 포함
정확한 시점 표현
ISO-8601 표준
ZonedDateTime now = ZonedDateTime.now();
System.out.println(now); // 2025-01-15T14:30:25.123+09:00[Asia/Seoul]
✅ 장점: 시간대 이름 포함
더 풍부한 시간대 정보
// YouTube 동영상 업로드 시간을 저장할 때
// 1. LocalDateTime 사용한다면?
LocalDateTime publishAt = LocalDateTime.of(2025, 1, 15, 14, 30, 25);
// 문제: 이게 어느 시간대인지 모름 (한국? 미국? 중국?) // 2. OffsetDateTime 사용한다면?
OffsetDateTime publishAt = OffsetDateTime.of(2025, 1, 15, 14, 30, 25, 0, ZoneOffset.ofHours(9));
// 장점: 한국 시간(UTC+9)임을 명확히 알 수 있음
// LocalDateTime
LocalDateTime localTime = LocalDateTime.parse("2025-01-15T14:30:25");
System.out.println(localTime); // 2025-01-15T14:30:25
// 문제: 이게 언제인지 정확히 모름! // OffsetDateTime OffsetDateTime offsetTime = OffsetDateTime.parse("2025-01-15T14:30:25+09:00");
System.out.println(offsetTime); // 2025-01-15T14:30:25+09:00
// 장점: 한국 시간 오후 2시 30분 25초임을 명확히 알 수 있음
public class PostInfoResponseMessage { private LocalDateTime publishAt; // 시간대 정보 없음
}
❌ 문제점:
시간대 정보가 없어서 정확한 시점을 모름
AI 서버에서 분석할 때 혼란 가능
public class PostInfoResponseMessage { private ZonedDateTime publishAt; // 시간대 이름 포함
}
✅ 장점: 더 풍부한 시간대 정보
❌ 단점: JSON 직렬화 시 복잡할 수 있음public class PostInfoResponseMessage { private Instant publishAt; // UTC 기준 타임스탬프
}
✅ 장점: 단순하고 명확
❌ 단점: 사용자가 보기 어려움// YouTube 동영상이 언제 업로드되었는지 정확히 표현
"2025-01-15T14:30:25+09:00" // 한국 시간으로 명확히 표현
// AI 서버가 시간대를 고려한 분석 가능
// - 업로드 시간대별 성과 분석
// - 지역별 인기도 분석
// - 시간대별 최적 업로드 시간 추천
// JSON으로 변환 시 깔끔함
{ "publish_at": "2025-01-15T14:30:25+09:00"
} ISO-8601 국제 표준
다른 시스템과 호환성 좋음
// PostInfoResponseMessage.java
public class PostInfoResponseMessage { private LocalDateTime publishAt; // 시간대 정보 없음
} // 문제: AI 서버에서 시간대를 추측해야 함
// "2025-01-15T14:30:25" → 이게 어느 시간대인지 모름!
OffsetDateTime을 선택한 이유:
정확한 시점 표현 - 시간대 정보 포함
AI 분석 품질 향상 - 시간대별 분석 가능 국제 표준 준수 - ISO-8601
JSON 직렬화 깔끔함 - 명확한 형식
LocalDateTime도 충분히 좋지만, 시간대 정보가 중요한 우리 프로젝트에서는 OffsetDateTime이 더 적합해요! 🚀]]></description><link>kt에이블/빅프/date,localdate,offsetdatetime.html</link><guid isPermaLink="false">kt에이블/빅프/date,localdate,OffsetDateTime.md</guid><pubDate>Fri, 29 Aug 2025 22:09:02 GMT</pubDate></item><item><title><![CDATA[Untitled]]></title><description><![CDATA[이 문서는 애플리케이션의 디자인 시스템과 일관성을 유지하기 위한 철학과 가이드라인을 정의합니다.UI 요소의 중요도와 계층에 따라 시각적 깊이를 구분하여 사용자의 인지 부하를 줄입니다.동일한 기능은 동일한 시각적 표현과 상호작용을 가져야 합니다.모든 색상은 App.css에 정의된 변수를 사용하여 일관성을 보장합니다. 용도: 페이지의 주요 콘텐츠 영역 스타일: 그림자 있는 Card (Card 기본) 예시: 게시물 목록 Card 콘텐츠 목록 Card 콘텐츠 타입 선택 Card 메인 워크플로우 Card 용도: 필터, 선택기, 탭 헤더 스타일: outline Card (Card outline={true}) 예시: SearchFilter SnsTypeFilter PostSelector DateRangeSelector 탭 헤더 용도: 개별 아이템, 카드 스타일: 그림자 있는 Card (Card 기본) 예시: PostCard ContentCard StoreCard StoreInfoSection AdInfoSection 용도: 드롭다운, 모달 내부 요소 스타일: outline Card (Card outline={true}) 예시: 드롭다운 메뉴 모달 내부 섹션 --color-text: #040324 (주요 텍스트) --color-bg: <a href=".?query=tag:f7f7fe" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#f7f7fe">#f7f7fe</a> (배경) <br>
--color-white: <a href=".?query=tag:ffffff" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#ffffff">#ffffff</a> (하얀색) <br>
--color-primary: <a href=".?query=tag:b5b5ff" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#b5b5ff">#b5b5ff</a> (주요 액션) <br>
--color-secondary: <a href=".?query=tag:f38380" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#f38380">#f38380</a> (보조 액션) <br>
--color-success: <a href=".?query=tag:64d97b" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#64d97b">#64d97b</a> (성공) <br>
--color-warning: <a href=".?query=tag:f59e0b" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#f59e0b">#f59e0b</a> (경고) <br>
--color-danger: <a href=".?query=tag:ef4444" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#ef4444">#ef4444</a> (위험/삭제) /5, /10, /15, /20, /30, /40, /50, /60, /70, /80, /90, /95 예시: text-text/60, bg-primary/20 <br>
--color-youtube: <a href=".?query=tag:ff6b6b" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#ff6b6b">#ff6b6b</a> <br>
--color-instagram: <a href=".?query=tag:fd79a8" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#fd79a8">#fd79a8</a> <br>
--color-facebook: <a href=".?query=tag:74b9ff" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#74b9ff">#74b9ff</a> 용도: 페이지의 주요 기능 (생성, 저장, 확인) 스타일: variant="primary" 예시: "새 게시물 업로드", "저장", "확인" 용도: 보조 기능 (수정, 편집) 스타일: variant="secondary" 예시: "수정", "편집" 용도: 긍정적인 액션 (선택, 활성화) 스타일: variant="success" 예시: "선택", "활성화" 용도: 삭제, 취소 등 위험한 액션 스타일: variant="danger" 예시: "삭제", "취소", "로그아웃" 용도: 카드 내부의 빠른 액션 스타일: IconButton 컴포넌트 사용 크기: size="small" (카드 내부), size="medium" (테이블) RealtimeColorsLayout: 로그인, 매장 선택 등 특별한 페이지 ApiPageLayout: 데이터 로딩이 필요한 관리 페이지 직접 스타일링: 분석, 콘텐츠 제작 등 복잡한 페이지 RealtimeHeader: 페이지 제목과 부제목 variant: 페이지 성격에 따라 결정 primary: 관리 페이지 secondary: 선택 페이지 default: 일반 페이지 하드코딩된 색상 사용 금지 App.css 색상 변수만 사용 투명도는 표준 시스템 사용 같은 깊이의 요소는 같은 스타일 깊이 1: 그림자 Card 깊이 2: outline Card 깊이 3: 그림자 Card 깊이 4: outline Card Primary 액션: 주요 기능 Secondary 액션: 보조 기능 Success 액션: 긍정적 액션 Danger 액션: 위험한 액션 IconButton: 카드/테이블 내부 액션 제목: font-bold text-text 부제목: font-bold text-text/70 본문: text-text/60 설명: text-text/50 Card 패딩: p-6 (깊이 1, 3), p-4 (깊이 2, 4) 섹션 간격: mb-8 (깊이 1), mb-4 (깊이 2) 요소 간격: gap-4 (기본), gap-2 (밀집) 색상 시스템 통일 (최우선) 깊이별 스타일 통일 액션 버튼 시스템 통일 Typography 통일 Spacing 통일 모든 변경사항은 빌드 테스트 필수 기존 하드코딩된 스타일은 점진적으로 제거 새로운 컴포넌트는 이 가이드라인을 따라야 함 ]]></description><link>kt에이블/untitled.html</link><guid isPermaLink="false">kt에이블/Untitled.md</guid><pubDate>Mon, 25 Aug 2025 20:22:23 GMT</pubDate></item><item><title><![CDATA[그외 에러]]></title><description><![CDATA[댓글이 너무길어 varchar 255 를넘음text로변경하고 최대길이를 넣음하나가실패하면 전부 롤백됨 == 트랜잭션때문임
개별별도로 트랜잭션 으로분리// 이전: 전체 배치가 하나의 트랜잭션
@Transactional
private void saveCommentsToDatabase(...) {
// 하나라도 실패하면 전체 롤백
}// 현재: 개별 댓글마다 별도 트랜잭션
private void saveCommentsToDatabase(...) {
for (comment : comments) {
saveCommentInTransaction(comment); // 각각 별도 트랜잭션
}
}배치 리스타트시 에러
.publishedAt(ZonedDateTime.parse(snippet.getPublishedAt().toString()).toInstant())이미지 빌드eclipse-temurin:17-jre
FROM amazoncorretto:17-alpine-- 내꺼
FROM amazoncorretto:17-alpine WORKDIR /app COPY build/libs/*SNAPSHOT.jar app.jar EXPOSE 8081 ENV TZ=Asia/Seoul
RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone ENTRYPOINT ["java","-Xmx400M","-Djava.security.egd=file:/dev/./urandom","-jar","app.jar"]--- 종수님꺼
FROM eclipse-temurin:17-jre WORKDIR /app
COPY build/libs/*SNAPSHOT.jar app.jar ENV JAVA_TOOL_OPTIONS="-XX:MaxRAMPercentage=70 -XX:InitialRAMPercentage=50" EXPOSE 8080
ENTRYPOINT ["java","-Duser.timezone=Asia/Seoul","-Djava.security.egd=file:/dev/./urandom","-jar","app.jar"]디비컬럼캐싱문제해결<a rel="noopener nofollow" class="external-link is-unresolved" href="https://stackoverflow.com/questions/49016372/spring-data-redis-cacheable-java-lang-classcastexception-java-util-linkedhashm" target="_self">https://stackoverflow.com/questions/49016372/spring-data-redis-cacheable-java-lang-classcastexception-java-util-linkedhashm</a>지렷다는거임general어쩌고해도해겨랑노디늑거ㅐ혁ㄹ됏다는거임비동기
CompletableFuture.runAsync()는 ForkJoinPool.commonPool()을 사용하는데, 기본적으로 CPU 코어 수 - 1개만큼 스레드를 사용합니다.현재 상황:
macOS에서 보통 8-16개 코어 → 7-15개 스레드
각 postId마다 하나씩 비동기 작업 생성
스레드 풀이 가득 차면 큐에 대기
문제점:
postId가 많으면 스레드 풀 부족으로 대기 발생
메모리 사용량 증가 가능
해결방법: 커스텀 스레드 풀 사용이제 최대 5개까지 동시에 AI 분석이 실행됩니다.변경사항:
Executors.newFixedThreadPool(5) → 5개 스레드 풀 생성
CompletableFuture.runAsync(..., aiAnalysisExecutor) → 커스텀 스레드 풀 사용
장점:
리소스 제한: AI 서버 부하 제어
메모리 관리: 동시 실행 수 제한으로 메모리 사용량 안정화
예측 가능: 5개씩 순차적으로 처리
필요시 조정:
AI 서버 성능에 따라 스레드 수 조정 가능
newFixedThreadPool(3) 또는 newFixedThreadPool(10) 등
이제 AI 분석 작업이 5개씩 순차적으로 처리되어 안정적으로 동작합니다.네, 맞습니다!동작 방식:
5개 스레드가 모두 사용 중 → 새로운 AI 분석 요청은 큐에서 대기
하나의 AI 분석 완료 → 해당 스레드가 해제됨
큐에서 대기 중인 작업 → 해제된 스레드로 즉시 실행
예시:스레드 풀 상태: [작업1][작업2][작업3][작업4][작업5] (모든 스레드 사용 중)
큐: [작업6][작업7][작업8] (대기 중) 작업3 완료 → 스레드 해제
스레드 풀: [작업1][작업2][빈칸][작업4][작업5]
큐에서 작업6이 즉시 빈 스레드로 이동
스레드 풀: [작업1][작업2][작업6][작업4][작업5]
특징:
FIFO (First In, First Out): 먼저 들어온 작업이 먼저 실행
자동 관리: 스레드 해제되면 큐에서 자동으로 가져와서 실행
무한 대기: 큐가 가득 차도 계속 대기 (메모리 허용하는 한)
장점:
AI 서버 부하 제어
순차적 처리로 안정성 확보
메모리 사용량 예측 가능
이렇게 하면 AI 서버에 과부하 없이 안정적으로 처리됩니다.]]></description><link>kt에이블/그외-에러.html</link><guid isPermaLink="false">kt에이블/그외 에러.md</guid><pubDate>Sun, 24 Aug 2025 21:27:23 GMT</pubDate></item><item><title><![CDATA[성과분석 예시응답값]]></title><description><![CDATA[ ~/personalproject/kt/big_pj/backend/_myDoc   feature/analytics ±  ./quick-test.sh
🚀 Analytics Service 빠른 API 테스트
Base URL: http://localhost:8080🏥 서비스 헬스체크
✅ 서비스 정상📋 사용자 정보
이메일: <a data-tooltip-position="top" aria-label="mailto:aa@example.com" rel="noopener nofollow" class="external-link is-unresolved" href="mailto:aa@example.com" target="_self">aa@example.com</a>
이름: 테스트사용자1756066092
전화번호: 010-4533-8603🔐 2단계: 로그인 시도
🔐 로그인 중...
POST http://localhost:8080/api/auth/login<br>
Body: {"email": "<a data-tooltip-position="top" aria-label="mailto:aa@example.com" rel="noopener nofollow" class="external-link is-unresolved" href="mailto:aa@example.com" target="_self">aa@example.com</a>", "password": "1q2w3e4r5t!"}
✅ 로그인 성공 (HTTP 200)
Access Token: eyJhbGciOiJIUzI1NiJ9... ✅ 로그인 성공!
Token: eyJhbGciOiJIUzI1NiJ9...🎉 인증 완료! Access Token 획득🔍 실시간 게시물 메트릭 (특정 게시물)
GET http://localhost:8080/api/analytics/realtime/posts/metrics?postId=1&amp;snsType=youtube
Token: eyJhbGciOiJIUzI1NiJ9...
✅ HTTP 200
Raw Response:
{
"isSuccess": true,
"message": "요청이 성공적으로 처리되었습니다.",
"result": {
"postId": 1,
"accountId": 1,
"likes": 10789,
"dislikes": 0,
"comments": 976,
"shares": 0,
"views": 13446043,
"fetchedAt": "2025-08-25T05:08:15.110170593",
"snsType": "youtube"
}
}🔍 실시간 게시물 메트릭 (최근 게시물 자동 선택)
GET http://localhost:8080/api/analytics/realtime/posts/metrics?snsType=youtube
Token: eyJhbGciOiJIUzI1NiJ9...
✅ HTTP 200
Raw Response:
{
"isSuccess": true,
"message": "요청이 성공적으로 처리되었습니다.",
"result": {
"postId": 1,
"accountId": 1,
"likes": 10789,
"dislikes": 0,
"comments": 976,
"shares": 0,
"views": 13446043,
"fetchedAt": "2025-08-25T05:08:15.404469718",
"snsType": "youtube"
}
}🔍 실시간 계정 메트릭
GET http://localhost:8080/api/analytics/realtime/accounts/metrics?snsType=youtube
Token: eyJhbGciOiJIUzI1NiJ9...
✅ HTTP 200
Raw Response:
{
"isSuccess": true,
"message": "요청이 성공적으로 처리되었습니다.",
"result": {
"accountId": 1,
"followers": 68300,
"views": 146633975,
"fetchedAt": "2025-08-25T05:08:15.568018176",
"snsType": "youtube"
}
}🔍 실시간 댓글 (특정 게시물, 3개만)
GET http://localhost:8080/api/analytics/realtime/posts/comments?postId=1&amp;snsType=youtube&amp;page=0&amp;size=3
Token: eyJhbGciOiJIUzI1NiJ9...
✅ HTTP 200
Raw Response:
{
"isSuccess": true,
"message": "요청이 성공적으로 처리되었습니다.",
"result": [
{
"commentId": "UgzwEQZWpeG7JMUidVN4AaABAg",
"authorId": "UCn9yy_uGmt-ptAohxFEQktA",
"text": "페이커 좀 귀여운듯?",
"likeCount": 0,
"publishedAt": "2025-08-22T18:03:34"
},
{
"commentId": "Ugyo94eRvTUsQ7fFw-Z4AaABAg",
"authorId": "UC51XrjCBis2-owDHUIJU8AA",
"text": "하 대상혁 오랜만에 봐도 이 광고에서 너무 귀엽게 나옴 이런 광고를 만들어준 왕뚜껑에게 감사하며 오늘도 사먹겠습니다..",
"likeCount": 0,
"publishedAt": "2025-08-19T10:06:23"
},
{
"commentId": "Ugw03jf1W6E1wDJ63cZ4AaABAg",
"authorId": "UCooJWhQsmQIOn2FXxTqsvOw",
"text": "조만간 뽀로로 잡겠는데?",
"likeCount": 0,
"publishedAt": "2025-08-19T04:27:03"
}
]
}🔍 실시간 댓글 (최근 게시물 자동 선택, 3개만)
GET http://localhost:8080/api/analytics/realtime/posts/comments?snsType=youtube&amp;page=0&amp;size=3
Token: eyJhbGciOiJIUzI1NiJ9...
✅ HTTP 200
Raw Response:
{
"isSuccess": true,
"message": "요청이 성공적으로 처리되었습니다.",
"result": [
{
"commentId": "UgzwEQZWpeG7JMUidVN4AaABAg",
"authorId": "UCn9yy_uGmt-ptAohxFEQktA",
"text": "페이커 좀 귀여운듯?",
"likeCount": 0,
"publishedAt": "2025-08-22T18:03:34"
},
{
"commentId": "Ugyo94eRvTUsQ7fFw-Z4AaABAg",
"authorId": "UC51XrjCBis2-owDHUIJU8AA",
"text": "하 대상혁 오랜만에 봐도 이 광고에서 너무 귀엽게 나옴 이런 광고를 만들어준 왕뚜껑에게 감사하며 오늘도 사먹겠습니다..",
"likeCount": 0,
"publishedAt": "2025-08-19T10:06:23"
},
{
"commentId": "Ugw03jf1W6E1wDJ63cZ4AaABAg",
"authorId": "UCooJWhQsmQIOn2FXxTqsvOw",
"text": "조만간 뽀로로 잡겠는데?",
"likeCount": 0,
"publishedAt": "2025-08-19T04:27:03"
}
]
}🔍 히스토리 게시물 메트릭 (특정 게시물)
GET http://localhost:8080/api/analytics/history/posts/metrics?date=2025-08-25&amp;postId=1&amp;snsType=youtube
Token: eyJhbGciOiJIUzI1NiJ9...
✅ HTTP 200
Raw Response:
{
"isSuccess": true,
"message": "요청이 성공적으로 처리되었습니다.",
"result": {
"postId": 1,
"accountId": 1,
"likes": 10789,
"dislikes": 0,
"comments": 976,
"shares": null,
"views": 13446043,
"fetchedAt": "2025-08-25T04:49:54.283372",
"snsType": "youtube"
}
}🔍 히스토리 게시물 메트릭 (SNS 타입 필터)
GET http://localhost:8080/api/analytics/history/posts/metrics?date=2025-08-25&amp;snsType=youtube
Token: eyJhbGciOiJIUzI1NiJ9...
✅ HTTP 200
Raw Response:
{
"isSuccess": true,
"message": "요청이 성공적으로 처리되었습니다.",
"result": {
"postId": 1,
"accountId": 1,
"likes": 10789,
"dislikes": 0,
"comments": 976,
"shares": null,
"views": 13446043,
"fetchedAt": "2025-08-25T04:49:54.283372",
"snsType": "youtube"
}
}🔍 히스토리 계정 메트릭
GET http://localhost:8080/api/analytics/history/accounts/metrics?date=2025-08-25&amp;snsType=youtube
Token: eyJhbGciOiJIUzI1NiJ9...
✅ HTTP 200
Raw Response:
{
"isSuccess": true,
"message": "요청이 성공적으로 처리되었습니다.",
"result": {
"accountId": 1,
"followers": 68300,
"views": 146633975,
"fetchedAt": "2025-08-25T04:49:54.477111",
"snsType": "youtube"
}
}🔍 히스토리 댓글 (특정 게시물, 3개만)
GET http://localhost:8080/api/analytics/history/posts/comments?date=2025-08-25&amp;postId=1&amp;snsType=youtube&amp;page=0&amp;size=3
Token: eyJhbGciOiJIUzI1NiJ9...
✅ HTTP 200
Raw Response:
{
"isSuccess": true,
"message": "요청이 성공적으로 처리되었습니다.",
"result": [
{
"commentId": "UgzCU2eajjWUc7jVkQN4AaABAg",
"authorId": "UCT4DznPPq-Na5UEOr6P12dQ",
"text": "대 상 혁",
"likeCount": 13,
"publishedAt": "2025-05-16T01:05:14"
},
{
"commentId": "UgxzOCiRK46w60mv7DF4AaABAg",
"authorId": "UC7zmKtVksn5nxVtyum-TAbw",
"text": "그저 빛.. 광고가 안보이는데요?",
"likeCount": 233,
"publishedAt": "2025-05-16T01:06:19"
},
{
"commentId": "UgyOZi6hlmK3_OChVBh4AaABAg",
"authorId": "UCa5CEHkbU9-HLSo_3ehsVqg",
"text": "대상혁",
"likeCount": 2,
"publishedAt": "2025-05-16T01:07:03"
}
]
}🔍 히스토리 댓글 (SNS 타입 필터, 3개만)
GET http://localhost:8080/api/analytics/history/posts/comments?date=2025-08-25&amp;snsType=youtube&amp;page=0&amp;size=3
Token: eyJhbGciOiJIUzI1NiJ9...
✅ HTTP 200
Raw Response:
{
"isSuccess": true,
"message": "요청이 성공적으로 처리되었습니다.",
"result": [
{
"commentId": "UgzCU2eajjWUc7jVkQN4AaABAg",
"authorId": "UCT4DznPPq-Na5UEOr6P12dQ",
"text": "대 상 혁",
"likeCount": 13,
"publishedAt": "2025-05-16T01:05:14"
},
{
"commentId": "UgxzOCiRK46w60mv7DF4AaABAg",
"authorId": "UC7zmKtVksn5nxVtyum-TAbw",
"text": "그저 빛.. 광고가 안보이는데요?",
"likeCount": 233,
"publishedAt": "2025-05-16T01:06:19"
},
{
"commentId": "UgyOZi6hlmK3_OChVBh4AaABAg",
"authorId": "UCa5CEHkbU9-HLSo_3ehsVqg",
"text": "대상혁",
"likeCount": 2,
"publishedAt": "2025-05-16T01:07:03"
}
]
}🔍 감정분석 (특정 게시물)
GET http://localhost:8080/api/analytics/history/posts/emotion-analysis?date=2025-08-25&amp;postId=1&amp;snsType=youtube
Token: eyJhbGciOiJIUzI1NiJ9...
✅ HTTP 200
Raw Response:
{
"isSuccess": true,
"message": "요청이 성공적으로 처리되었습니다.",
"result": {
"postId": 1,
"emotionSummary": {
"positiveCount": 0,
"neutralCount": 0,
"negativeCount": 0,
"totalCount": 0
},
"keywords": {
"positive": [],
"negative": []
}
}
}🔍 감정분석 (최근 게시물 자동 선택)
GET http://localhost:8080/api/analytics/history/posts/emotion-analysis?date=2025-08-25&amp;snsType=youtube
Token: eyJhbGciOiJIUzI1NiJ9...
✅ HTTP 200
Raw Response:
{
"isSuccess": true,
"message": "요청이 성공적으로 처리되었습니다.",
"result": {
"postId": 1,
"emotionSummary": {
"positiveCount": 0,
"neutralCount": 0,
"negativeCount": 0,
"totalCount": 0
},
"keywords": {
"positive": [],
"negative": []
}
}
}🎉 테스트 완료!📊 새로운 API 구조 요약:
• 실시간 API: /api/analytics/realtime/ (SNS 타입 필수)
• 히스토리 API: /api/analytics/history/ (날짜 필수)
• 배치 API: /api/analytics/batch/*🔧 주요 개선사항:
• SNS 타입 기반 필터링
• 최근 게시물 자동 선택
• 일관된 API 패턴
• 유연한 필터링 옵션
• 새로운 배치 API 엔드포인트
• JsonTypeInfo 제거로 응답 간소화
~/personalproject/kt/big_pj/backend/_myDoc   feature/analytics ±  ]]></description><link>kt에이블/성과분석-예시응답값.html</link><guid isPermaLink="false">kt에이블/성과분석 예시응답값.md</guid><pubDate>Sun, 24 Aug 2025 20:09:44 GMT</pubDate></item><item><title><![CDATA[캐시전략]]></title><description><![CDATA[@Cacheable과 CachePort는 캐싱을 구현하는 두 가지 다른 접근 방식이야.@Cacheable("postMetrics")
public List&lt;PostMetricsResponse&gt; getPostMetrics(Long postId) { // 메서드 실행 결과가 자동으로 캐시됨 return repository.findByPostId(postId);
}
특징:
선언적 캐싱 (AOP 기반)
메서드 레벨에서 간단하게 적용
Spring이 자동으로 캐시 키 생성, 저장, 조회 처리
설정이 간단하지만 세밀한 제어 어려움
@Service
public class AnalyticsService { private final CachePort cachePort; public List&lt;PostMetricsResponse&gt; getPostMetrics(Long postId) { // 명시적 캐시 제어 return cachePort.getCachedRealtimePostMetrics(postId) .orElseGet(() -&gt; { var metrics = repository.findByPostId(postId); cachePort.cacheRealtimePostMetrics(postId, metrics); return metrics; }); }
}
특징:
명시적 캐시 제어
비즈니스 로직과 캐시 로직 분리
세밀한 캐시 전략 구현 가능
테스트하기 쉬움 (Port 모킹 가능)
도메인 주도 설계 원칙 준수
@Cacheable 사용:
간단한 캐싱이 필요할 때
메서드 결과를 그대로 캐시할 때
빠른 프로토타이핑
CachePort 사용:
복잡한 캐시 전략이 필요할 때
캐시 무효화 로직이 복잡할 때
도메인 로직과 캐시 로직 분리가 중요할 때
테스트 용이성이 중요할 때
현재 프로젝트는 마이크로서비스 아키텍처이고 도메인 주도 설계를 따르고 있어서 CachePort가 더 적합해 보여.캐시역직렬화문제
@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)
objectMapper.enableDefaultTyping &lt;&lt; 애는죽음ObjectMapper objectMapper = new ObjectMapper();
PolymorphicTypeValidator ptv = BasicPolymorphicTypeValidator.builder()
.allowIfSubType("kt.aivle.analytics.adapter.in.web.dto.response") // 허용할 패키지 지정
.build();
objectMapper.activateDefaultTyping(ptv, ObjectMapper.DefaultTyping.NON_FINAL);<a rel="noopener nofollow" class="external-link is-unresolved" href="https://techblog.woowahan.com/22767/" target="_self">https://techblog.woowahan.com/22767/</a> ~/personalproject/kt/big_pj/backend/_myDoc   feature/analytics ±✚  docker exec -it redis redis-cli keys "*"
"realtime-post-metrics::post-1-null-youtube"
"refresh_token:a5889e13-c40b-4abc-9da2-92264b8032f8"
"realtime-post-metrics::post-1-1-null"
"realtime-account-metrics::account-1-youtube"
null역직열화안됨
현재&nbsp;GenericJackson2JsonRedisSerializer를&nbsp;사용하고&nbsp;있는데, 이게&nbsp;문제의&nbsp;원인이에요. 커스텀 직렬화/역직렬화를 위해&nbsp;RedisTemplate을 사용하는 방식으로 바꿔보죠.<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://choieungi.github.io/posts/spring-redis-cache-serialization-exception/" target="_self">https://choieungi.github.io/posts/spring-redis-cache-serialization-exception/</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://choieungi.github.io/posts/spring-redis-distributed-lock/" target="_self">https://choieungi.github.io/posts/spring-redis-distributed-lock/</a><br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://zzudev.tistory.com/51" target="_self">https://zzudev.tistory.com/51</a> snsType은&nbsp;필수로&nbsp;유지 계정/포스트 메트릭은&nbsp;List가 아닌 단일&nbsp;객체&nbsp;반환 계정은&nbsp;하나만 연결 가능하므로&nbsp;첫&nbsp;번째&nbsp;것 반환 포스트는&nbsp;지정 안&nbsp;되면 최근&nbsp;계정 기준 히스토리는&nbsp;date&nbsp;필수 특정 날짜에&nbsp;여러 데이터 있으면 시간이 늦은&nbsp;것 반환 먼저&nbsp;snsType을 다시&nbsp;필수로 만들고, 반환 타입을 수정해드릴게요.]]></description><link>kt에이블/빅프/캐시전략.html</link><guid isPermaLink="false">kt에이블/빅프/캐시전략.md</guid><pubDate>Sun, 24 Aug 2025 18:30:37 GMT</pubDate></item><item><title><![CDATA[별도의트랜젝션이필요한경우]]></title><description><![CDATA[별도 트랜잭션이 필요한 경우들을 설명해드릴게요:@Service
public class PointService { @Transactional public void processUserAction(Long userId) { // 메인 트랜잭션 User user = userRepository.findById(userId); user.addPoint(100); userRepository.save(user); // 별도 트랜잭션으로 포인트 히스토리 저장 // 메인 트랜잭션이 롤백되어도 히스토리는 남아있어야 함 savePointHistoryInNewTransaction(userId, 100); } @Transactional(propagation = Propagation.REQUIRES_NEW) public void savePointHistoryInNewTransaction(Long userId, int points) { PointHistory history = new PointHistory(userId, points); pointHistoryRepository.save(history); }
}
@Service
public class BatchProcessingService { public void processLargeDataset() { List&lt;Data&gt; allData = dataRepository.findAll(); // 10만 건 for (int i = 0; i &lt; allData.size(); i += 1000) { // 1000건씩 별도 트랜잭션으로 처리 // 중간에 실패해도 이전 1000건은 커밋됨 processBatchInTransaction(allData.subList(i, Math.min(i + 1000, allData.size()))); } } @Transactional public void processBatchInTransaction(List&lt;Data&gt; batch) { for (Data data : batch) { // 처리 로직 processedDataRepository.save(processData(data)); } }
}
@Service
public class PaymentService { @Transactional public void processPayment(PaymentRequest request) { // 1. 결제 정보 저장 Payment payment = new Payment(request); paymentRepository.save(payment); // 2. 외부 결제 API 호출 (별도 트랜잭션) // API 호출이 실패해도 결제 정보는 남아있어야 함 callPaymentApiInNewTransaction(payment.getId()); } @Transactional(propagation = Propagation.REQUIRES_NEW) public void callPaymentApiInNewTransaction(Long paymentId) { Payment payment = paymentRepository.findById(paymentId); // 외부 API 호출 (실패 가능성 높음) PaymentResult result = externalPaymentApi.process(payment); // API 결과 저장 payment.setStatus(result.getStatus()); paymentRepository.save(payment); }
}
@Service
public class UserActivityService { @Transactional public void updateUserProfile(Long userId, ProfileUpdateRequest request) { // 메인 비즈니스 로직 User user = userRepository.findById(userId); user.updateProfile(request); userRepository.save(user); // 활동 로그는 별도 트랜잭션으로 저장 // 메인 로직이 롤백되어도 로그는 남아있어야 함 logUserActivityInNewTransaction(userId, "PROFILE_UPDATE", request); } @Transactional(propagation = Propagation.REQUIRES_NEW) public void logUserActivityInNewTransaction(Long userId, String action, Object data) { UserActivity activity = new UserActivity(userId, action, data); userActivityRepository.save(activity); }
}
만약 댓글 수집에서 별도 트랜잭션이 필요하다면:@Service
public class CommentCollectionService { public void collectComments(Long postId) { // API 호출로 댓글 수집 (트랜잭션 외부) List&lt;Comment&gt; comments = fetchCommentsFromAPI(postId); // 각 댓글을 별도 트랜잭션으로 저장 // 하나 실패해도 다른 것들은 커밋됨 for (Comment comment : comments) { saveCommentInTransaction(comment); } } @Transactional public void saveCommentInTransaction(Comment comment) { // 감정분석 수행 Sentiment sentiment = emotionAnalysisService.analyze(comment.getContent()); // 댓글과 감정분석 결과를 함께 저장 CommentMetric metric = new CommentMetric(comment, sentiment); commentMetricRepository.save(metric); }
}
현재 댓글 수집에서는 별도 트랜잭션이 필요하지 않아요:
단순 저장 작업
일부 실패해도 계속 진행하는 것이 좋음
감정분석은 별도 비동기 작업으로 처리
별도 트랜잭션은 데이터 일관성이나 작업 분리가 중요한 경우에만 사용하면 돼요!]]></description><link>kt에이블/빅프/별도의트랜젝션이필요한경우.html</link><guid isPermaLink="false">kt에이블/빅프/별도의트랜젝션이필요한경우.md</guid><pubDate>Sat, 23 Aug 2025 19:10:02 GMT</pubDate></item><item><title><![CDATA[ㅇㅔ러]]></title><description><![CDATA[<img alt="ㅇㅔ러-1755935752638.png" src="kt에이블/빅프/assets/ㅇㅔ러-1755935752638.png" target="_self">
문제 해결됨! 데이터는 정상적으로 있음:&nbsp;Total&nbsp;posts&nbsp;to&nbsp;process:&nbsp;1로 나오고&nbsp;있어 수동&nbsp;배치는 정상 작동: 1개 포스트를&nbsp;찾아서 처리하고 있어 스케줄러 배치만&nbsp;문제:&nbsp;readCount=0,&nbsp;writeCount=0으로 나오는 이유는&nbsp;Spring&nbsp;Batch의 Job&nbsp;Instance가&nbsp;이미 완료되어서 재실행되지 않는 것 Spring&nbsp;Batch 동작 방식: 같은&nbsp;Job&nbsp;Parameters로&nbsp;실행된 Job&nbsp;Instance는 한 번만 실행됨 이미&nbsp;완료된&nbsp;Job&nbsp;Instance는&nbsp;재실행되지 않음 스케줄러가 매번&nbsp;같은 Job&nbsp;Parameters&nbsp;(new JobParameters())로 실행해서&nbsp;이미&nbsp;완료된 Job&nbsp;Instance를 찾고 있음 해결 방법: Job Parameters에 현재 시간을 추가해서&nbsp;매번 다른 Job&nbsp;Instance로&nbsp;실행되도록 수정해야 해.--
이벤트에러나면다맞감수정좀]]></description><link>kt에이블/빅프/ㅇㅔ러.html</link><guid isPermaLink="false">kt에이블/빅프/ㅇㅔ러.md</guid><pubDate>Sat, 23 Aug 2025 16:23:08 GMT</pubDate><enclosure url="kt에이블/빅프/assets/ㅇㅔ러-1755935752638.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="kt에이블/빅프/assets/ㅇㅔ러-1755935752638.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[analyics-README]]></title><description><![CDATA[YouTube 및 기타 SNS 플랫폼의 메트릭을 수집하고 분석하는 마이크로서비스입니다.
Port/Adapter 패턴 완전 적용: 모든 외부 의존성을 Port 인터페이스로 추상화 ExternalApiPort → YouTubeApiAdapter: YouTube API 통신
AiAnalysisPort → AiAnalysisAdapter: AI 분석 서버 통신
CachePort → RedisCacheAdapter: Redis 캐시 관리
ValidationPort → AnalyticsDomainService: 비즈니스 규칙 검증 의존성 역전 원칙: 서비스 계층이 인프라 계층에 의존하지 않음
테스트 용이성: Port 인터페이스를 통한 Mock 테스트 가능 Repository Ports: port/out/repository/ - 데이터 접근 관련 Port
Infrastructure Ports: port/out/infrastructure/ - 외부 시스템 통신 관련 Port
명확한 책임 분리: Repository와 Infrastructure Port가 명확히 구분 AiAnalysisService 제거: AiAnalysisAdapter로 대체
AnalyticsCacheService 제거: RedisCacheAdapter로 대체
MetricsValidator 제거: AnalyticsDomainService로 대체
YouTubeApiService 제거: YouTubeApiAdapter로 대체 공통 Repository 패턴: BaseJpaRepository 추상 클래스로 중복 코드 제거 모든 JpaRepository가 공통 기능을 상속받도록 리팩토링
findAllWithPagination, findByCreatedAtBetween 등 공통 메서드 제공 Validator 분리: AnalyticsRequestValidator로 입력 검증 로직 통합 ID 형식 검증, 페이지네이션 검증 등 공통 로직 분리
컨트롤러에서 중복되던 검증 코드 제거 예외 처리 개선: BusinessException으로 통일 AnalyticsErrorCode enum으로 구체적인 에러 코드 체계화
모든 예외를 BusinessException으로 통일하여 일관성 확보
기존의 개별 exception 클래스들 제거 (AnalyticsException, AnalyticsValidationException, AnalyticsNotFoundException, AnalyticsQuotaExceededException) LocalDate → Date 변경: 타임존 일관성을 위한 날짜 타입 통일 Jackson의 time-zone 설정과 일치하도록 Date 타입 사용
서울 타임존 기준으로 일관된 날짜 처리 날짜 필터링 단순화: 복잡한 범위 검색에서 직접 날짜 비교로 변경 DATE(createdAt) = DATE(:date) 쿼리로 정확한 날짜 매칭
불필요한 startDate/endDate 계산 로직 제거
성능 향상 및 코드 간소화 Repository 메서드 최적화: 날짜 전용 조회 메서드 추가 findByPostIdAndCreatedAtDate(Long postId, Date date)
findByAccountIdAndCreatedAtDate(Long accountId, Date date)
findByPostIdAndCreatedAtDateWithPagination(Long postId, Date date, Integer page, Integer size) 캐싱 전략: Redis 캐싱을 활용한 성능 최적화 @Cacheable 어노테이션으로 메트릭 조회 결과 캐싱
캐시 TTL 설정으로 데이터 신선도 관리 비동기 처리: CompletableFuture를 활용한 비동기 메트릭 조회 @Async 어노테이션으로 대용량 데이터 처리 성능 향상 배치 처리: 병렬 처리를 통한 대용량 데이터 처리 성능 향상 병렬 스레드 수 설정으로 리소스 최적화 Actuator: 헬스체크 및 메트릭 모니터링 엔드포인트 추가 /actuator/health: 서비스 상태 확인
/actuator/metrics: 성능 메트릭 조회
/api/analytics/health: 커스텀 헬스체크 엔드포인트 Swagger: API 문서화 개선 @Operation, @Parameter 어노테이션으로 상세한 API 문서화
각 엔드포인트별 설명 및 파라미터 정보 추가 로깅: 구조화된 로깅 및 캐시 디버깅 로그 추가 캐시 히트/미스 로그 추가
성능 모니터링을 위한 구조화된 로그 패턴 적용 YouTube API에서 실시간 데이터를 직접 조회하는 API들입니다.GET /api/analytics/realtime/posts/{postId}/metrics postId: 로컬 DB의 게시물 ID (Long)
응답: RealtimePostMetricsResponse - YouTube API 실시간 데이터
GET /api/analytics/realtime/accounts/{accountId}/metrics accountId: 로컬 DB의 계정 ID (Long)
응답: RealtimeAccountMetricsResponse - YouTube API 실시간 데이터
GET /api/analytics/realtime/posts/{postId}/comments?page=0&amp;size=20 postId: 로컬 DB의 게시물 ID (Long)
응답: PostCommentsQueryResponse - YouTube API 실시간 댓글
GET /api/analytics/realtime/posts/{postId}/emotion-analysis postId: 로컬 DB의 게시물 ID (Long)
응답: EmotionAnalysisResponse - 댓글 감정분석 결과 및 키워드
로컬 DB에 저장된 과거 데이터를 조회하는 API들입니다.GET /api/analytics/history/posts/{postId}/metrics?date=2024-01-15 postId: 로컬 DB의 게시물 ID (Long)
date: 조회할 날짜 (Date, 필수) - 서울 타임존 기준
응답: PostMetricsQueryResponse - DB 저장된 메트릭
GET /api/analytics/history/accounts/{accountId}/metrics?date=2024-01-15 accountId: 로컬 DB의 계정 ID (Long)
date: 조회할 날짜 (Date, 필수) - 서울 타임존 기준
응답: AccountMetricsQueryResponse - DB 저장된 메트릭
GET /api/analytics/history/posts/{postId}/comments?date=2024-01-15&amp;page=0&amp;size=20 postId: 로컬 DB의 게시물 ID (Long)
date: 조회할 날짜 (Date, 필수) - 서울 타임존 기준
응답: PostCommentsQueryResponse - DB 저장된 댓글
GET /api/analytics/history/posts/{postId}/emotion-analysis?date=2024-01-15 postId: 로컬 DB의 게시물 ID (Long)
date: 조회할 날짜 (Date, 필수) - 서울 타임존 기준
응답: EmotionAnalysisResponse - 댓글 감정분석 결과 및 키워드
메트릭 수집을 위한 배치 작업을 실행하고 모니터링하는 API들입니다.POST /api/analytics/batch/accounts/{accountId}/metrics
POST /api/analytics/batch/posts/{postId}/metrics
POST /api/analytics/batch/posts/{postId}/comments accountId/postId: 로컬 DB의 ID (Long)
응답: BatchOperationResponse - 배치 작업 실행 결과
GET /api/analytics/batch/status
GET /api/analytics/batch/status/{jobName} 응답: BatchJobStatusResponse - 배치 작업 상태 정보
서비스 상태 및 성능을 모니터링하는 API들입니다.GET /api/analytics/health 응답: HealthStatus - 서비스 상태 정보
GET /api/analytics/realtime/quota/status 응답: QuotaStatus - YouTube API 할당량 사용 현황
GET /actuator/health # 서비스 헬스체크
GET /actuator/metrics # 성능 메트릭
GET /actuator/prometheus # Prometheus 메트릭
// AiAnalysisRequest - AI 서버로 전송하는 댓글 데이터
{ "data": [ { "id": "1", "result": "댓글 내용" } ], "keyword": { "positive": ["긍정키워드1", "긍정키워드2"], "negative": ["부정키워드1", "부정키워드2"] }
} // AiAnalysisResponse - AI 서버로부터 받는 분석 결과
{ "emotion_analysis": { "individual_results": [ { "id": "1", "result": "POSITIVE" // POSITIVE, NEGATIVE, NEUTRAL } ] }, "keywords": { "positive": ["긍정키워드1", "긍정키워드2"], "negative": ["부정키워드1", "부정키워드2"] }
} // SentimentType Enum
public enum SentimentType { POSITIVE("POSITIVE"), // 긍정 NEGATIVE("NEGATIVE"), // 부정 NEUTRAL("NEUTRAL"); // 중립
}
// HealthStatus
{ "service": "analytics-service", "status": "UP", "timestamp": 1705123456789
} // QuotaStatus
{ "currentUsage": 1500, "limit": 10000, "timeUntilReset": 7200000, // 2시간 (밀리초) "lastResetTime": 1705116000000
}
// RealtimePostMetricsResponse
{ "postId": 1, // 로컬 DB ID "snsPostId": "w7YKHjH_MpM", // YouTube Video ID "accountId": 1, // 로컬 계정 ID "likes": 1234, // 실시간 좋아요 수 (Long으로 변경) "dislikes": 5, // 실시간 싫어요 수 "comments": 89, // 실시간 댓글 수 "shares": null, // 공유 수 (YouTube API v3 미지원) "views": 56789, // 실시간 조회 수 "fetchedAt": "2024-01-15T12:00:00", // API 호출 시간 "dataSource": "youtube_api", // 데이터 소스 "isCached": false // 캐시 여부
} // RealtimeAccountMetricsResponse
{ "accountId": 1, // 로컬 DB ID "snsAccountId": "UC123456789", // YouTube Channel ID "followers": 12345, // 실시간 구독자 수 "views": 1234567, // 실시간 총 조회 수 "fetchedAt": "2024-01-15T12:00:00", // API 호출 시간 "dataSource": "youtube_api", // 데이터 소스 "isCached": false // 캐시 여부
}
// PostMetricsQueryResponse
{ "postId": 1, // 로컬 DB ID "likes": "1234", // DB 저장된 좋아요 수 "dislikes": 5, // DB 저장된 싫어요 수 "comments": 89, // DB 저장된 댓글 수 "shares": null, // DB 저장된 공유 수 "views": 56789, // DB 저장된 조회 수 "crawledAt": "2024-01-15T12:00:00" // 수집 시간 (createdAt 기반)
} // AccountMetricsQueryResponse
{ "accountId": 1, // 로컬 DB ID "followers": 12345, // DB 저장된 구독자 수 "views": 1234567, // DB 저장된 총 조회 수 "crawledAt": "2024-01-15T12:00:00" // 수집 시간 (createdAt 기반)
} // PostCommentsQueryResponse
{ "commentId": "UgzDE8pqJ_c", // YouTube 댓글 ID "authorId": 123456789, // 댓글 작성자 ID "text": "댓글 내용", // 댓글 텍스트 "likeCount": 5, // 댓글 좋아요 수 "publishedAt": "2024-01-15T12:00:00", // 댓글 작성 시간 "crawledAt": "2024-01-15T12:00:00" // 수집 시간 (createdAt 기반)
}
// BatchOperationResponse
{ "operationName": "collectPostMetrics", "status": "SUCCESS", "executedAt": "2024-01-15T12:00:00", "message": "Post metrics collection completed successfully", "processedCount": 1, "failedCount": 0
} // BatchJobStatusResponse
{ "jobName": "collectPostMetrics_1", "status": "RUNNING", "startTime": "2024-01-15T12:00:00", "endTime": null, "progress": 50, "totalItems": 100, "errorMessage": null
} Hexagonal Architecture 완전 준수: Port/Adapter 패턴 완전 적용
의존성 역전 원칙: 모든 외부 의존성을 Port 인터페이스로 추상화
명확한 책임 분리: 각 계층의 역할 명확화
테스트 용이성: Port 인터페이스를 통한 Mock 테스트 가능 Bean Validation 추가: @Pattern, @Min, @Max 어노테이션
입력 검증 강화: 컨트롤러 레벨에서 엄격한 검증
Lombok 경고 해결: @Builder.Default 어노테이션 적용 기존: Guava Cache (인메모리, 단일 서버)
개선: Redis Cache (분산 캐시, 클러스터 공유)
세분화된 TTL: 메트릭 5분, 댓글 2분, 할당량 1분
스마트 캐시 무효화: 이벤트 발생 시 관련 캐시만 삭제
Port/Adapter 패턴: CachePort 인터페이스를 통한 캐시 추상화 AnalyticsErrorCode enum: 구체적인 에러 코드 체계
BusinessException 통일: 모든 예외를 BusinessException으로 통일
일관된 에러 응답: 모든 API에서 동일한 에러 형식
기존 예외 클래스 제거: AnalyticsException, AnalyticsValidationException, AnalyticsNotFoundException, AnalyticsQuotaExceededException 제거 SnsPostMetric: snsPostId, accountId 필드 제거 (FK로 충분히 조회 가능)
SnsAccountMetric: snsAccountId 필드 제거 (FK로 충분히 조회 가능)
SnsPostCommentMetric: authorName → authorId로 변경 (정확한 사용자 식별)
시간 필드 통합: crawledAt 제거, createdAt 기반으로 통일
데이터 중복 제거: FK 관계로 충분히 조회 가능한 필드들 제거
성능 최적화: 불필요한 필드 제거로 저장 공간 절약
예외 처리 통일: BusinessException으로 모든 예외 처리 통일 SentimentType Enum: 감정 분석 결과를 위한 타입 안전한 enum 추가 POSITIVE, NEGATIVE, NEUTRAL 값으로 감정 분류
Jackson @JsonCreator와 @JsonValue로 AI 서버 응답과 자동 매핑
대소문자 무관한 파싱 및 기본값 처리 AiAnalysisPort/AiAnalysisAdapter: AI 서버와의 통신을 위한 Port/Adapter 패턴 AiAnalysisPort 인터페이스로 AI 서버 통신 추상화
AiAnalysisAdapter에서 실제 HTTP 통신 구현
댓글 데이터를 AI 서버로 전송하여 감정 분석 수행
키워드 추출 기능 포함 (긍정/부정 분리) EmotionAnalysisService: 감정 분석 비즈니스 로직을 담당하는 서비스 AiAnalysisPort를 통한 AI 서버 호출
감정 분석 결과를 DB에 저장
에러 처리 및 재시도 로직 API 호출 최적화: 캐싱으로 중복 호출 방지
할당량 관리: YouTube API 할당량 효율적 사용
비동기 처리: 배치 작업의 비동기 실행
쿼리 최적화: createdAt 기반 인덱스 활용
날짜 필터링 최적화: DATE() 함수를 활용한 정확한 날짜 매칭
키워드 조회 최적화: DB 조회 2번 → 1번으로 최적화
Port/Adapter 패턴: 느슨한 결합으로 성능 최적화
Mock 테스트: 빠른 개발 사이클로 성능 개선
의존성 역전: 외부 시스템과의 느슨한 결합
확장성: 새로운 Adapter 추가 시 기존 코드 변경 없음
예외 처리 최적화: BusinessException으로 통일된 에러 처리로 성능 향상 역할: 히스토리 데이터 및 실시간 데이터 조회
주요 기능: 히스토리 메트릭/댓글 조회 (DB 기반)
실시간 메트릭/댓글 조회 (ExternalApiPort 기반)
감정분석 결과 조회
캐싱 적용 (@Cacheable) 특징: 히스토리/실시간 완전 분리
키워드 조회 최적화 (한 번에 조회 후 메모리에서 분리)
BusinessException을 통한 일관된 에러 처리 역할: 배치 작업을 통한 메트릭 수집
주요 기능: 계정 메트릭 수집 (ExternalApiPort 사용)
게시물 메트릭 수집 (ExternalApiPort 사용)
댓글 수집 및 감정분석 연동
병렬 처리 및 배치 최적화 특징: 새로운 댓글 발견 시 자동 감정분석 수행
YouTube API 할당량 관리
배치 작업 모니터링
BusinessException을 통한 에러 처리 역할: 댓글 감정분석 및 키워드 추출
주요 기능: AiAnalysisPort를 통한 AI 서버 통신
감정분석 결과 DB 저장
키워드 긍정/부정 분리 저장 특징: AI 서버 응답 처리
BusinessException을 통한 에러 처리 및 로깅 역할: 외부 이벤트 처리 (게시물/계정 생성/삭제)
주요 기능: 게시물 생성/삭제 이벤트 처리
SNS 계정 연결/해제 이벤트 처리
CachePort를 통한 관련 캐시 무효화 특징: 이벤트 기반 캐시 무효화
트랜잭션 처리
BusinessException을 통한 에러 처리 역할: 정기적인 메트릭 수집 스케줄링
주요 기능: 매일 오전 1시 자동 메트릭 수집
Spring Batch Job 실행
스케줄 관리 특징: @Scheduled 어노테이션 활용
중복 실행 방지 역할: 배치 작업 상태 모니터링
주요 기능: 배치 작업 진행률 추적
작업 상태 관리
에러 처리 특징: 실시간 모니터링
작업 히스토리 관리 ExternalApiPort: YouTube API 통신 추상화
AiAnalysisPort: AI 분석 서버 통신 추상화
CachePort: Redis 캐시 관리 추상화
ValidationPort: 비즈니스 규칙 검증 추상화 YouTubeApiAdapter: YouTube API 통신 구현
AiAnalysisAdapter: AI 분석 서버 통신 구현
RedisCacheAdapter: Redis 캐시 구현
AnalyticsDomainService: 비즈니스 규칙 검증 구현 SnsAccountRepositoryPort: 계정 데이터 접근
SnsPostRepositoryPort: 게시물 데이터 접근
SnsAccountMetricRepositoryPort: 계정 메트릭 데이터 접근
SnsPostMetricRepositoryPort: 게시물 메트릭 데이터 접근
SnsPostCommentMetricRepositoryPort: 댓글 메트릭 데이터 접근
PostCommentKeywordRepositoryPort: 키워드 데이터 접근
AnalyticsQueryService
├── ExternalApiPort (YouTubeApiAdapter)
├── CachePort (RedisCacheAdapter)
└── PostCommentKeywordRepositoryPort MetricsCollectionService
├── ExternalApiPort (YouTubeApiAdapter)
├── ValidationPort (AnalyticsDomainService)
├── EmotionAnalysisService
└── BatchJobMonitor EmotionAnalysisService
├── AiAnalysisPort (AiAnalysisAdapter)
└── PostCommentKeywordRepositoryPort AnalyticsEventService
├── CachePort (RedisCacheAdapter)
└── Repository Ports BatchScheduler
└── MetricsCollectionService
cd analytics-service
./gradlew bootRun
docker-compose up -d analytics-service
./gradlew :analytics-service:build
./quick-test.sh
./batch-test-api.sh
./clear-db-only.sh
# 실시간 로그
docker logs -f analytics-service # 스케줄러 로그
docker logs analytics-service | grep "DAILY METRICS" # 캐시 디버깅 로그
docker logs analytics-service | grep "CACHE"
curl -X GET "http://localhost:8080/api/analytics/batch/status" \ -H "X-USER-ID: 4" \ -H "Authorization: Bearer YOUR_TOKEN"
# Redis 캐시 확인
redis-cli keys "analytics:*" # 할당량 상태 확인
curl -X GET "http://localhost:8080/api/analytics/realtime/quota/status" # 헬스체크
curl -X GET "http://localhost:8080/api/analytics/health"
# 서비스 헬스체크
curl -X GET "http://localhost:8080/actuator/health" # 성능 메트릭
curl -X GET "http://localhost:8080/actuator/metrics" # Prometheus 메트릭
curl -X GET "http://localhost:8080/actuator/prometheus"
@Scheduled(cron = "0 0 01 * * ?", zone = "Asia/Seoul")
public void runDailyMetricsCollectionJob() 실행 시간: 매일 오전 1시 (한국 시간)
실행 순서: 계정 메트릭 → 게시물 메트릭 → 댓글 수집
Spring Batch Job: dailyMetricsCollectionJob
// @Scheduled(cron = "0 */2 * * * ?", zone = "Asia/Seoul")
// @Profile("dev")
public void runTestMetricsCollectionJob() 실행 주기: 2분마다 (테스트용)
프로파일: dev 환경에서만 활성화
용도: 개발 및 테스트를 위한 빠른 수집
매일 9시 → BatchScheduler.runDailyMetricsCollectionJob() ↓
JobParameters 생성 (실행시간, 타임스탬프) ↓
Spring Batch Job 실행
dailyMetricsCollectionJob ↓
Step 1: collectAccountMetricsStep (계정 메트릭 수집) ↓
Step 2: collectPostMetricsStep (게시물 메트릭 수집) ↓
Step 3: collectPostCommentsStep (댓글 수집)
processBatch() 메서드 ↓
1. 전체 아이템 수 조회
2. 페이지네이션으로 배치 처리 (기본 100개씩)
3. 각 아이템별 개별 처리
4. 진행률 모니터링
5. 에러 처리 및 재시도
catch (BusinessException e) { if (e.getMessage().contains("할당량")) { log.warn("YouTube API quota exceeded during {} collection. Stopping batch.", itemType); break; // 배치 작업 중단 }
} 동작: 즉시 배치 작업 중단
복구: 다음 날 9시에 다시 실행
데이터 손실: 없음 (부분적으로 수집된 데이터는 저장됨)
catch (JobExecutionAlreadyRunningException e) { log.error("❌ Batch job is already running: {}", e.getMessage());
} 동작: 이미 실행 중인 배치가 있으면 새 배치 실행 안함
복구: 기존 배치 완료 후 다음 스케줄까지 대기
catch (Exception e) { batchJobMonitor.recordJobFailure(jobName, e.getMessage()); log.error("Failed to collect {}", itemType, e); throw new BusinessException(AnalyticsErrorCode.INTERNAL_ERROR);
} 동작: 실패한 배치 작업 상태 기록
복구: 수동으로 재실행 가능 (API 엔드포인트 제공)
데이터 손실: 실패한 아이템만 손실, 성공한 아이템은 저장됨
# 모든 배치 작업 상태
GET /api/analytics/batch/status # 특정 배치 작업 상태
GET /api/analytics/batch/status/{jobName}
{ "jobName": "account-metrics-collection", "status": "RUNNING", // RUNNING, COMPLETED, FAILED "startTime": "2024-01-15T09:00:00", "endTime": null, "progress": 50, // 처리된 아이템 수 "totalItems": 100, // 전체 아이템 수 "errorMessage": null // 에러 메시지 (실패 시)
}
# 배치 작업 시작/완료 로그
docker logs analytics-service | grep "Daily metrics collection" # 실시간 진행률 로그
docker logs analytics-service | grep "Batch job progress" # 에러 로그
docker logs analytics-service | grep "❌"
POST /api/analytics/batch/metrics
# 계정 메트릭
POST /api/analytics/batch/accounts/metrics
POST /api/analytics/batch/accounts/{accountId}/metrics # 게시물 메트릭
POST /api/analytics/batch/posts/metrics
POST /api/analytics/batch/posts/{postId}/metrics # 댓글 수집
POST /api/analytics/batch/posts/comments
POST /api/analytics/batch/posts/{postId}/comments 재시도: @Retryable 어노테이션으로 최대 3회 재시도
백오프: 1초 간격으로 지수 백오프
복구: 재시도 성공 시 정상 처리, 실패 시 다음 배치에서 재시도 트랜잭션: 각 배치 아이템별 트랜잭션 처리
롤백: 실패 시 해당 아이템만 롤백
복구: 성공한 아이템은 유지, 실패한 아이템만 재처리 할당량 초과: 즉시 배치 중단, 다음 날 재시도
API 오류: 개별 아이템 실패 처리, 배치 계속 진행
복구: 실패한 아이템은 수동 재실행 가능 배치 크기: 기본 100개씩 처리
병렬 스레드: 4개 스레드로 병렬 처리
메모리 효율성: 페이지네이션으로 메모리 사용량 제한 중복 방지: 최근 1시간 내 데이터가 있으면 스킵
API 호출 최소화: 캐싱으로 중복 API 호출 방지
성능 향상: 캐시 히트 시 즉시 응답 실시간 모니터링: YouTube API 할당량 사용량 추적
스마트 중단: 할당량 초과 시 즉시 배치 중단
효율적 사용: 배치 처리로 API 호출 최적화 스케줄: 매일 9시 자동 실행
독립성: 이전 배치 실패와 무관하게 새 배치 시작
데이터 무결성: 중복 데이터 방지 로직으로 데이터 일관성 보장 히스토리 보존: 이전 수집 데이터는 그대로 유지
증분 수집: 새로운 데이터만 추가 수집
데이터 갱신: 기존 데이터는 최신 정보로 업데이트 수동 재실행: API를 통한 개별 아이템 재처리
선택적 복구: 실패한 아이템만 선택적으로 재처리
데이터 보완: 누락된 데이터 보완 가능
analytics-service/
├── adapter/
│ ├── in/
│ │ ├── web/ # REST API 컨트롤러
│ │ │ ├── dto/ # DTO 클래스들
│ │ │ └── validator/ # 입력 검증 로직
│ │ └── event/ # 이벤트 컨트롤러
│ └── out/
│ ├── persistence/ # 데이터 접근 계층
│ │ └── repository/ # JPA Repository
│ └── infrastructure/ # 외부 시스템 통신 계층
│ ├── YouTubeApiAdapter
│ ├── AiAnalysisAdapter
│ └── RedisCacheAdapter
├── application/
│ ├── port/
│ │ ├── in/ # UseCase 인터페이스
│ │ └── out/ # Port 인터페이스
│ │ ├── repository/ # Repository Ports
│ │ ├── infrastructure/ # Infrastructure Ports
│ │ └── dto/ # Port DTO 클래스들
│ └── service/ # 비즈니스 로직
├── domain/
│ ├── entity/ # 도메인 엔티티
│ ├── model/ # 도메인 모델 (SnsType, SentimentType)
│ └── service/ # 도메인 서비스 (AnalyticsDomainService)
├── exception/ # 예외 처리 (AnalyticsErrorCode)
└── config/ # 설정 클래스 헥사고날 아키텍처: Port/Adapter 패턴 완전 적용
의존성 역전: 모든 외부 의존성을 Port 인터페이스로 추상화
공통 Repository: BaseJpaRepository로 중복 코드 제거
Validator 분리: 입력 검증 로직을 별도 패키지로 분리
예외 처리: BusinessException으로 통일된 에러 처리
캐싱 계층: Redis 캐싱을 통한 성능 최적화
모니터링: Actuator를 통한 헬스체크 및 메트릭 수집 Redis Cache (분산 캐시) 메트릭 데이터: 5분 TTL (@Cacheable(value = "post-metrics"))
댓글 데이터: 2분 TTL (@Cacheable(value = "comments"))
할당량 정보: 1분 TTL (Guava Cache) Port/Adapter 패턴 CachePort 인터페이스로 캐시 추상화
RedisCacheAdapter에서 실제 Redis 구현
서비스 계층은 Port를 통해서만 캐시 접근 이벤트 기반 무효화 게시물 생성/삭제 시 관련 캐시 삭제
계정 연결/해제 시 관련 캐시 삭제
CachePort.evict* 메서드로 캐시 무효화 캐시 키 패턴 post-metrics::{userId}-{postId}-{date}
account-metrics::{userId}-{accountId}-{date}
comments::{postId}-{page}-{size} 성능 최적화 캐시 히트율 모니터링
캐시 미스 시 자동 재로딩
배치 작업 시 캐시 일괄 갱신 INVALID_POST_ID: 잘못된 게시물 ID 형식입니다.
INVALID_ACCOUNT_ID: 잘못된 계정 ID 형식입니다.
INVALID_USER_ID: 잘못된 사용자 ID 형식입니다.
INVALID_DATE: 잘못된 날짜 매개변수입니다.
INVALID_PAGINATION: 잘못된 페이지네이션 매개변수입니다. POST_NOT_FOUND: 게시물을 찾을 수 없습니다.
ACCOUNT_NOT_FOUND: 계정을 찾을 수 없습니다.
NO_DATA_AVAILABLE: 지정된 조건에 해당하는 데이터가 없습니다. YOUTUBE_API_ERROR: YouTube API 오류가 발생했습니다.
YOUTUBE_QUOTA_EXCEEDED: YouTube API 할당량이 초과되었습니다.
YOUTUBE_VIDEO_NOT_FOUND: YouTube 비디오를 찾을 수 없습니다.
YOUTUBE_CHANNEL_NOT_FOUND: YouTube 채널을 찾을 수 없습니다. AI_ANALYSIS_ERROR: AI 분석 서비스 오류가 발생했습니다.
EMOTION_ANALYSIS_ERROR: 감정 분석에 실패했습니다. UNAUTHORIZED_ACCESS: 데이터에 대한 권한이 없습니다.
USER_MISMATCH: 사용자 ID가 일치하지 않습니다. INTERNAL_ERROR: 내부 서버 오류가 발생했습니다.
DATABASE_ERROR: 데이터베이스 작업에 실패했습니다.
CACHE_ERROR: 캐시 작업에 실패했습니다.
app: youtube: api: quota-limit: 10000 # YouTube API 일일 할당량 quota-window: 86400 # 할당량 윈도우 (초) batch-size: 100 # 배치 처리 크기 retry-attempts: 3 # 재시도 횟수 retry-delay: 1000 # 재시도 지연 (밀리초) parallel-threads: 4 # 병렬 처리 스레드 수 cache: ttl: post-metrics: 300 # 게시물 메트릭 캐시 TTL (초) account-metrics: 300 # 계정 메트릭 캐시 TTL (초) comments: 120 # 댓글 캐시 TTL (초) ai: analysis: url: http://localhost:8081/analyze # AI 분석 서버 URL
management: endpoints: web: exposure: include: health,info,metrics,prometheus base-path: /actuator endpoint: health: show-details: when-authorized show-components: always metrics: export: prometheus: enabled: true 중복 필드 제거: FK로 충분히 조회 가능한 필드들 제거
시간 필드 통합: crawledAt → createdAt 기반으로 통일
사용자 식별 개선: authorName → authorId로 변경
저장 공간 절약: 불필요한 필드 제거로 DB 용량 최적화 LocalDate → Date 변경: 타임존 일관성을 위한 날짜 타입 통일
날짜 필터링 단순화: 복잡한 범위 검색에서 직접 날짜 비교로 변경
Repository 메서드 최적화: 날짜 전용 조회 메서드 추가
성능 향상: 불필요한 날짜 변환 로직 제거 SentimentType Enum: 감정 분석 결과를 위한 타입 안전한 enum
AiAnalysisRequest/AiAnalysisResponse DTO: AI 서버와의 통신을 위한 전용 DTO
EmotionAnalysisService: 감정 분석 로직을 담당하는 서비스
키워드 긍정/부정 분리: AI 서버 요청/응답에서 키워드를 긍정/부정으로 분리 인덱스 활용: createdAt 기반 인덱스로 조회 성능 향상
FK 관계 활용: 중복 데이터 제거로 조인 성능 개선
메모리 효율성: 엔티티 크기 감소로 메모리 사용량 최적화
날짜 필터링 최적화: DATE(createdAt) = DATE(:date) 쿼리로 정확한 날짜 매칭
키워드 조회 최적화: DB 조회 2번 → 1번으로 최적화 정규화 강화: 중복 데이터 제거로 데이터 일관성 확보
관계 명확화: FK 관계를 통한 명확한 데이터 관계
무결성 보장: 중복 필드 제거로 데이터 무결성 향상 완전한 분리: 히스토리 조회와 실시간 조회를 완전히 분리
명확한 역할: 각 API의 역할과 책임 명확화
성능 최적화: 불필요한 실시간 데이터 조회 로직 제거
]]></description><link>kt에이블/빅프/ai문서/analyics-readme.html</link><guid isPermaLink="false">kt에이블/빅프/ai문서/analyics-README.md</guid><pubDate>Fri, 22 Aug 2025 04:49:31 GMT</pubDate></item><item><title><![CDATA[service]]></title><description><![CDATA[Analytics Service는 SNS 계정과 게시물의 메트릭을 수집, 분석하고 실시간 데이터를 제공하는 마이크로서비스입니다.분리하지 않는 이유:
단일 도메인: 모든 기능이 "분석/메트릭 수집"이라는 하나의 도메인에 속함
강한 응집도: 서비스들이 서로 밀접하게 연관되어 있음
공유 데이터: 동일한 엔티티(SnsAccount, SnsPost)를 여러 서비스가 공유
트랜잭션 경계: 메트릭 수집→분석→저장이 하나의 트랜잭션으로 처리되어야 함
서비스 분리 기준 (현재 미충족):
비즈니스 도메인 분리: 다른 도메인(예: 사용자 관리, 결제 등)과 분리
독립적 배포: 각 서비스가 독립적으로 배포/스케일링 가능
데이터 소유권: 각 서비스가 고유한 데이터를 소유
팀 구조: 다른 팀이 담당하는 기능
향후 분리 고려 시점:
YouTube 외 다른 SNS 플랫폼 추가 시 → SnsPlatformService 분리
AI 분석 로직이 복잡해질 때 → AiAnalysisService 독립 서비스화
실시간 알림 기능 추가 시 → NotificationService 분리
분리 기준:
책임 분리: 각 서비스가 명확한 단일 책임을 가짐
데이터 독립성: 각 서비스가 고유한 데이터를 소유
스케일링 요구사항: 서로 다른 스케일링 패턴
기술 스택: 다른 기술적 요구사항
제안하는 서비스 분리:책임: 외부 API에서 데이터 수집
포함 서비스:
YouTubeApiService
MetricsCollectionService BatchScheduler
BatchJobMonitor
MetricsValidator
데이터 소유:
SnsAccountMetric
SnsPostMetric
SnsPostCommentMetric
스케일링: 배치 작업 기반, 주기적 실행책임: 감정분석 및 키워드 추출
포함 서비스:
AiAnalysisService (현재)
EmotionAnalysisService
데이터 소유:
PostCommentKeyword
스케일링: AI 모델 로딩, GPU 리소스 필요책임: 분석 데이터 조회 및 캐싱
포함 서비스:
AnalyticsQueryService (현재)
AnalyticsCacheService
데이터 소유: 없음 (읽기 전용)스케일링: 높은 읽기 요청, 캐시 기반책임: Kafka 이벤트 처리
포함 서비스:
AnalyticsEventService
데이터 소유:
SnsAccount
SnsPost
스케일링: 이벤트 기반, 실시간 처리분리 시 장점:
독립적 스케일링: 각 서비스별로 다른 리소스 할당
기술 스택 최적화: AI 서비스는 GPU, 조회 서비스는 캐시 최적화
장애 격리: 한 서비스 장애가 다른 서비스에 영향 최소화
팀 분리: 각 서비스별로 다른 팀이 담당 가능
분리 시 단점:
복잡성 증가: 서비스 간 통신, 데이터 동기화 필요
트랜잭션 관리: 분산 트랜잭션 처리 복잡
운영 오버헤드: 모니터링, 배포, 로깅 복잡화
현재 구조 평가: 헥사고날 아키텍처 잘 구현됨1. 도메인 계층 (Domain Layer)
엔티티: SnsAccount, SnsPost, SnsAccountMetric, SnsPostMetric, SnsPostCommentMetric, PostCommentKeyword
모델: SentimentType, SnsType enum
순수한 비즈니스 로직: 도메인 엔티티에 JPA 어노테이션만 포함
2. 애플리케이션 계층 (Application Layer)
UseCase 인터페이스: AnalyticsQueryUseCase, AnalyticsEventUseCase, MetricsCollectionUseCase
서비스: Application Service들이 UseCase 구현
Port 정의: In/Out Port 인터페이스 명확히 분리
3. 어댑터 계층 (Adapter Layer)
Inbound Adapters: Web: BatchController, HistoricalAnalyticsController
Event: PostEventConsumer, SnsAccountEventConsumer Outbound Adapters: Persistence: SnsAccountRepository, SnsPostRepository 등 1. 인증/인가 처리
현재: @RequestHeader("X-USER-ID")로 직접 처리
평가: ✅ 적절한 구현 - Gateway에서 이미 인증 처리 후 전달
이유: Gateway에서 JWT 검증 후 X-USER-ID 헤더로 전달
Analytics Service는 비즈니스 로직에만 집중
MSA에서 각 서비스의 책임 분리 원칙에 부합 2. 데이터 검증 로직
현재: AnalyticsRequestValidator가 어댑터 계층에 위치
평가: ⚠️ 개선 필요 - 입력 검증은 어댑터 계층에 적합하지만 비즈니스 규칙은 분리 필요
해결방안: 입력 형식 검증: 어댑터 계층 유지 (현재 적절)
비즈니스 규칙 검증: 도메인 서비스로 이동
예: 날짜 범위, 사용자 권한 등은 도메인 로직 3. 캐시 관리
현재: AnalyticsCacheService가 애플리케이션 계층에 위치
평가: ⚠️ 개선 필요 - 캐시 전략은 비즈니스 로직이지만 구현은 인프라 관심사
해결방안: 캐시 전략 결정: 애플리케이션 계층 유지 (비즈니스 로직)
캐시 구현: Infrastructure Adapter로 이동 (RedisAdapter)
Port 인터페이스로 분리하여 의존성 역전 4. 배치 작업 관리
현재: BatchScheduler, BatchJobMonitor가 애플리케이션 계층에 위치
평가: ✅ 올바른 위치 - 비즈니스 로직이므로 애플리케이션 계층에 적합
이유: 메트릭 수집은 핵심 비즈니스 기능
스케줄링은 비즈니스 요구사항 (매일 오전 1시)
모니터링은 비즈니스 프로세스 추적 5. 외부 API 통신
현재: YouTubeApiService가 애플리케이션 계층에 위치
평가: ⚠️ 개선 필요 - YouTube API 통신은 인프라 관심사
해결방안: Infrastructure Adapter로 이동 (YouTubeApiAdapter)
ExternalApiPort 인터페이스 정의
애플리케이션 계층은 Port를 통해서만 외부 API 접근 1. 인증/인가 분리// 현재 구현이 적절함 - Gateway에서 처리
@GetMapping("/posts/{postId}/metrics")
public ResponseEntity&lt;ApiResponse&lt;List&lt;PostMetricsQueryResponse&gt;&gt;&gt; getHistoricalPostMetrics( @PathVariable String postId, @RequestParam LocalDate date, @RequestHeader("X-USER-ID") String userId) { // Gateway에서 이미 인증 처리됨
}
2. 인프라 어댑터 분리// Port 인터페이스 정의
public interface ExternalApiPort { ChannelStatistics getChannelStatistics(String channelId); VideoStatistics getVideoStatistics(String videoId); List&lt;PostCommentsQueryResponse&gt; getVideoComments(String videoId);
} public interface CachePort { void cacheRealtimePostMetrics(Long postId, List&lt;RealtimePostMetricsResponse&gt; metrics); Optional&lt;List&lt;RealtimePostMetricsResponse&gt;&gt; getCachedRealtimePostMetrics(Long postId); void evictPostCache(Long postId);
} // Infrastructure Adapter 구현
@Component
public class YouTubeApiAdapter implements ExternalApiPort { // YouTube API 통신 로직
} @Component public class RedisCacheAdapter implements CachePort { // Redis 캐시 로직
}
3. 도메인 서비스 강화// 도메인 서비스로 비즈니스 규칙 검증 이동
@Component
public class AnalyticsDomainService { public void validateMetrics(MetricsData data) { // 비즈니스 규칙 검증 (구독자 수, 조회수 등) } public void validateDateRange(LocalDate startDate, LocalDate endDate) { // 날짜 범위 비즈니스 규칙 검증 } public void validateUserAccess(Long userId, Long accountId) { // 사용자 접근 권한 비즈니스 규칙 검증 }
}
4. 전체적인 아키텍처 개선 방향
의존성 역전: 모든 외부 의존성을 Port 인터페이스로 추상화
단일 책임: 각 계층이 명확한 책임을 가지도록 분리
테스트 용이성: Port 인터페이스를 통한 Mock 테스트 가능
1. Port 인터페이스 생성
ExternalApiPort: YouTube API 통신 추상화
AiAnalysisPort: AI 분석 서버 통신 추상화
CachePort: Redis 캐시 관리 추상화 ValidationPort: 비즈니스 규칙 검증 추상화
2. Infrastructure Adapter 구현
YouTubeApiAdapter: YouTube API 통신 구현
AiAnalysisAdapter: AI 분석 서버 통신 구현
RedisCacheAdapter: Redis 캐시 구현
AnalyticsDomainService: 비즈니스 규칙 검증 구현
3. 서비스 계층 개선
MetricsCollectionService: Port 인터페이스 사용으로 외부 의존성 제거
EmotionAnalysisService: AiAnalysisPort 사용으로 AI 서비스 의존성 제거
AnalyticsQueryService: Port 인터페이스 사용으로 캐시 의존성 제거
모든 서비스가 Port를 통해서만 외부 시스템 접근
4. 의존성 역전 원칙 적용Application Service → Port Interface ← Infrastructure Adapter
5. 테스트 용이성 향상
Port 인터페이스를 통한 Mock 테스트 가능
각 계층별 독립적 테스트 가능
외부 시스템 의존성 제거로 단위 테스트 간소화
6. 폴더 구조 개선 Repository Ports: port/out/repository/ - 데이터 접근 관련 Port SnsAccountRepositoryPort
SnsPostRepositoryPort
SnsAccountMetricRepositoryPort
SnsPostMetricRepositoryPort
SnsPostCommentMetricRepositoryPort
PostCommentKeywordRepositoryPort Infrastructure Ports: port/out/infrastructure/ - 외부 시스템 통신 관련 Port ExternalApiPort - YouTube API 통신
AiAnalysisPort - AI 분석 서버 통신
CachePort - Redis 캐시 관리
ValidationPort - 비즈니스 규칙 검증 개선 효과:
명확한 책임 분리: Repository와 Infrastructure Port가 명확히 구분
가독성 향상: 폴더 구조만 봐도 Port의 목적을 쉽게 파악
유지보수성: 관련 Port들을 쉽게 찾고 관리 가능
위치: BatchScheduler.java
역할: 정기적인 메트릭 수집 배치 작업을 스케줄링주요 기능:
매일 오전 1시 메트릭 수집 배치 실행 (@Scheduled(cron = "0 22 1 * * ?"))
Spring Batch JobLauncher를 통한 배치 작업 실행
중복 실행 방지 및 예외 처리
테스트용 5분마다 실행 옵션 (개발환경)
핵심 메서드:@Scheduled(cron = "0 22 1 * * ?", zone = "Asia/Seoul")
public void runDailyMetricsCollectionJob()
위치: MetricsCollectionService.java
역할: YouTube API를 통한 계정/게시물 메트릭 수집주요 기능:
계정 메트릭 수집: 구독자 수, 총 조회수
게시물 메트릭 수집: 조회수, 좋아요, 댓글 수
댓글 수집: 게시물별 댓글 데이터 수집
배치 처리: 대량 데이터를 효율적으로 처리
할당량 관리: YouTube API 할당량 초과 시 배치 중단
핵심 메서드:public void collectAccountMetrics() // 계정 메트릭 수집
public void collectPostMetrics() // 게시물 메트릭 수집 public void collectPostComments() // 댓글 수집
설정값:
batch-size: 100 (배치 크기)
retry-attempts: 3 (재시도 횟수)
parallel-threads: 4 (병렬 처리 스레드)
위치: EmotionAnalysisService.java
역할: 댓글 감정분석 결과를 처리하고 저장주요 기능:
감정분석 실행: AiAnalysisPort를 통한 분석 수행
댓글 메트릭 저장: 감정분석 결과와 함께 댓글 데이터 저장
키워드 저장: 긍정/부정 키워드를 DB에 저장
데이터 정리: 기존 키워드 삭제 후 새로운 키워드 저장
핵심 메서드:public void analyzeAndSaveEmotions(Long postId, List&lt;PostCommentsQueryResponse&gt; comments)
저장 데이터:
SnsPostCommentMetric: 댓글별 감정분석 결과
PostCommentKeyword: 긍정/부정 키워드
위치: AnalyticsQueryService.java
역할: 수집된 메트릭 데이터를 조회하고 분석 결과 제공주요 기능:
게시물 메트릭 조회: 캐시 적용된 메트릭 데이터 조회
계정 메트릭 조회: 계정별 통계 데이터 조회
댓글 조회: 게시물별 댓글 데이터 조회
비동기 처리: @Async를 통한 비동기 조회
실시간 데이터: ExternalApiPort를 통한 실시간 메트릭 조회
핵심 메서드:@Cacheable(value = "post-metrics")
public List&lt;PostMetricsQueryResponse&gt; getPostMetrics(String userId, PostMetricsQueryRequest request) @Cacheable(value = "account-metrics") public List&lt;AccountMetricsQueryResponse&gt; getAccountMetrics(String userId, AccountMetricsQueryRequest request) // 실시간 데이터 조회
public List&lt;RealtimePostMetricsResponse&gt; getRealtimePostMetrics(String userId, PostMetricsQueryRequest request)
위치: BatchJobMonitor.java
역할: 배치 작업의 상태와 진행상황을 모니터링주요 기능:
작업 상태 추적: RUNNING, COMPLETED, FAILED 상태 관리
진행률 모니터링: 처리된 항목 수와 전체 항목 수 추적
에러 로깅: 작업 실패 시 에러 메시지 저장
메모리 기반: ConcurrentHashMap을 통한 상태 저장
핵심 메서드:public void recordJobStart(String jobName)
public void recordJobProgress(String jobName, int processed, int total)
public void recordJobSuccess(String jobName)
public void recordJobFailure(String jobName, String errorMessage)
위치: AnalyticsEventService.java
역할: Kafka 이벤트를 통한 SNS 계정/게시물 변경사항 처리주요 기능:
게시물 생성 이벤트: 새 게시물 등록
게시물 삭제 이벤트: 게시물 삭제
계정 연결 이벤트: SNS 계정 연결
계정 해제 이벤트: SNS 계정 해제
캐시 무효화: CachePort를 통한 데이터 변경 시 관련 캐시 삭제
핵심 메서드:public void handlePostCreated(SnsPostEvent event)
public void handlePostDeleted(SnsPostEvent event)
public void handleSnsAccountConnected(SnsAccountEvent event)
public void handleSnsAccountDisconnected(SnsAccountEvent event) 이벤트 수신 → AnalyticsEventService가 Kafka 이벤트 처리
정기 수집 → BatchScheduler가 MetricsCollectionService 실행
API 호출 → MetricsCollectionService가 ExternalApiPort를 통해 YouTube API 호출
감정분석 → EmotionAnalysisService가 AiAnalysisPort를 통해 외부 AI 서버 호출
데이터 저장 → EmotionAnalysisService가 분석 결과 저장
캐시 관리 → CachePort 구현체가 성능 최적화
데이터 조회 → AnalyticsQueryService가 클라이언트 요청 처리
BatchScheduler → MetricsCollectionService → ExternalApiPort → YouTubeApiAdapter ↓ EmotionAnalysisService → AiAnalysisPort → AiAnalysisAdapter ↓ AnalyticsQueryService → CachePort → RedisCacheAdapter ↓ AnalyticsEventService → CachePort → RedisCacheAdapter app.youtube.api.key: YouTube API 키
app.youtube.api.batch-size: 배치 크기 (기본값: 100)
app.youtube.api.retry-attempts: 재시도 횟수 (기본값: 3)
app.youtube.api.parallel-threads: 병렬 스레드 수 (기본값: 4)
ai.analysis.url: AI 분석 서버 URL (기본값: http://localhost:8081/analyze) 매일 오전 1시: 메트릭 수집 배치 실행
개발환경: 5분마다 테스트 실행 (주석 처리됨) AnalyticsQuotaExceededException: YouTube API 할당량 초과
AnalyticsException: 일반 분석 서비스 에러
AnalyticsNotFoundException: 리소스를 찾을 수 없음 재시도: @Retryable을 통한 자동 재시도
배치 중단: 할당량 초과 시 배치 작업 중단
로깅: 상세한 에러 로그 및 모니터링
캐시 무효화: 에러 발생 시 관련 캐시 삭제
]]></description><link>kt에이블/빅프/ai문서/service.html</link><guid isPermaLink="false">kt에이블/빅프/ai문서/service.md</guid><pubDate>Thu, 21 Aug 2025 17:33:02 GMT</pubDate></item><item><title><![CDATA[성과-README-초안]]></title><description><![CDATA[YouTube 및 기타 SNS 플랫폼의 메트릭을 수집하고 분석하는 마이크로서비스입니다.
공통 Repository 패턴: BaseJpaRepository 추상 클래스로 중복 코드 제거 모든 JpaRepository가 공통 기능을 상속받도록 리팩토링
findAllWithPagination, findByCreatedAtBetween 등 공통 메서드 제공 Validator 분리: AnalyticsRequestValidator로 입력 검증 로직 통합 ID 형식 검증, 페이지네이션 검증 등 공통 로직 분리
컨트롤러에서 중복되던 검증 코드 제거 예외 처리 개선: 구체적인 예외 클래스들 추가 AnalyticsNotFoundException: 데이터를 찾을 수 없을 때
AnalyticsValidationException: 입력 검증 실패 시
AnalyticsQuotaExceededException: YouTube API 할당량 초과 시 LocalDate → Date 변경: 타임존 일관성을 위한 날짜 타입 통일 Jackson의 time-zone 설정과 일치하도록 Date 타입 사용
서울 타임존 기준으로 일관된 날짜 처리 날짜 필터링 단순화: 복잡한 범위 검색에서 직접 날짜 비교로 변경 DATE(createdAt) = DATE(:date) 쿼리로 정확한 날짜 매칭
불필요한 startDate/endDate 계산 로직 제거
성능 향상 및 코드 간소화 Repository 메서드 최적화: 날짜 전용 조회 메서드 추가 findByPostIdAndCreatedAtDate(Long postId, Date date)
findByAccountIdAndCreatedAtDate(Long accountId, Date date)
findByPostIdAndCreatedAtDateWithPagination(Long postId, Date date, Integer page, Integer size) 캐싱 전략: Redis 캐싱을 활용한 성능 최적화 @Cacheable 어노테이션으로 메트릭 조회 결과 캐싱
캐시 TTL 설정으로 데이터 신선도 관리 비동기 처리: CompletableFuture를 활용한 비동기 메트릭 조회 @Async 어노테이션으로 대용량 데이터 처리 성능 향상 배치 처리: 병렬 처리를 통한 대용량 데이터 처리 성능 향상 병렬 스레드 수 설정으로 리소스 최적화 Actuator: 헬스체크 및 메트릭 모니터링 엔드포인트 추가 /actuator/health: 서비스 상태 확인
/actuator/metrics: 성능 메트릭 조회
/api/analytics/health: 커스텀 헬스체크 엔드포인트 Swagger: API 문서화 개선 @Operation, @Parameter 어노테이션으로 상세한 API 문서화
각 엔드포인트별 설명 및 파라미터 정보 추가 로깅: 구조화된 로깅 및 캐시 디버깅 로그 추가 캐시 히트/미스 로그 추가
성능 모니터링을 위한 구조화된 로그 패턴 적용 YouTube API에서 실시간 데이터를 직접 조회하는 API들입니다.GET /api/analytics/realtime/posts/{postId}/metrics postId: 로컬 DB의 게시물 ID (Long)
응답: RealtimePostMetricsResponse - YouTube API 실시간 데이터
GET /api/analytics/realtime/accounts/{accountId}/metrics accountId: 로컬 DB의 계정 ID (Long)
응답: RealtimeAccountMetricsResponse - YouTube API 실시간 데이터
GET /api/analytics/realtime/posts/{postId}/comments?page=0&amp;size=20 postId: 로컬 DB의 게시물 ID (Long)
응답: PostCommentsQueryResponse - YouTube API 실시간 댓글
GET /api/analytics/realtime/posts/{postId}/emotion-analysis postId: 로컬 DB의 게시물 ID (Long)
응답: EmotionAnalysisResponse - 댓글 감정분석 결과 및 키워드
로컬 DB에 저장된 과거 데이터를 조회하는 API들입니다.GET /api/analytics/history/posts/{postId}/metrics?date=2024-01-15 postId: 로컬 DB의 게시물 ID (Long)
date: 조회할 날짜 (Date, 필수) - 서울 타임존 기준
응답: PostMetricsQueryResponse - DB 저장된 메트릭
GET /api/analytics/history/accounts/{accountId}/metrics?date=2024-01-15 accountId: 로컬 DB의 계정 ID (Long)
date: 조회할 날짜 (Date, 필수) - 서울 타임존 기준
응답: AccountMetricsQueryResponse - DB 저장된 메트릭
GET /api/analytics/history/posts/{postId}/comments?date=2024-01-15&amp;page=0&amp;size=20 postId: 로컬 DB의 게시물 ID (Long)
date: 조회할 날짜 (Date, 필수) - 서울 타임존 기준
응답: PostCommentsQueryResponse - DB 저장된 댓글
메트릭 수집을 위한 배치 작업을 실행하고 모니터링하는 API들입니다.POST /api/analytics/batch/accounts/{accountId}/metrics
POST /api/analytics/batch/posts/{postId}/metrics
POST /api/analytics/batch/posts/{postId}/comments accountId/postId: 로컬 DB의 ID (Long)
응답: BatchOperationResponse - 배치 작업 실행 결과
GET /api/analytics/batch/status
GET /api/analytics/batch/status/{jobName} 응답: BatchJobStatusResponse - 배치 작업 상태 정보
서비스 상태 및 성능을 모니터링하는 API들입니다.GET /api/analytics/health 응답: HealthStatus - 서비스 상태 정보
GET /api/analytics/realtime/quota/status 응답: QuotaStatus - YouTube API 할당량 사용 현황
GET /actuator/health # 서비스 헬스체크
GET /actuator/metrics # 성능 메트릭
GET /actuator/prometheus # Prometheus 메트릭
// AiAnalysisRequest - AI 서버로 전송하는 댓글 데이터
{ "data": [ { "id": "1", "result": "댓글 내용" } ], "keyword": { "positive": ["긍정키워드1", "긍정키워드2"], "negative": ["부정키워드1", "부정키워드2"] }
} // AiAnalysisResponse - AI 서버로부터 받는 분석 결과
{ "emotion_analysis": { "individual_results": [ { "id": "1", "result": "POSITIVE" // POSITIVE, NEGATIVE, NEUTRAL } ] }, "keywords": { "positive": ["긍정키워드1", "긍정키워드2"], "negative": ["부정키워드1", "부정키워드2"] }
} // SentimentType Enum
public enum SentimentType { POSITIVE("POSITIVE"), // 긍정 NEGATIVE("NEGATIVE"), // 부정 NEUTRAL("NEUTRAL"); // 중립
}
// HealthStatus
{ "service": "analytics-service", "status": "UP", "timestamp": 1705123456789
} // QuotaStatus
{ "currentUsage": 1500, "limit": 10000, "timeUntilReset": 7200000, // 2시간 (밀리초) "lastResetTime": 1705116000000
}
// RealtimePostMetricsResponse
{ "postId": 1, // 로컬 DB ID "snsPostId": "w7YKHjH_MpM", // YouTube Video ID "accountId": 1, // 로컬 계정 ID "likes": "1234", // 실시간 좋아요 수 "dislikes": 5, // 실시간 싫어요 수 "comments": 89, // 실시간 댓글 수 "shares": null, // 공유 수 (YouTube API v3 미지원) "views": 56789, // 실시간 조회 수 "fetchedAt": "2024-01-15T12:00:00", // API 호출 시간 "dataSource": "youtube_api", // 데이터 소스 "isCached": false // 캐시 여부
} // RealtimeAccountMetricsResponse
{ "accountId": 1, // 로컬 DB ID "snsAccountId": "UC123456789", // YouTube Channel ID "followers": 12345, // 실시간 구독자 수 "views": 1234567, // 실시간 총 조회 수 "fetchedAt": "2024-01-15T12:00:00", // API 호출 시간 "dataSource": "youtube_api", // 데이터 소스 "isCached": false // 캐시 여부
}
// PostMetricsQueryResponse
{ "postId": 1, // 로컬 DB ID "likes": "1234", // DB 저장된 좋아요 수 "dislikes": 5, // DB 저장된 싫어요 수 "comments": 89, // DB 저장된 댓글 수 "shares": null, // DB 저장된 공유 수 "views": 56789, // DB 저장된 조회 수 "crawledAt": "2024-01-15T12:00:00" // 수집 시간 (createdAt 기반)
} // AccountMetricsQueryResponse
{ "accountId": 1, // 로컬 DB ID "followers": 12345, // DB 저장된 구독자 수 "views": 1234567, // DB 저장된 총 조회 수 "crawledAt": "2024-01-15T12:00:00" // 수집 시간 (createdAt 기반)
} // PostCommentsQueryResponse
{ "commentId": "UgzDE8pqJ_c", // YouTube 댓글 ID "authorId": 123456789, // 댓글 작성자 ID "text": "댓글 내용", // 댓글 텍스트 "likeCount": 5, // 댓글 좋아요 수 "publishedAt": "2024-01-15T12:00:00", // 댓글 작성 시간 "crawledAt": "2024-01-15T12:00:00" // 수집 시간 (createdAt 기반)
}
// BatchOperationResponse
{ "operationName": "collectPostMetrics", "status": "SUCCESS", "executedAt": "2024-01-15T12:00:00", "message": "Post metrics collection completed successfully", "processedCount": 1, "failedCount": 0
} // BatchJobStatusResponse
{ "jobName": "collectPostMetrics_1", "status": "RUNNING", "startTime": "2024-01-15T12:00:00", "endTime": null, "progress": 50, "totalItems": 100, "errorMessage": null
} Hexagonal Architecture 완전 준수: DTO를 application 계층으로 이동
계층 간 의존성 역전 해결: UseCase가 adapter에 의존하지 않음
명확한 책임 분리: 각 계층의 역할 명확화 Bean Validation 추가: @Pattern, @Min, @Max 어노테이션
입력 검증 강화: 컨트롤러 레벨에서 엄격한 검증
Lombok 경고 해결: @Builder.Default 어노테이션 적용 기존: Guava Cache (인메모리, 단일 서버)
개선: Redis Cache (분산 캐시, 클러스터 공유)
세분화된 TTL: 메트릭 5분, 댓글 2분, 할당량 1분
스마트 캐시 무효화: 이벤트 발생 시 관련 캐시만 삭제 AnalyticsErrorCode enum: 구체적인 에러 코드 체계
AnalyticsException 개선: 에러 코드와 메시지 분리
일관된 에러 응답: 모든 API에서 동일한 에러 형식 SnsPostMetric: snsPostId, accountId 필드 제거 (FK로 충분히 조회 가능)
SnsAccountMetric: snsAccountId 필드 제거 (FK로 충분히 조회 가능)
SnsPostCommentMetric: authorName → authorId로 변경 (정확한 사용자 식별)
시간 필드 통합: crawledAt 제거, createdAt 기반으로 통일
데이터 중복 제거: FK 관계로 충분히 조회 가능한 필드들 제거
성능 최적화: 불필요한 필드 제거로 저장 공간 절약 SentimentType Enum: 감정 분석 결과를 위한 타입 안전한 enum 추가 POSITIVE, NEGATIVE, NEUTRAL 값으로 감정 분류
Jackson @JsonCreator와 @JsonValue로 AI 서버 응답과 자동 매핑
대소문자 무관한 파싱 및 기본값 처리 AiAnalysisRequest/AiAnalysisResponse DTO: AI 서버와의 통신을 위한 전용 DTO 댓글 데이터를 AI 서버로 전송하여 감정 분석 수행
emotion_analysis.individual_results 구조로 AI 서버 응답 매핑
키워드 추출 기능 포함 (긍정/부정 분리) EmotionAnalysisService: 감정 분석 로직을 담당하는 서비스 AI 서버 호출 및 응답 처리
감정 분석 결과를 DB에 저장
에러 처리 및 재시도 로직 API 호출 최적화: 캐싱으로 중복 호출 방지
할당량 관리: YouTube API 할당량 효율적 사용
비동기 처리: 배치 작업의 비동기 실행
쿼리 최적화: createdAt 기반 인덱스 활용
날짜 필터링 최적화: DATE() 함수를 활용한 정확한 날짜 매칭
키워드 조회 최적화: DB 조회 2번 → 1번으로 최적화 역할: 히스토리 데이터 및 실시간 데이터 조회
주요 기능: 히스토리 메트릭/댓글 조회 (DB 기반)
실시간 메트릭/댓글 조회 (YouTube API 기반)
감정분석 결과 조회
캐싱 적용 (@Cacheable) 특징: 오늘 날짜 실시간 데이터 조회 로직 제거 (히스토리/실시간 완전 분리)
키워드 조회 최적화 (한 번에 조회 후 메모리에서 분리) 역할: YouTube API와의 모든 통신 담당
주요 기능: 실시간 비디오 메트릭 조회
실시간 채널 메트릭 조회
실시간 댓글 조회
API 에러 처리 및 할당량 관리 특징: 캐싱 적용으로 API 호출 최소화
할당량 초과 시 적절한 예외 처리
재시도 로직 포함 역할: 배치 작업을 통한 메트릭 수집
주요 기능: 계정 메트릭 수집
게시물 메트릭 수집
댓글 수집 및 감정분석 연동
병렬 처리 및 배치 최적화 특징: 새로운 댓글 발견 시 자동 감정분석 수행
YouTube API 할당량 관리
배치 작업 모니터링 역할: 댓글 감정분석 및 키워드 추출
주요 기능: AI 서버와의 통신
감정분석 결과 DB 저장
키워드 긍정/부정 분리 저장 특징: AI 서버 응답 처리
에러 처리 및 로깅 역할: AI 분석 서버와의 HTTP 통신
주요 기능: 댓글 데이터를 AI 서버로 전송
기존 키워드를 긍정/부정으로 분리하여 전송
AI 서버 응답 처리 특징: 키워드 조회 최적화 (한 번에 조회 후 메모리에서 분리)
HTTP 헤더 및 에러 처리 역할: Redis 기반 분산 캐싱 관리
주요 기능: 실시간 메트릭 캐싱 (5분 TTL)
댓글 캐싱 (2분 TTL)
할당량 정보 캐싱 (1분 TTL)
캐시 무효화 특징: 세분화된 TTL 설정
JSON 직렬화/역직렬화
에러 처리 역할: 외부 이벤트 처리 (게시물/계정 생성/삭제)
주요 기능: 게시물 생성/삭제 이벤트 처리
SNS 계정 연결/해제 이벤트 처리
관련 캐시 무효화 특징: 이벤트 기반 캐시 무효화
트랜잭션 처리 역할: 정기적인 메트릭 수집 스케줄링
주요 기능: 매일 12시 자동 메트릭 수집
개발 환경 1분마다 수집 (테스트용)
스케줄 관리 특징: @Scheduled 어노테이션 활용
프로파일별 다른 스케줄 역할: 배치 작업 상태 모니터링
주요 기능: 배치 작업 진행률 추적
작업 상태 관리
에러 처리 특징: 실시간 모니터링
작업 히스토리 관리 역할: 수집된 메트릭 데이터 검증
주요 기능: 메트릭 데이터 유효성 검사
이상치 감지
데이터 정규화 특징: 데이터 품질 보장
비즈니스 룰 적용 AnalyticsQueryService
├── YouTubeApiService
├── AnalyticsCacheService
└── PostCommentKeywordRepository YouTubeApiService
├── AnalyticsCacheService
└── SnsPostRepository MetricsCollectionService
├── YouTubeApiService
├── EmotionAnalysisService
├── BatchJobMonitor
└── MetricsValidator EmotionAnalysisService
├── AiAnalysisService
└── PostCommentKeywordRepository AiAnalysisService
└── PostCommentKeywordRepository AnalyticsEventService
└── AnalyticsCacheService MetricsCollectionScheduler
└── MetricsCollectionService
cd analytics-service
./gradlew bootRun
docker-compose up -d analytics-service
./gradlew :analytics-service:build
./quick-test.sh
./batch-test-api.sh
./clear-db-only.sh
# 실시간 로그
docker logs -f analytics-service # 스케줄러 로그
docker logs analytics-service | grep "DAILY METRICS" # 캐시 디버깅 로그
docker logs analytics-service | grep "CACHE"
curl -X GET "http://localhost:8080/api/analytics/batch/status" \ -H "X-USER-ID: 4" \ -H "Authorization: Bearer YOUR_TOKEN"
# Redis 캐시 확인
redis-cli keys "analytics:*" # 할당량 상태 확인
curl -X GET "http://localhost:8080/api/analytics/realtime/quota/status" # 헬스체크
curl -X GET "http://localhost:8080/api/analytics/health"
# 서비스 헬스체크
curl -X GET "http://localhost:8080/actuator/health" # 성능 메트릭
curl -X GET "http://localhost:8080/actuator/metrics" # Prometheus 메트릭
curl -X GET "http://localhost:8080/actuator/prometheus"
@Scheduled(cron = "0 0 09 * * ?", zone = "Asia/Seoul")
public void runDailyMetricsCollectionJob() 실행 시간: 매일 오전 9시 (한국 시간)
실행 순서: 계정 메트릭 → 게시물 메트릭 → 댓글 수집
Spring Batch Job: dailyMetricsCollectionJob
// @Scheduled(cron = "0 */2 * * * ?", zone = "Asia/Seoul")
// @Profile("dev")
public void runTestMetricsCollectionJob() 실행 주기: 2분마다 (테스트용)
프로파일: dev 환경에서만 활성화
용도: 개발 및 테스트를 위한 빠른 수집
매일 9시 → BatchScheduler.runDailyMetricsCollectionJob() ↓
JobParameters 생성 (실행시간, 타임스탬프) ↓
Spring Batch Job 실행
dailyMetricsCollectionJob ↓
Step 1: collectAccountMetricsStep (계정 메트릭 수집) ↓
Step 2: collectPostMetricsStep (게시물 메트릭 수집) ↓
Step 3: collectPostCommentsStep (댓글 수집)
processBatch() 메서드 ↓
1. 전체 아이템 수 조회
2. 페이지네이션으로 배치 처리 (기본 100개씩)
3. 각 아이템별 개별 처리
4. 진행률 모니터링
5. 에러 처리 및 재시도
catch (AnalyticsQuotaExceededException e) { log.warn("YouTube API quota exceeded during {} collection. Stopping batch.", itemType); break; // 배치 작업 중단
} 동작: 즉시 배치 작업 중단
복구: 다음 날 9시에 다시 실행
데이터 손실: 없음 (부분적으로 수집된 데이터는 저장됨)
catch (JobExecutionAlreadyRunningException e) { log.error("❌ Batch job is already running: {}", e.getMessage());
} 동작: 이미 실행 중인 배치가 있으면 새 배치 실행 안함
복구: 기존 배치 완료 후 다음 스케줄까지 대기
catch (Exception e) { batchJobMonitor.recordJobFailure(jobName, e.getMessage()); log.error("Failed to collect {}", itemType, e); throw new AnalyticsException("Failed to collect " + itemType, e);
} 동작: 실패한 배치 작업 상태 기록
복구: 수동으로 재실행 가능 (API 엔드포인트 제공)
데이터 손실: 실패한 아이템만 손실, 성공한 아이템은 저장됨
# 모든 배치 작업 상태
GET /api/analytics/batch/status # 특정 배치 작업 상태
GET /api/analytics/batch/status/{jobName}
{ "jobName": "account-metrics-collection", "status": "RUNNING", // RUNNING, COMPLETED, FAILED "startTime": "2024-01-15T09:00:00", "endTime": null, "progress": 50, // 처리된 아이템 수 "totalItems": 100, // 전체 아이템 수 "errorMessage": null // 에러 메시지 (실패 시)
}
# 배치 작업 시작/완료 로그
docker logs analytics-service | grep "Daily metrics collection" # 실시간 진행률 로그
docker logs analytics-service | grep "Batch job progress" # 에러 로그
docker logs analytics-service | grep "❌"
POST /api/analytics/batch/metrics
# 계정 메트릭
POST /api/analytics/batch/accounts/metrics
POST /api/analytics/batch/accounts/{accountId}/metrics # 게시물 메트릭
POST /api/analytics/batch/posts/metrics
POST /api/analytics/batch/posts/{postId}/metrics # 댓글 수집
POST /api/analytics/batch/posts/comments
POST /api/analytics/batch/posts/{postId}/comments 재시도: @Retryable 어노테이션으로 최대 3회 재시도
백오프: 1초 간격으로 지수 백오프
복구: 재시도 성공 시 정상 처리, 실패 시 다음 배치에서 재시도 트랜잭션: 각 배치 아이템별 트랜잭션 처리
롤백: 실패 시 해당 아이템만 롤백
복구: 성공한 아이템은 유지, 실패한 아이템만 재처리 할당량 초과: 즉시 배치 중단, 다음 날 재시도
API 오류: 개별 아이템 실패 처리, 배치 계속 진행
복구: 실패한 아이템은 수동 재실행 가능 배치 크기: 기본 100개씩 처리
병렬 스레드: 4개 스레드로 병렬 처리
메모리 효율성: 페이지네이션으로 메모리 사용량 제한 중복 방지: 최근 1시간 내 데이터가 있으면 스킵
API 호출 최소화: 캐싱으로 중복 API 호출 방지
성능 향상: 캐시 히트 시 즉시 응답 실시간 모니터링: YouTube API 할당량 사용량 추적
스마트 중단: 할당량 초과 시 즉시 배치 중단
효율적 사용: 배치 처리로 API 호출 최적화 스케줄: 매일 9시 자동 실행
독립성: 이전 배치 실패와 무관하게 새 배치 시작
데이터 무결성: 중복 데이터 방지 로직으로 데이터 일관성 보장 히스토리 보존: 이전 수집 데이터는 그대로 유지
증분 수집: 새로운 데이터만 추가 수집
데이터 갱신: 기존 데이터는 최신 정보로 업데이트 수동 재실행: API를 통한 개별 아이템 재처리
선택적 복구: 실패한 아이템만 선택적으로 재처리
데이터 보완: 누락된 데이터 보완 가능
analytics-service/
├── adapter/
│ ├── in/
│ │ ├── web/ # REST API 컨트롤러
│ │ │ └── validator/ # 입력 검증 로직
│ │ └── event/ # 이벤트 컨트롤러
│ └── out/
│ └── persistence/ # 데이터 접근 계층
│ └── repository/ # JPA Repository
├── application/
│ ├── port/
│ │ ├── in/ # UseCase 인터페이스
│ │ └── out/ # Repository 인터페이스
│ └── service/ # 비즈니스 로직
├── domain/
│ ├── entity/ # 도메인 엔티티
│ └── model/ # 도메인 모델
├── exception/ # 예외 처리 클래스
└── config/ # 설정 클래스 공통 Repository: BaseJpaRepository로 중복 코드 제거
Validator 분리: 입력 검증 로직을 별도 패키지로 분리
예외 처리: 구체적인 예외 클래스들로 세분화된 에러 처리
캐싱 계층: Redis 캐싱을 통한 성능 최적화
모니터링: Actuator를 통한 헬스체크 및 메트릭 수집 Redis Cache (분산 캐시) 메트릭 데이터: 5분 TTL (@Cacheable(value = "post-metrics"))
댓글 데이터: 2분 TTL (@Cacheable(value = "comments"))
할당량 정보: 1분 TTL (Guava Cache) 이벤트 기반 무효화 게시물 생성/삭제 시 관련 캐시 삭제
계정 연결/해제 시 관련 캐시 삭제
@CacheEvict 어노테이션으로 자동 무효화 캐시 키 패턴 post-metrics::{userId}-{postId}-{date}
account-metrics::{userId}-{accountId}-{date}
comments::{postId}-{page}-{size} 성능 최적화 캐시 히트율 모니터링
캐시 미스 시 자동 재로딩
배치 작업 시 캐시 일괄 갱신 INVALID_POST_ID: 잘못된 게시물 ID 형식
INVALID_ACCOUNT_ID: 잘못된 계정 ID 형식
INVALID_DATE: 잘못된 날짜 파라미터
INVALID_PAGINATION: 잘못된 페이지네이션 파라미터 POST_NOT_FOUND: 게시물을 찾을 수 없음
ACCOUNT_NOT_FOUND: 계정을 찾을 수 없음
NO_DATA_AVAILABLE: 조회 조건에 맞는 데이터 없음 YOUTUBE_API_ERROR: YouTube API 오류 발생
YOUTUBE_QUOTA_EXCEEDED: YouTube API 할당량 초과
YOUTUBE_VIDEO_NOT_FOUND: YouTube 비디오를 찾을 수 없음
YOUTUBE_CHANNEL_NOT_FOUND: YouTube 채널을 찾을 수 없음 UNAUTHORIZED_ACCESS: 데이터에 대한 권한 없음
USER_MISMATCH: 사용자 ID 불일치 INTERNAL_ERROR: 내부 서버 오류
DATABASE_ERROR: 데이터베이스 작업 실패
CACHE_ERROR: 캐시 작업 실패
app: youtube: api: quota-limit: 10000 # YouTube API 일일 할당량 quota-window: 86400 # 할당량 윈도우 (초) batch-size: 100 # 배치 처리 크기 retry-attempts: 3 # 재시도 횟수 retry-delay: 1000 # 재시도 지연 (밀리초) parallel-threads: 4 # 병렬 처리 스레드 수 cache: ttl: post-metrics: 300 # 게시물 메트릭 캐시 TTL (초) account-metrics: 300 # 계정 메트릭 캐시 TTL (초) comments: 120 # 댓글 캐시 TTL (초) ai: analysis: url: http://localhost:8081/analyze # AI 분석 서버 URL
management: endpoints: web: exposure: include: health,info,metrics,prometheus base-path: /actuator endpoint: health: show-details: when-authorized show-components: always metrics: export: prometheus: enabled: true 중복 필드 제거: FK로 충분히 조회 가능한 필드들 제거
시간 필드 통합: crawledAt → createdAt 기반으로 통일
사용자 식별 개선: authorName → authorId로 변경
저장 공간 절약: 불필요한 필드 제거로 DB 용량 최적화 LocalDate → Date 변경: 타임존 일관성을 위한 날짜 타입 통일
날짜 필터링 단순화: 복잡한 범위 검색에서 직접 날짜 비교로 변경
Repository 메서드 최적화: 날짜 전용 조회 메서드 추가
성능 향상: 불필요한 날짜 변환 로직 제거 SentimentType Enum: 감정 분석 결과를 위한 타입 안전한 enum
AiAnalysisRequest/AiAnalysisResponse DTO: AI 서버와의 통신을 위한 전용 DTO
EmotionAnalysisService: 감정 분석 로직을 담당하는 서비스
키워드 긍정/부정 분리: AI 서버 요청/응답에서 키워드를 긍정/부정으로 분리 인덱스 활용: createdAt 기반 인덱스로 조회 성능 향상
FK 관계 활용: 중복 데이터 제거로 조인 성능 개선
메모리 효율성: 엔티티 크기 감소로 메모리 사용량 최적화
날짜 필터링 최적화: DATE(createdAt) = DATE(:date) 쿼리로 정확한 날짜 매칭
키워드 조회 최적화: DB 조회 2번 → 1번으로 최적화 정규화 강화: 중복 데이터 제거로 데이터 일관성 확보
관계 명확화: FK 관계를 통한 명확한 데이터 관계
무결성 보장: 중복 필드 제거로 데이터 무결성 향상 완전한 분리: 히스토리 조회와 실시간 조회를 완전히 분리
명확한 역할: 각 API의 역할과 책임 명확화
성능 최적화: 불필요한 실시간 데이터 조회 로직 제거
]]></description><link>kt에이블/빅프/ai문서/성과-readme-초안.html</link><guid isPermaLink="false">kt에이블/빅프/ai문서/성과-README-초안.md</guid><pubDate>Thu, 21 Aug 2025 13:31:29 GMT</pubDate></item><item><title><![CDATA[쿠키적용실패]]></title><description><![CDATA[localhost8080/어쩌구저쩌구페이지에 이도하면 응답으로 리다이랙트를시켜서 최종적으로 내 client페이지에 리다이랙트시켜주는데 이때 cookies를 같이 던져준다카카오가 서버로 리다이랙트시키고 그서버가## REQUEST GENERAL
Request URL
http://localhost:8080/api/auth/oauth2/code/kakao?code=rUA14oVfYQ7eaBaoEUcJqdiCJ7l_o2XDRX5UAJXzwp-w31V2Zb8_oQAAAAQKDQxeAAABmMshqQwWphHJzwXJqw&amp;state=-9-jOIfBPBtwluTdmFviAFZrPlqU3gAwk9VtxTr5Exo%3D
Request Method
GET
Status Code
302 Found
Remote Address
[::1]:8080
Referrer Policy
strict-origin-when-cross-origin
## Response header
HTTP/1.1 302 Found Vary: Origin Vary: Access-Control-Request-Method Vary: Access-Control-Request-Headers Set-Cookie: JSESSIONID=82930ADACECC28C5FC611C05675A3C50; Path=/; HttpOnly Set-Cookie: accessToken=eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiI0IiwiZW1haWwiOiJtYW5kdWl1QGtha2FvLmNvbSIsImp0aSI6IjMwOGFjMmU3LWZkOTYtNGEzNy1hZjVjLTdmZDhkNWVmODZiNCIsImlhdCI6MTc1NTc1NDYzOCwiZXhwIjoxNzU1NzU1MjM4fQ.hRIBqqzWF5P6pE6a4eIj_3axNVZ2SW0rxv0WMqn6R5w; Path=/ Set-Cookie: refreshToken=27361f54-81df-4601-8e79-c0c8ca373a7b; Path=/ X-Content-Type-Options: nosniff X-XSS-Protection: 0 Cache-Control: no-cache, no-store, max-age=0, must-revalidate Pragma: no-cache Expires: 0 X-Frame-Options: DENY Location: http://localhost:5173/oauth-success Content-Length: 0 Date: Thu, 21 Aug 2025 05:37:18 GMT
GET /api/auth/oauth2/code/kakao?code=rUA14oVfYQ7eaBaoEUcJqdiCJ7l_o2XDRX5UAJXzwp-w31V2Zb8_oQAAAAQKDQxeAAABmMshqQwWphHJzwXJqw&amp;state=-9-jOIfBPBtwluTdmFviAFZrPlqU3gAwk9VtxTr5Exo%3D HTTP/1.1 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate, br, zstd Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7 Cache-Control: no-cache Connection: keep-alive Cookie: JSESSIONID=E80A78E7CA3A6961B545CCC918B984EA Host: localhost:8080 Pragma: no-cache Referer: http://localhost:5173/ Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: cross-site Sec-Fetch-User: ?1 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Whale/4.33.325.15 Safari/537.36 sec-ch-ua: "Chromium";v="138", "Whale";v="4", "Not.A/Brand";v="99" sec-ch-ua-mobile: ?0 sec-ch-ua-platform: "macOS"
302 리다이렉트 응답과 함께 Set-Cookie가 전송되었음에도 클라이언트에서 쿠키가 저장되지 않는 경우, 대표적인 원인은 다음과 같습니다: Secure 속성과 HTTPS 미사용 배포 환경이 HTTPS가 아니라면, Set-Cookie에 Secure 속성이 있으면 쿠키가 저장되지 않습니다. 302 응답에서 Secure 쿠키는 HTTPS 연결에서만 브라우저가 받아들입니다. SameSite 속성 설정 문제 기본 브라우저 정책으로 인해, 리다이렉트가 발생하는 cross-site 요청에서 쿠키가 차단될 수 있습니다. SameSite 속성이 Lax 또는 Strict라면, 타 사이트에서의 리다이렉트 시 쿠키를 수락하지 않을 가능성이 큽니다. SameSite=None; Secure 설정이 되어야 외부 OAuth 리다이렉트 후 쿠키가 저장됩니다. 도메인 불일치 서버가 Set-Cookie에 지정한 도메인이 클라이언트 URL의 도메인과 맞지 않으면 저장 안 됩니다. 클라이언트 측 요청 정책 클라이언트가 쿠키를 포함하는 요청을 하려면 xhr/fetch 시 credentials: 'include' 옵션을 사용해야 하며, 그렇지 않으면 쿠키가 전송되지 않을 수 있습니다. 하지만 302 리다이렉트 응답은 브라우저가 자동으로 처리하므로 보통 클라이언트 설정 문제는 아니지만, CORS 설정과 연동되면 영향을 줍니다. 브라우저 보안 정책 및 확장프로그램 특정 브라우저 보안 설정이나 확장프로그램(예: 광고 차단기) 때문에 쿠키 저장이 차단될 수 있습니다. 정리하면, 302 응답의 Set-Cookie가 무시되는 가장 흔한 이유는 SameSite와 Secure 설정 문제, 그리고 HTTPS 미사용입니다. 특히 OAuth 인증 과정 뒤라면 아래 조치들을 꼭 확인하세요:
302 응답에서 Set-Cookie 헤더에 SameSite=None; Secure 포함 배포 서버가 HTTPS를 사용 중인지 확인 Domain 속성이 클라이언트 도메인과 일치하는지 확인 CORS 및 클라이언트 요청에서 자격 증명(쿠키) 허용 설정 확인 이 부분들부터 점검하는 것을 권장합니다.]]></description><link>kt에이블/빅프/쿠키적용실패.html</link><guid isPermaLink="false">kt에이블/빅프/쿠키적용실패.md</guid><pubDate>Thu, 21 Aug 2025 05:55:06 GMT</pubDate></item><item><title><![CDATA[어노테이션차이]]></title><description><![CDATA[@Component @Service
따라서&nbsp;@Service가 적절합니다.만약&nbsp;@Component로&nbsp;바꿔도&nbsp;기능적으로는 동일하지만,&nbsp;의미적으로는&nbsp;@Service가 더&nbsp;명확합니다.]]></description><link>kt에이블/어노테이션차이.html</link><guid isPermaLink="false">kt에이블/어노테이션차이.md</guid><pubDate>Thu, 21 Aug 2025 04:58:46 GMT</pubDate></item><item><title><![CDATA[에러]]></title><description><![CDATA[Entry for instance of 'kt.aivle.analytics.domain.entity.SnsPostCommentMetric' has a null identifier (this can happen if the session is flushed after an exception occurs)]]></description><link>kt에이블/에러.html</link><guid isPermaLink="false">kt에이블/에러.md</guid><pubDate>Thu, 21 Aug 2025 04:40:03 GMT</pubDate></item><item><title><![CDATA[impliment가먼데]]></title><description><![CDATA[{
"emotion_analysis": {
"individual_results": [
{
"id": 1,
"result": "POSITIVE"
},
],
keywords:{
"positive": List
"negative":List negative;
}
}]]></description><link>kt에이블/빅프/impliment가먼데.html</link><guid isPermaLink="false">kt에이블/빅프/impliment가먼데.md</guid><pubDate>Wed, 20 Aug 2025 12:48:30 GMT</pubDate></item><item><title><![CDATA[Spring Cache,Redis,Guava Cache]]></title><link>kt에이블/빅프/spring-cache,redis,guava-cache.html</link><guid isPermaLink="false">kt에이블/빅프/Spring Cache,Redis,Guava Cache.md</guid><pubDate>Wed, 20 Aug 2025 06:06:36 GMT</pubDate></item><item><title><![CDATA[성과분석db와고민]]></title><description><![CDATA[curl '<a data-tooltip-position="top" aria-label="https://youtube.googleapis.com/youtube/v3/commentThreads?part=snippet&amp;maxResults=20&amp;pageToken=nextPageToken%EA%B0%92&amp;order=time&amp;videoId=ofnp63sk8wM&amp;key=%5BYOUR_API_KEY%5D'" rel="noopener nofollow" class="external-link is-unresolved" href="https://youtube.googleapis.com/youtube/v3/commentThreads?part=snippet&amp;maxResults=20&amp;pageToken=nextPageToken%EA%B0%92&amp;order=time&amp;videoId=ofnp63sk8wM&amp;key=%5BYOUR_API_KEY%5D'" target="_self">https://youtube.googleapis.com/youtube/v3/commentThreads?part=snippet&amp;maxResults=20&amp;pageToken=nextPageToken값&amp;order=time&amp;videoId=ofnp63sk8wM&amp;key=[YOUR_API_KEY]'</a> --header 'Authorization: Bearer [YOUR_ACCESS_TOKEN]' --header 'Accept: application/json' --compressed
다만, 다음과 같은 방법으로 원하는 날짜 이후 댓글만 선별할 수 있습니다:
API 호출 시&nbsp;order=time&nbsp;파라미터를 넣어 최신 댓글부터 역순으로 가져오기 (최신순 정렬)
댓글을 페이지네이션으로 계속 받아오면서 응답에 포함된 각 댓글의&nbsp;snippet.topLevelComment.snippet.publishedAt(댓글 작성 일시)을 확인
<br>원하는 날짜 이후의 댓글인 경우만 처리하고, 그 이전 날짜 댓글이 나오면 수집을 중단
"<a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/v3/docs/commentThreads#snippet" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/commentThreads#snippet" target="_self">snippet</a>": {<br>
"<a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/v3/docs/commentThreads#snippet.channelId" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/commentThreads#snippet.channelId" target="_self">channelId</a>": string,<br>
"<a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/v3/docs/commentThreads#snippet.videoId" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/commentThreads#snippet.videoId" target="_self">videoId</a>": string,<br>
"<a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/v3/docs/commentThreads#snippet.topLevelComment" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/commentThreads#snippet.topLevelComment" target="_self">topLevelComment</a>": <a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/v3/docs/comments#resource" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/comments#resource" target="_self">comments Resource</a>,<br>
"<a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/v3/docs/commentThreads#snippet.canReply" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/commentThreads#snippet.canReply" target="_self">canReply</a>": boolean,<br>
"<a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/v3/docs/commentThreads#snippet.totalReplyCount" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/commentThreads#snippet.totalReplyCount" target="_self">totalReplyCount</a>": unsigned integer,<br>
"<a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/v3/docs/commentThreads#snippet.isPublic" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/commentThreads#snippet.isPublic" target="_self">isPublic</a>": boolean
},
<br><a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/v3/docs/comments#resource" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/comments#resource" target="_self">comments Resource</a> &gt;&gt;{<br>
"<a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/v3/docs/comments#kind" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/comments#kind" target="_self">kind</a>": "youtube#comment",<br>
"<a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/v3/docs/comments#etag" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/comments#etag" target="_self">etag</a>": etag,<br>
"<a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/v3/docs/comments#id" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/comments#id" target="_self">id</a>": string,<br>
"<a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/v3/docs/comments#snippet" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/comments#snippet" target="_self">snippet</a>": {<br>
"<a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/v3/docs/comments#snippet.authorDisplayName" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/comments#snippet.authorDisplayName" target="_self">authorDisplayName</a>": string,<br>
"<a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/v3/docs/comments#snippet.authorProfileImageUrl" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/comments#snippet.authorProfileImageUrl" target="_self">authorProfileImageUrl</a>": string,<br>
"<a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/v3/docs/comments#snippet.authorChannelUrl" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/comments#snippet.authorChannelUrl" target="_self">authorChannelUrl</a>": string,<br>
"<a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/v3/docs/comments#snippet.authorChannelId" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/comments#snippet.authorChannelId" target="_self">authorChannelId</a>": {<br>
"<a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/v3/docs/comments#snippet.authorChannelId.value" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/comments#snippet.authorChannelId.value" target="_self">value</a>": string
},<br>
"<a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/v3/docs/comments#snippet.channelId" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/comments#snippet.channelId" target="_self">channelId</a>": string,<br>
"<a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/v3/docs/comments#snippet.textDisplay" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/comments#snippet.textDisplay" target="_self">textDisplay</a>": string,<br>
"<a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/v3/docs/comments#snippet.textOriginal" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/comments#snippet.textOriginal" target="_self">textOriginal</a>": string,<br>
"<a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/v3/docs/comments#snippet.parentId" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/comments#snippet.parentId" target="_self">parentId</a>": string,<br>
"<a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/v3/docs/comments#snippet.canRate" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/comments#snippet.canRate" target="_self">canRate</a>": boolean,<br>
"<a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/v3/docs/comments#snippet.viewerRating" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/comments#snippet.viewerRating" target="_self">viewerRating</a>": string,<br>
"<a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/v3/docs/comments#snippet.likeCount" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/comments#snippet.likeCount" target="_self">likeCount</a>": unsigned integer,<br>
"<a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/v3/docs/comments#snippet.moderationStatus" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/comments#snippet.moderationStatus" target="_self">moderationStatus</a>": string,<br>
"<a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/v3/docs/comments#snippet.publishedAt" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/comments#snippet.publishedAt" target="_self">publishedAt</a>": datetime,<br>
"<a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/v3/docs/comments#snippet.updatedAt" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/comments#snippet.updatedAt" target="_self">updatedAt</a>": datetime
}
}
즉,&nbsp;API의 직접 필터 기능 대신 클라이언트(내 코드)에서 날짜 조건을 검사하여 필터링해야 합니다.<br>
GET <a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.googleapis.com/youtube/v3/channels" target="_self">https://www.googleapis.com/youtube/v3/channels</a>
?part=statistics
&amp;id=CHANNEL_ID
&amp;key=YOUR_API_KEY<br>
"<a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/v3/docs/channels#statistics.viewCount" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/channels#statistics.viewCount" target="_self">viewCount</a>": unsigned long,<br>
"<a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/v3/docs/channels#statistics.subscriberCount" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/channels#statistics.subscriberCount" target="_self">subscriberCount</a>": unsigned long, // this value is rounded to three significant figures<br>
GET <a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.googleapis.com/youtube/v3/videos" target="_self">https://www.googleapis.com/youtube/v3/videos</a>
?part=statistics
&amp;id=VIDEO_ID
&amp;key=YOUR_API_KEY
viewCount: 조회 수
likeCount: 좋아요 수
dislikeCount: 싫어요 수 commentCount: 댓글 수
타입마다디비에넣을수잇는데이터를제한
-- 게시물 지표
CREATE TABLE sns_post_metric ( id BIGINT AUTO_INCREMENT PRIMARY KEY, post_id BIGINT NOT NULL, -- 내부 POST의 FK likes BIGINT NULL, dislikes BIGINT NULL, comments BIGINT NULL, shares BIGINT NULL, views BIGINT NULL, crawled_at DATETIME NOT NULL
); -- 댓글 지표
CREATE TABLE sns_post_comment_metric ( id BIGINT AUTO_INCREMENT PRIMARY KEY, sns_comment_id VARCHAR(255) NOT NULL, -- SNS가 준 댓글 ID post_id BIGINT NOT NULL, -- 내부 POST FK content VARCHAR(255) NULL, crawled_at DATETIME NOT NULL
); -- 계정 지표
CREATE TABLE sns_account_metric ( id BIGINT AUTO_INCREMENT PRIMARY KEY, account_id BIGINT NOT NULL, -- 내부 계정 FK followers BIGINT NULL, views BIGINT NULL, crawled_at DATETIME NOT NULL
); -- 게시물 정보
CREATE TABLE sns_post ( id BIGINT AUTO_INCREMENT PRIMARY KEY, -- 내부 PK account_id BIGINT NOT NULL, -- 내부 SNS 계정 FK sns_post_id VARCHAR(255) NOT NULL -- SNS 제공 고유 게시물 ID
); -- 계정 정보
CREATE TABLE sns_account ( id BIGINT AUTO_INCREMENT PRIMARY KEY, -- 내부 PK user_id BIGINT NOT NULL, -- 우리 서비스 사용자 ID sns_account_id VARCHAR(255) NOT NULL, -- SNS 제공 고유 계정 ID type VARCHAR(255) NOT NULL -- ex: "instagram", "twitter"
); [SNS 플랫폼] --- (플랫폼 고유 ID) ---&gt; [sns-service] | | (ID 매핑 &amp; 내부 PK 생성) v
[sns-service 데이터베이스] | (게시, 삭제, 연동 이벤트 발행) v
[분석 서비스 이벤트 수신] | |-- 분리된 PK (sns-service 내부 PK)로 DB 저장 |-- 원본 SNS ID는 별도 필드로 저장 v
[분석 서비스 DB - POST, SNS_ACCOUNT, METRIC 테이블 등] 특정게시물의 댓글 수좋아요수뷰수싫어요수를가져오는api &lt;이건 db저장ㄴㄴ디비에 저장되는 정보바탕으로 가져오는 api
12시기준으로업데이트됨
수집된데이터를 가져오는 api조건 :
날짜 : 당일, 3일전,1주일전,한달전,6개월전,1년전
계정별 : 해당 계정의 게시물 정보 sum해서
게시글별 :성과분석디비에중복되는데이터에대한정보를둘것인가
토큰정보를이벤트로받을것인가
대량의데이터를 이벤트로 어케받을것인가
빠르게업데이트되는dataapi를쓸것인가anaylisticapi를쓸것인가
유튜브에서제공하는 unique한id값을쓸것인가
sns-service의 pk를 그대로 쓸것인가<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://ssdragon.tistory.com/162" target="_self">https://ssdragon.tistory.com/162</a>
분산환경에서&nbsp;DB 기본키(PK)는 어떤 ID 생성 전략으로 만들어야할까? (UUID,ULID,TSID...)MSA에서 흔히 ‘데이터 중복 저장’을&nbsp;Read Model&nbsp;또는&nbsp;Materialized View로 사용합니다.
이건 오히려 좋은 패턴입니다.
분석 목적 or 조회 최적화를 위해 필요한 데이터는 로컬 DB에 저장.
대신 원본 변경(SNS 연동 해제, 게시물 삭제)이 발생하면 이벤트로 반영.
전부 실시간 동기화할 필요 없음.
➡ 이런 구조를&nbsp;Event Sourcing + CQRS(Read Model)&nbsp;패턴과 유사하다고 보면 됩니다.
current상황
sns_post_id&nbsp;→ 유튜브, 인스타그램 등&nbsp;플랫폼 고유 ID&nbsp;(외부 식별자)
sns-service의 id&nbsp;→ 우리 서비스 내부에서 각 SNS 플랫폼의 sns_post_id와 매핑해서 만든 내부 PK (예: auto increment나 UUID)
분석 서비스는 이벤트를 받을 때&nbsp;sns-service의 내부 PK(id)&nbsp;와&nbsp;플랫폼 고유 ID(sns_post_id)&nbsp;둘 다 받을 수 있음
장단점, 근거,&nbsp;Post/Account Metric 등에서 조인
ID 변환 로직이 필요 없음
하지만 현재처럼&nbsp;sns-service가 데이터 소스의 단일 진입점이라면, 내부 PK 없이 그대로 쓰는 것도 유지보수 측면에서 더 간단합니다.
다른 sns를 추가한다면 유튜브안에서는 unique한 id일지몰라도 겹칠수가잇다외부에서 제공된 postid를 그대로 PK(Primary Key)로 사용하는 것은 일반적으로 권장되지 않습니다. 다음과 같은 이유와 주의사항이 있습니다.
PK는 데이터베이스 내에서 레코드를 고유하게 식별하는 중요한 역할을 하며 값이 변경되지 않아야 합니다. 외부에서 온 값이 PK로 사용되면, 그 값의 유효성, 중복성, 변경 가능성 등에 대해 신뢰할 수 있어야 합니다. 그렇지 않으면 데이터 무결성에 문제가 생길 수 있습니다.
Auto Increment 방식의 PK를 외부에 그대로 노출하면, 순차적 증가로 인해 다른 리소스 접근이 예상 가능해져 보안상 취약점이 될 수 있습니다. 반면 UUID같이 복잡한 랜덤 고유값을 사용하면 이런 문제를 줄일 수 있으나, UUID는 인덱스 및 저장 공간의 부담이 있습니다.
실제로 내부적으로는 Auto Increment PK를 사용하되, 외부에 노출하는 PK는 별도의 매핑 테이블을 통해 UUID 같은 다른 식별자로 변환하는 방식을 많이 사용합니다. 이를 통해 내부 데이터베이스 구조를 숨기고 보안을 강화할 수 있습니다.
만약 외부 postid를 PK로 그대로 사용해야 한다면, 그 값이 절대 중복되지 않고 변경되지 않을 것이라는 보장이 있어야 하며, 외부에서 전달되는 값에 대한 신뢰성 및 검증 로직이 반드시 필요합니다.
또한, PK를 외부에서 주입받아 사용하는 구조는 데이터베이스 설계 및 서비스 아키텍처에 따라 복잡성을 증가시키고, PK 변경 시 연쇄적인 영향이 클 수 있으니 신중하게 접근해야 합니다. 결론적으로, 외부 postid를 PK로 그대로 사용하는 것보다는 내부 PK와 외부 식별자를 분리하고, 외부에는 UUID 같은 별도의 식별자를 노출하는 방식을 권장합니다. 내부 PK는 Auto Increment를 사용하고, 외부 노출용 ID를 별도로 관리하는 설계가 보안과 유지보수 측면에서 더 안전하고 효율적입니다YouTube에서 제공하는 videoid를 PK(Primary Key)로 데이터베이스에 그대로 사용하는 경우 발생할 수 있는 주요 이슈는 다음과 같습니다.
고유성 문제 및 충돌 위험
YouTube videoid는 고유하지만, 외부 시스템에서 해당 ID를 PK로 그대로 사용할 때는 고유성 검증과 충돌 방지 로직을 철저히 구현해야 합니다. 고유하지 않거나 중복되면 PK 제약 조건을 위반해 데이터 삽입에 실패합니다.
비정형 문자열 키의 성능 문제
videoid는 일반적으로 문자열(예: 11자리 알파벳과 숫자 조합)인 경우가 많은데, 이러한 비정형 문자열을 PK로 사용하면, 정수형 ID에 비해 인덱스 생성과 탐색 속도가 느려질 수 있고 저장 공간 부담도 커질 수 있습니다.
삽입 시 데이터 단편화
무작위로 생성된 ID를 PK로 사용하면, 데이터가 물리적으로 분포가 불규칙해져서 데이터베이스가 레코드를 순차적으로 저장하지 못하고 단편화(fragmentation)가 발생할 수 있습니다. 이는 조회 성능 저하를 유발할 수 있습니다.
보안 및 예측 가능성
YouTube videoid처럼 예측 불가능한 문자열은 URL 보안에는 도움이 되지만, 내부 DB PK로 그대로 노출했을 때 보안상 주의가 필요합니다. 반면 정수형 순번 PK는 예측 가능하기에 외부에 노출하면 크롤링 등에 취약할 수 있습니다.
변경 불가능성 및 신뢰성
외부 서비스가 제공하는 videoid가 변경되지 않고 안정적으로 유지되는 경우 PK로 사용이 가능하지만, 만약 ID 생성 정책이 변경되거나 재사용 가능성이 있으면 PK로서의 적합성이 떨어집니다.
시스템 설계 복잡성 증가
외부 ID를 PK로 바로 사용하는 경우, 데이터 이관, 마이그레이션, 백엔드 내부 개발자 간 협업 시 복잡성이 증가할 수 있습니다. 또한 외부 시스템 장애, 정책 변경에 대응하기 어려워질 수 있습니다.
실제 YouTube도 초기에는 64비트 순차 PK를 암호화한 후 videoid로 사용했으나, 보안 우려 및 확장성 문제로 현재는 무작위로 생성한 고유 문자열 ID를 사용하고, 내부적으로는 별도의 PK 체계를 유지하는 것으로 알려져 있습니다.따라서 YouTube videoid를 PK로 사용할 때는
반드시 고유성, 변경 불가능성을 보장하고, 비정형 문자열 PK로 인한 성능 저하를 감안하며, 데이터베이스 단편화 문제를 해결할 방안을 마련하고, 보안 및 신뢰성 측면의 검증 로직을 구현하는 것이 필요합니다. <br>그러나 일반적으로는 내부용 PK는 별도의 정수형 또는 UUID 필드를 두고, YouTube videoid는 유니크한 보조 식별자 또는 외부식별자 컬럼으로 관리하는 설계가 더 안전하고 유지보수가 쉽습니다.<a data-tooltip-position="top" aria-label="https://news.ycombinator.com/item?id=25288188" rel="noopener nofollow" class="external-link is-unresolved" href="https://news.ycombinator.com/item?id=25288188" target="_self"></a>요약하면, YouTube videoid를 PK로 직접 사용하면 성능 저하, 데이터 단편화, 보안 및 설계 복잡성 등 여러 문제가 발생할 수 있으며, 이 때문에 별도 내부 PK와 외부 ID 분리 관리를 권장합니다.Domain Layer (Port) ←→ Application Layer ←→ Adapter Layer
↑ ↑ ↑
AccountMetricRepositoryPort UseCase AccountMetricRepository
↓
AccountMetricJpaRepository 실시간&nbsp;데이터와&nbsp;DB 데이터가&nbsp;동일한 DTO 형식으로 응답 PostMetricsQueryResponse,&nbsp;AccountMetricsQueryResponse,&nbsp;PostCommentsQueryResponse&nbsp;통일 일관된&nbsp;필드 타입과&nbsp;구조 Guava Cache&nbsp;사용으로&nbsp;메모리 기반 캐싱 메트릭 캐시:&nbsp;5분 TTL, 1000개 최대 크기 댓글&nbsp;캐시:&nbsp;2분&nbsp;TTL, 500개 최대 크기&nbsp;(더 자주&nbsp;변경됨) API&nbsp;할당량&nbsp;절약: 동일 요청 시 캐시에서&nbsp;즉시 응답 우선순위&nbsp;기반 할당량&nbsp;관리: BATCH_COLLECTION:&nbsp;80% (배치 작업용) REAL_TIME_QUERY: 95% (실시간 조회용) BACKGROUND_SYNC: 98% (백그라운드용) 24시간 자동 리셋: 할당량 윈도우 관리 실시간 모니터링:&nbsp;/api/analytics/quota/status&nbsp;API 추가 ]]></description><link>kt에이블/빅프/성과분석db와고민.html</link><guid isPermaLink="false">kt에이블/빅프/성과분석db와고민.md</guid><pubDate>Mon, 18 Aug 2025 02:03:05 GMT</pubDate></item><item><title><![CDATA[handler]]></title><description><![CDATA[msw와 백엔드와연계]]></description><link>kt에이블/빅프/handler.html</link><guid isPermaLink="false">kt에이블/빅프/handler.md</guid><pubDate>Thu, 14 Aug 2025 07:16:40 GMT</pubDate></item><item><title><![CDATA[배치스케줄링]]></title><description><![CDATA[걍다박아넣쟈
나눠서 이벤트도 스트림형식으로 받을 수있다]]></description><link>kt에이블/빅프/배치스케줄링.html</link><guid isPermaLink="false">kt에이블/빅프/배치스케줄링.md</guid><pubDate>Thu, 14 Aug 2025 01:21:09 GMT</pubDate></item><item><title><![CDATA[성과분석계획]]></title><description><![CDATA[
기본 로그인 &amp; 계정 연동 플랫폼 자체 회원가입/로그인(JWT 등)
YouTube 계정 OAuth2 연동 (다계정 허용)
access_token, refresh_token, expires_at 저장 데이터 수집 YouTube Data API v3, YouTube Analytics API를 이용해 영상·채널 메트릭 조회
스케줄러(@Scheduled)로 매일 자정 자동 실행
토큰 만료 시 refresh token을 사용해 자동 갱신 성과 분석 &amp; AI 연동 수집 데이터 기반으로 AI 서버에 감성 분석, 트렌드 분석, 최적 게시 시간 분석 요청
분석 결과 DB 저장 및 리포트 생성 관리 &amp; 조회 성과 지표, 리포트 이력 조회
다운로드 기능 (CSV/Excel) 필수 API YouTube Data API v3 /videos?part=statistics
/channels?part=statistics
/commentThreads?part=snippet YouTube Analytics API /reports?metrics=views,likes,comments,... Spring Boot 구현 포인트 Google API Java Client Library 또는 RestTemplate/WebClient로 REST 호출
OAuth2 인증 처리
토큰 만료 시 자동 refresh 로직 구현 textuser ├─ id, email, password, ... youtube_account ├─ id, user_id(FK), channel_id, access_token, refresh_token, expires_at video ├─ id, youtube_account_id(FK), video_id, title, description, published_at video_metric ├─ id, video_id(FK), date, view_count, like_count, comment_count analysis_result ├─ id, video_id(FK), type, period, score, summary report ├─ id, youtube_account_id(FK), period, file_path, created_at관계:textuser 1 ─ N youtube_account 1 ─ N video 1 ─ N video_metric │ └─ N analysis_result
Spring Scheduler java@Scheduled(cron = "0 0 0 * * *") *// 매일 자정* public void collectYouTubeMetrics() { ... } 작업 흐름: 모든 연동 계정 조회
토큰 만료 확인 → refresh token으로 갱신
API 호출로 최신 영상/조회수/좋아요/댓글 갱신
video_metric 테이블 업데이트
필요 시 AI 분석 요청 및 결과 저장 사용자 로그인 → 계정 연동(OAuth2)
스케줄러 또는 사용자 요청 시 API 호출 → YouTube API에서 데이터 수집
AI 서버 분석 요청 → 감정 분석, 인사이트, 추천 결과
분석/리포트 DB 저장
프론트엔드 대시보드/리포트 제공 및 다운로드
💡 이렇게 구성하면
데이터 수집(A), 분석(B), 관리(C) 구조가 명확하게 구분
YouTube API 활용, OAuth2 토큰 관리, AI 서버 연동, DB 설계, 스케줄링까지 포함된 완전한 Spring Boot 기반 아키텍처 완성
]]></description><link>kt에이블/빅프/ai문서/설계/성과분석계획.html</link><guid isPermaLink="false">kt에이블/빅프/ai문서/설계/성과분석계획.md</guid><pubDate>Wed, 13 Aug 2025 06:01:30 GMT</pubDate></item><item><title><![CDATA[게시글_sns_관련_db]]></title><description><![CDATA[소셜 미디어 계정, 게시글, 성과지표, 댓글을 관리하는 데이터베이스 스키마입니다.소셜 미디어 계정 정보를 저장하는 테이블소셜 미디어 게시글 정보를 저장하는 테이블소셜 미디어 게시글의 성과 지표를 저장하는 테이블소셜 미디어 게시글의 댓글을 저장하는 테이블
SOCIAL_ACCOUNT → SOCIAL_POST: 하나의 소셜 계정이 여러 개의 게시글을 가질 수 있음
SOCIAL_POST → POST_METRIC: 하나의 게시글이 여러 개의 성과지표 기록을 가질 수 있음 (시간별 스냅샷)
SOCIAL_POST → COMMENT: 하나의 게시글이 여러 개의 댓글을 가질 수 있음 SOCIAL_POST.social_account_id → SOCIAL_ACCOUNT.id
POST_METRIC.social_post_id → SOCIAL_POST.id
COMMENT.social_post_id → SOCIAL_POST.id
]]></description><link>kt에이블/빅프/ai문서/설계/게시글_sns_관련_db.html</link><guid isPermaLink="false">kt에이블/빅프/ai문서/설계/게시글_sns_관련_db.md</guid><pubDate>Wed, 13 Aug 2025 06:01:30 GMT</pubDate></item><item><title><![CDATA[성과분석 다이어어그램]]></title><description><![CDATA[┌───────────────────────────┐
│ Frontend │
│ (React/Vue, Dashboard UI) │
│ │
│ - 로그인/회원가입 │
│ - 계정 연동 버튼 │
│ - 영상/지표 확인 │
│ - 리포트 생성 요청 │
└──────────────▲────────────┘ │ REST API ▼
┌───────────────────────────┐
│ Spring Boot API │
│ (Backend Server) │
├───────────────────────────┤
│ ① 계정/토큰 관리 모듈 │
│ - OAuth2 인증 처리 │
│ - access/refresh token │
│ - 만료 처리/자동갱신 │
├───────────────────────────┤
│ ② 데이터 수집 모듈([A]) │
│ - YouTube API 호출 │
│ - channels/videos │
│ - statistics/comments │
├───────────────────────────┤
│ ③ AI 분석 연동 모듈([B]) │
│ - 감정분석, 인기콘텐츠 │
│ - 최적게시시간 분석 │
│ - 리포트 생성 │
├───────────────────────────┤
│ ④ 성과 관리·조회 모듈([C]) │
│ - 분석 결과 조회 │
│ - 전체 이력 관리 │
│ - 지표 다운로드 │
├───────────────────────────┤
│ ⑤ 스케줄링 배치 │
│ - @Scheduled 사용 │
│ - 매일 자정 배치실행 │
│ - 토큰 갱신 후 데이터수집│
└───────────▲────────────────┘ │ ┌─────────┴─────────┐ │ │ ▼ ▼
┌───────────────────────────┐
│ YouTube API Provider │
│ (Data API / Analytics API)│
│ - 채널/영상 메트릭 조회 │
│ - 댓글 목록/감정 분석용 │
└───────────────────────────┘
┌───────────────────────────┐
│ AI 분석 서버 │
│ - 감정분석 모델 │
│ - 트렌드 분석 │
│ - 추천 알고리즘 │
│ - 리포트 생성 │
└───────────────────────────┘ ┌───────────────────────────┐
│ DB │
│ (MySQL / PostgreSQL 등) │
│ - user │
│ - youtube_account │
│ - video │
│ - video_metric │
│ - analysis_result │
│ - report │
└───────────────────────────┘ `text[사용자/프론트엔드]
├─ 로그인 / 회원가입
├─ YouTube 계정 연동(OAuth2)
├─ 대시보드 조회
├─ 보고서 생성·다운로드
│
▼ REST API 요청
[Spring Boot 백엔드 서버]
├─ 계정/토큰 관리
│ ├─ OAuth2 인증 처리
│ ├─ Access/Refresh Token 저장
│ └─ 토큰 만료 시 자동 갱신
├─ 데이터 수집 모듈 [A]
│ ├─ YouTube Data API 호출
│ ├─ 영상/채널 통계
│ └─ 댓글 목록 수집
├─ AI 분석 연동 모듈 [B]
│ ├─ 댓글 감성 분석
│ ├─ 트렌드/최적 시간 분석
│ └─ 성과 리포트 생성
├─ 성과 관리·조회 모듈 [C]
│ ├─ 전체 지표 이력 조회
│ ├─ 분석결과 조회
│ └─ CSV/Excel 다운로드
├─ 스케줄링 배치
│ ├─ 매일 자정 실행
│ ├─ 토큰 점검·갱신
│ └─ 데이터 자동 수집
│
├─────────→ [YouTube API Provider]
│ ├─ Data API
│ └─ Analytics API
│
└─────────→ [AI 분석 서버]
├─ 감성 분석 모델
├─ 트렌드 &amp; 추천
└─ 보고서 생성 엔진[데이터베이스]
├─ user
├─ youtube_account
├─ video
├─ video_metric
├─ analysis_result
└─ report`
좌 → 우 흐름: 사용자 → 백엔드 → 외부 API/AI → DB
백엔드 내부: 4개의 모듈(A/B/C/스케줄링)을 색깔로 구분
API 경로 추가: 각 모듈 옆에 주요 REST 엔드포인트 표시
DB 관계선: user → youtube_account → video → video_metric &amp; analysis_result &amp; report
]]></description><link>kt에이블/빅프/ai문서/설계/성과분석-다이어어그램.html</link><guid isPermaLink="false">kt에이블/빅프/ai문서/설계/성과분석 다이어어그램.md</guid><pubDate>Wed, 13 Aug 2025 06:01:30 GMT</pubDate></item><item><title><![CDATA[analytics-serves-1]]></title><description><![CDATA[YouTube 성과 분석을 위한 MSA 서비스입니다. 헥사고날 아키텍처로 구현되었으며, SNS 서비스에서 토큰 이벤트를 받아서 YouTube 데이터를 수집하고 AI 분석을 수행합니다.┌─────────────────────────────────────────────────────────────┐
│ Adapter Layer │
├─────────────────────────────────────────────────────────────┤
│ Inbound Adapters Outbound Adapters │
│ ├─ Web Controller ├─ Persistence │
│ ├─ Event Consumer ├─ External API │
│ └─ ... └─ Event Producer │
├─────────────────────────────────────────────────────────────┤
│ Application Layer │
│ ├─ Use Cases (Port In) │
│ ├─ Services │
│ └─ Port Out │
├─────────────────────────────────────────────────────────────┤
│ Domain Layer │
│ ├─ Entities (VideoMetric, AnalysisResult) │
│ ├─ Ports (Repository Port) │
│ └─ Domain Services │
└─────────────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────────────┐
│ Controller Layer │
│ ├─ Request/Response DTOs │
│ ├─ Command/Query Mappers │
│ └─ Validation │
├─────────────────────────────────────────────────────────────┤
│ Application Layer │
│ ├─ Commands (CollectMetricsCommand, GetDashboardStatisticsCommand) │
│ ├─ Queries (GetVideoMetricsCommand, GetTopContentCommand) │
│ └─ Use Cases (AnalyticsUseCase, AnalyticsEventUseCase) │
├─────────────────────────────────────────────────────────────┤
│ Domain Layer │
│ ├─ Entities (VideoMetric, AnalysisResult) │
│ ├─ Ports (VideoMetricRepositoryPort) │
│ └─ Domain Services │
└─────────────────────────────────────────────────────────────┘ YouTube Data API v3 연동: 채널 정보, 비디오 목록, 메트릭 수집 /youtube/v3/channels: 채널 정보 및 통계 조회
/youtube/v3/search: 채널의 비디오 목록 조회
/youtube/v3/videos: 비디오별 상세 메트릭 조회 토큰 관리: OAuth2 토큰 자동 갱신 (구현 예정)
스케줄링: 매일 자정 자동 데이터 수집 (구현 예정) 대시보드 통계: 조회수, 좋아요, 댓글, 참여율 등
감정 분석: 댓글 감정 분석 (AI 서버 연동)
트렌드 분석: 성과 트렌드 및 인사이트
최적 게시 시간: AI 기반 최적 게시 시간 추천 성과 리포트: 기간별 상세 분석 리포트
상위 콘텐츠: 성과가 좋은 콘텐츠 목록
데이터 내보내기: CSV/Excel 다운로드 (구현 예정) POST /api/analytics/collect-metrics - 메트릭 수집 시작 Headers: X-USER-ID
Query: snsType GET /api/analytics/dashboard - 대시보드 통계 조회 Headers: X-USER-ID
Body: DashboardStatisticsRequest (startDate, endDate) GET /api/analytics/video-metrics - 비디오별 메트릭 조회 Headers: X-USER-ID
Body: VideoMetricsRequest (videoId, startDate, endDate) GET /api/analytics/top-content - 상위 성과 콘텐츠 Headers: X-USER-ID
Query: limit (default: 10) POST /api/analytics/analyze-sentiment - 감정 분석 Headers: X-USER-ID
Query: videoId POST /api/analytics/analyze-trends - 트렌드 분석 Headers: X-USER-ID
Body: AnalysisRequest (startDate, endDate) POST /api/analytics/analyze-optimal-time - 최적 게시 시간 분석 Headers: X-USER-ID POST /api/analytics/generate-report - 리포트 생성 Headers: X-USER-ID
Body: AnalysisRequest (startDate, endDate) POST /api/analytics/refresh-token - 토큰 갱신 Headers: X-USER-ID
Query: snsType Analytics Service는 실제로 필요할 때만 Post Service와 SNS Service에 요청하여 최신 데이터를 받습니다. 이를 통해 불필요한 이벤트 처리와 데이터 동기화 복잡성을 제거합니다.
sns-token.response: SNS 토큰 정보 응답 이벤트
social-post.response: Post Service로부터 받는 게시글 정보 응답 이벤트 sns-token.request: SNS 토큰 정보 요청 이벤트
social-post.request: Post Service에 게시글 정보 요청 이벤트 Consumer Group: analytics-service
Auto Offset Reset: earliest
Trusted Packages: * (모든 패키지 허용)
Analytics Service → Kafka → Post Service → Kafka → Analytics Service ↓ ↓ ↓
1. 메트릭 수집 시 2. 게시글 정보 조회 3. 게시글 정보 응답 게시글 요청 이벤트 및 반환 이벤트 발행 발행
Analytics Service → Kafka → SNS Service → Kafka → Analytics Service ↓ ↓ ↓
1. 메트릭 수집 시 2. 토큰 정보 조회 3. 토큰 정보 응답 토큰 요청 이벤트 및 반환 이벤트 발행 발행
{ "requestId": "req123", "userId": "user123", "snsType": "youtube", "startDate": "2024-01-01", "endDate": "2024-01-31"
}
{ "requestId": "req123", "userId": "user123", "snsType": "youtube", "posts": [ { "id": 1, "socialAccountId": 1, "postId": 1, "snsPostId": "dQw4w9WgXcQ", "status": "published", "postedAt": "2024-01-01T00:00:00Z", "title": "비디오 제목", "description": "비디오 설명", "thumbnailUrl": "https://..." } ]
}
{ "requestId": "req123", "userId": "user123", "snsType": "youtube"
}
{ "requestId": "req123", "userId": "user123", "snsType": "youtube", "accessToken": "ya29.a0...", "refreshToken": "1//04...", "expiresAt": 1704067200000, "isExpired": false
}
post_metric (1) ── (N) analysis_result
comment (1) ── (N) analysis_result
모든 테이블은 BaseEntity를 상속받아 다음 컬럼을 포함합니다:
created_at: 생성 시간 (자동 설정, 수정 불가)
updated_at: 수정 시간 (자동 업데이트) post_metric 테이블: idx_user_id: 사용자별 조회 성능 향상
idx_social_post_id_metric_date: 게시글별 날짜 범위 조회 성능 향상
idx_user_id_date_range: 사용자별 날짜 범위 조회 성능 향상 comment 테이블: idx_user_id: 사용자별 조회 성능 향상
idx_social_post_id: 게시글별 댓글 조회 성능 향상
idx_crawled_at: 수집 시간별 조회 성능 향상 analysis_result 테이블: idx_user_id: 사용자별 조회 성능 향상
idx_analysis_type: 분석 타입별 조회 성능 향상 analytics-service/
├── src/main/java/kt/aivle/analytics/
│ ├── adapter/
│ │ ├── in/
│ │ │ ├── web/
│ │ │ │ ├── dto/
│ │ │ │ │ ├── AnalyticsResponse.java
│ │ │ │ │ ├── VideoMetricsResponse.java
│ │ │ │ │ ├── AnalysisResultResponse.java
│ │ │ │ │ ├── DashboardStatistics.java
│ │ │ │ │ ├── DashboardStatisticsRequest.java
│ │ │ │ │ ├── VideoMetricsRequest.java
│ │ │ │ │ └── AnalysisRequest.java
│ │ │ │ ├── mapper/
│ │ │ │ │ └── AnalyticsCommandMapper.java
│ │ │ │ └── AnalyticsController.java
│ │ │ └── event/
│ │ │ ├── consumer/
│ │ │ │ └── SnsTokenRequestEventConsumer.java
│ │ │ └── dto/
│ │ │ └── SnsTokenRequestEvent.java
│ │ └── out/
│ │ ├── persistence/
│ │ │ ├── VideoMetricRepository.java
│ │ │ └── VideoMetricJpaRepository.java
│ │ ├── external/
│ │ │ └── ExternalApiAdapter.java
│ │ └── event/
│ │ ├── SnsTokenEventProducer.java
│ │ └── SnsTokenResponseEvent.java
│ ├── application/
│ │ ├── port/
│ │ │ ├── in/
│ │ │ │ ├── command/
│ │ │ │ │ ├── CollectMetricsCommand.java
│ │ │ │ │ ├── GetDashboardStatisticsCommand.java
│ │ │ │ │ ├── GetVideoMetricsCommand.java
│ │ │ │ │ ├── AnalyzeSentimentCommand.java
│ │ │ │ │ ├── AnalyzeTrendsCommand.java
│ │ │ │ │ ├── AnalyzeOptimalTimeCommand.java
│ │ │ │ │ ├── GetTopContentCommand.java
│ │ │ │ │ ├── GenerateReportCommand.java
│ │ │ │ │ └── RefreshTokenCommand.java
│ │ │ │ ├── AnalyticsUseCase.java
│ │ │ │ └── AnalyticsEventUseCase.java
│ │ │ └── out/
│ │ │ └── ExternalApiPort.java
│ │ └── service/
│ │ ├── AnalyticsService.java
│ │ └── AnalyticsEventService.java
│ ├── domain/
│ │ ├── entity/
│ │ │ ├── BaseEntity.java
│ │ │ ├── VideoMetric.java
│ │ │ └── AnalysisResult.java
│ │ ├── model/
│ │ │ ├── SnsType.java
│ │ │ └── AnalysisType.java
│ │ └── port/
│ │ └── out/
│ │ └── VideoMetricRepositoryPort.java
│ ├── config/
│ │ ├── RestTemplateConfig.java
│ │ ├── KafkaConfig.java
│ │ └── JpaConfig.java
│ ├── exception/
│ │ └── AnalyticsErrorCode.java
│ └── AnalyticsServiceApplication.java
└── src/main/resources/ └── application.yml 채널 정보 조회
GET https://www.googleapis.com/youtube/v3/channels
Parameters: part=snippet,statistics&amp;mine=true
Headers: Authorization: Bearer {access_token} 응답 예시:
{ "kind": "youtube#channelListResponse", "etag": "\"etag\"", "pageInfo": { "totalResults": 1, "resultsPerPage": 1 }, "items": [ { "kind": "youtube#channel", "etag": "\"etag\"", "id": "UC_x5XG1OV2P6uZZ5FSM9Ttw", "snippet": { "title": "Google Developers", "description": "Google Developers 공식 채널", "publishedAt": "2007-08-23T00:34:43.000Z", "thumbnails": { "default": {"url": "https://...", "width": 88, "height": 88}, "medium": {"url": "https://...", "width": 240, "height": 240}, "high": {"url": "https://...", "width": 800, "height": 800} } }, "statistics": { "viewCount": "123456789", "subscriberCount": "1000000", "hiddenSubscriberCount": false, "videoCount": "500" } } ]
} 비디오 목록 조회
GET https://www.googleapis.com/youtube/v3/search
Parameters: part=snippet&amp;channelId={channelId}&amp;maxResults=50&amp;order=date&amp;type=video
Headers: Authorization: Bearer {access_token} 응답 예시:
{ "kind": "youtube#searchListResponse", "etag": "\"etag\"", "nextPageToken": "CAUQAA", "pageInfo": { "totalResults": 1000, "resultsPerPage": 50 }, "items": [ { "kind": "youtube#searchResult", "etag": "\"etag\"", "id": { "kind": "youtube#video", "videoId": "dQw4w9WgXcQ" }, "snippet": { "publishedAt": "2024-01-01T00:00:00Z", "channelId": "UC_x5XG1OV2P6uZZ5FSM9Ttw", "title": "비디오 제목", "description": "비디오 설명", "thumbnails": { "default": {"url": "https://...", "width": 120, "height": 90}, "medium": {"url": "https://...", "width": 320, "height": 180}, "high": {"url": "https://...", "width": 480, "height": 360} }, "channelTitle": "채널명", "publishTime": "2024-01-01T00:00:00Z" } } ]
} 비디오 메트릭 조회
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/v3/docs/videos/list" target="_self">https://developers.google.com/youtube/v3/docs/videos/list</a>
GET https://www.googleapis.com/youtube/v3/videos
Parameters: part=statistics&amp;id={videoId}
Headers: Authorization: Bearer {access_token} 응답 예시:
{ "kind": "youtube#videoListResponse", "etag": "\"etag\"", "pageInfo": { "totalResults": 1, "resultsPerPage": 1 }, "items": [ { "kind": "youtube#video", "etag": "\"etag\"", "id": "dQw4w9WgXcQ", "statistics": { "viewCount": "1234567", "likeCount": "12345", "favoriteCount": "0", "commentCount": "1234" } } ]
} 조회수 (viewCount)
좋아요 수 (likeCount)
댓글 수 (commentCount)
구독자 수 (subscriberCount)
비디오 수 (videoCount)
참고: shareCount(공유 수)는 YouTube Data API v3에서 제공되지 않으며, YouTube Analytics API에서만 조회 가능합니다.
https://www.googleapis.com/auth/youtube.readonly: YouTube 데이터 읽기 권한 일일 할당량: 10,000 units/day (기본값)
초당 요청 제한: 300 requests/second
채널 조회: mine=true 사용 시 인증된 사용자의 채널만 조회
비디오 목록: 최대 50개씩 조회 (maxResults=50)
{ "error": { "code": 403, "message": "Daily Limit Exceeded. The quota will be reset at midnight Pacific Time (PT).", "errors": [ { "message": "Daily Limit Exceeded. The quota will be reset at midnight Pacific Time (PT).", "domain": "usageLimits", "reason": "dailyLimitExceeded" } ] }
} 400: 잘못된 요청 (잘못된 매개변수)
401: 인증 실패 (토큰 만료 또는 잘못됨)
403: 권한 없음 (할당량 초과, 스코프 부족)
404: 리소스를 찾을 수 없음
500: 서버 내부 오류 YOUTUBE_API_KEY: YouTube Data API 키
AI_SERVER_URL: AI 분석 서버 URL
MYSQL_USER: MySQL 사용자명
MYSQL_PASSWORD: MySQL 비밀번호 서비스 포트: 8084
MySQL: 3307
Kafka: 9092
# 전체 서비스 실행
./docker-manager.sh # 또는 직접 실행
docker-compose up analytics-service
# Gradle 빌드
./gradlew :analytics-service:build # 실행
./gradlew :analytics-service:bootRun SnsType enum에 새 타입 추가 (현재: YOUTUBE, INSTAGRAM, TIKTOK, TWITTER)
ExternalApiAdapter에 API 호출 로직 구현
AnalyticsService의 collectMetrics 메서드에 분기 추가 AnalysisResult.AnalysisType에 새 타입 추가 (SENTIMENT_ANALYSIS, TREND_ANALYSIS, OPTIMAL_POSTING_TIME, CONTENT_PERFORMANCE, AUDIENCE_ANALYSIS)
AnalyticsUseCase에 새 메서드 정의
AnalyticsService에 구현
AnalyticsController에 API 엔드포인트 추가 Command: 데이터를 변경하는 작업 (Create, Update, Delete)
Query: 데이터를 조회하는 작업 (Get, List, Search)
Mapper: DTO와 Command/Query 간의 변환 Request DTO: 클라이언트로부터 받는 데이터 (검증 포함)
Response DTO: 클라이언트에게 반환하는 데이터
Validation: @Valid, @NotNull, @NotBlank 등 사용 Event Consumer: Kafka 토픽에서 토큰 응답 이벤트 수신 및 처리
Event Producer: SNS Service로 토큰 요청 이벤트 발행
Event UseCase: 이벤트 처리 로직 분리
On-Demand Pattern: 필요할 때만 토큰 정보 요청 DEBUG: 상세 디버그 정보
INFO: 일반 정보
WARN: 경고 메시지
ERROR: 오류 메시지 메트릭 수집 성공률
API 호출 응답 시간
토큰 갱신 성공률
분석 처리 시간
Kafka 이벤트 처리 성공률
모든 API는 일관된 응답 형식을 사용합니다:{ "code": "OK", "message": "성공", "data": { // 실제 응답 데이터 }, "timestamp": "2024-01-01T00:00:00Z"
}
{ "code": "ANALYTICS_001", "message": "토큰을 찾을 수 없습니다.", "data": null, "timestamp": "2024-01-01T00:00:00Z"
} InfraException: Kafka 이벤트 처리 실패 시 발생
재시도 로직: 실패한 이벤트에 대한 재시도 메커니즘
데드 레터 큐: 처리 실패한 이벤트를 별도 토픽으로 이동 토큰 관련: ANALYTICS_001 (토큰을 찾을 수 없음), ANALYTICS_002 (토큰 만료), ANALYTICS_003 (토큰 갱신 실패)
YouTube API 관련: ANALYTICS_101 (API 호출 실패), ANALYTICS_102 (채널을 찾을 수 없음), ANALYTICS_103 (비디오를 찾을 수 없음)
AI 서버 관련: ANALYTICS_201 (AI 서버 호출 실패), ANALYTICS_202 (감정 분석 실패), ANALYTICS_203 (트렌드 분석 실패)
메트릭 관련: ANALYTICS_301 (메트릭 수집 실패), ANALYTICS_302 (유효하지 않은 날짜 범위)
기타: ANALYTICS_401 (지원하지 않는 SNS 타입), ANALYTICS_501 (Kafka 이벤트 처리 실패) 헥사고날 아키텍처 구조
YouTube Data API v3 연동 (채널, 비디오 목록, 메트릭 수집)
비디오 메트릭 수집 및 저장
대시보드 통계 조회
On-Demand 토큰 요청 패턴
AI 서버 연동 (감정 분석, 트렌드 분석, 최적 게시 시간) 토큰 자동 갱신 로직
스케줄링된 데이터 수집
데이터 내보내기 (CSV/Excel) YouTube Analytics API 연동 (상세 분석 데이터, 공유 수 등)
실시간 알림 기능
성능 최적화 (캐싱, 배치 처리)
YouTube Analytics API는 YouTube Data API v3보다 더 상세한 분석 데이터를 제공합니다. 채널 소유자만 접근 가능하며, 복잡한 쿼리 파라미터를 사용합니다.
OAuth 2.0 스코프: https://www.googleapis.com/auth/yt-analytics.readonly
권한: 채널 소유자만 접근 가능
채널 식별: ids=channel==MINE 또는 ids=channel==CHANNEL_ID
GET https://youtubeanalytics.googleapis.com/v2/reports
Parameters: ids=channel==MINE startDate=2024-01-01 endDate=2024-01-31 metrics=views,likes,shares,subscribersGained,subscribersLost dimensions=day sort=day
응답 예시:{ "kind": "youtubeAnalytics#resultTable", "columnHeaders": [ { "name": "day", "columnType": "DIMENSION", "dataType": "STRING" }, { "name": "views", "columnType": "METRIC", "dataType": "INTEGER" }, { "name": "likes", "columnType": "METRIC", "dataType": "INTEGER" }, { "name": "shares", "columnType": "METRIC", "dataType": "INTEGER" } ], "rows": [ ["2024-01-01", 1234, 56, 12], ["2024-01-02", 2345, 78, 23], ["2024-01-03", 3456, 90, 34] ]
}
GET https://youtubeanalytics.googleapis.com/v2/reports
Parameters: ids=channel==MINE startDate=2024-01-01 endDate=2024-01-31 metrics=views,likes,shares,averageViewDuration,averageViewPercentage dimensions=video filters=video==VIDEO_ID1,VIDEO_ID2 sort=-views
응답 예시:{ "kind": "youtubeAnalytics#resultTable", "columnHeaders": [ { "name": "video", "columnType": "DIMENSION", "dataType": "STRING" }, { "name": "views", "columnType": "METRIC", "dataType": "INTEGER" }, { "name": "averageViewDuration", "columnType": "METRIC", "dataType": "FLOAT" }, { "name": "averageViewPercentage", "columnType": "METRIC", "dataType": "FLOAT" } ], "rows": [ ["dQw4w9WgXcQ", 50000, 180.5, 65.2], ["abc123def456", 30000, 120.3, 45.8] ]
}
GET https://youtubeanalytics.googleapis.com/v2/reports
Parameters: ids=channel==MINE startDate=2024-01-01 endDate=2024-01-31 metrics=views,estimatedMinutesWatched dimensions=country sort=-views
응답 예시:{ "kind": "youtubeAnalytics#resultTable", "columnHeaders": [ { "name": "country", "columnType": "DIMENSION", "dataType": "STRING" }, { "name": "views", "columnType": "METRIC", "dataType": "INTEGER" }, { "name": "estimatedMinutesWatched", "columnType": "METRIC", "dataType": "INTEGER" } ], "rows": [ ["US", 50000, 75000], ["KR", 30000, 45000], ["JP", 20000, 30000] ]
}
GET https://youtubeanalytics.googleapis.com/v2/reports
Parameters: ids=channel==MINE startDate=2024-01-01 endDate=2024-01-31 metrics=views,estimatedMinutesWatched dimensions=insightTrafficSourceDetail sort=-views
응답 예시:{ "kind": "youtubeAnalytics#resultTable", "columnHeaders": [ { "name": "insightTrafficSourceDetail", "columnType": "DIMENSION", "dataType": "STRING" }, { "name": "views", "columnType": "METRIC", "dataType": "INTEGER" } ], "rows": [ ["ADVERTISING", 15000], ["EXTERNAL_URL", 12000], ["PROMOTED", 8000], ["SEARCH", 5000] ]
}
GET https://youtubeanalytics.googleapis.com/v2/reports
Parameters: ids=channel==MINE startDate=2024-01-01 endDate=2024-01-31 metrics=views,estimatedMinutesWatched dimensions=deviceType sort=-views
응답 예시:{ "kind": "youtubeAnalytics#resultTable", "columnHeaders": [ { "name": "deviceType", "columnType": "DIMENSION", "dataType": "STRING" }, { "name": "views", "columnType": "METRIC", "dataType": "INTEGER" } ], "rows": [ ["MOBILE", 60000], ["DESKTOP", 30000], ["TABLET", 10000] ]
} views: 조회수
likes: 좋아요 수
shares: 공유 수
comments: 댓글 수
subscribersGained: 새 구독자 수
subscribersLost: 구독 취소 수 averageViewDuration: 평균 시청 시간 (초)
averageViewPercentage: 평균 시청률 (%)
estimatedMinutesWatched: 예상 시청 시간 (분)
estimatedRevenue: 예상 수익 (수익 창출 채널만)
adImpressions: 광고 노출수
cpm: CPM (Cost Per Mille) day: 일별
week: 주별
month: 월별 video: 비디오별
playlist: 재생목록별
creatorContentType: 콘텐츠 타입 (동영상, Shorts 등) country: 국가별
continent: 대륙별
subContinent: 하위 대륙별 insightTrafficSourceDetail: 트래픽 소스
deviceType: 디바이스 타입
operatingSystem: 운영체제 video==VIDEO_ID: 특정 비디오
country==US: 특정 국가
deviceType==MOBILE: 특정 디바이스
insightTrafficSourceDetail==SEARCH: 특정 트래픽 소스 일일 할당량: 10,000 units/day
최대 결과 수: 200개 행
날짜 범위: 최대 93일
실시간 데이터: 2-3일 지연 복잡한 쿼리: dimensions, metrics, filters 조합이 복잡
권한 관리: 채널 소유자 권한 필요
데이터 지연: 실시간이 아닌 2-3일 지연
할당량 관리: 일일 할당량 제한으로 인한 효율적 사용 필요 <br><a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/analytics/channel_reports?hl=ko" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/analytics/channel_reports?hl=ko" target="_self">YouTube Analytics API 공식 문서</a>
<br><a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/analytics/api_reference?hl=ko" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/analytics/api_reference?hl=ko" target="_self">API 참조</a>
<br><a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/analytics/dimsmets?hl=ko" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/analytics/dimsmets?hl=ko" target="_self">측정항목 및 차원</a>
]]></description><link>kt에이블/빅프/ai문서/설계/analytics-serves-1.html</link><guid isPermaLink="false">kt에이블/빅프/ai문서/설계/analytics-serves-1.md</guid><pubDate>Wed, 13 Aug 2025 06:01:30 GMT</pubDate></item><item><title><![CDATA[Store_Service_Database_설계]]></title><description><![CDATA[Store Service는 사용자의 가게 정보를 관리하는 서비스입니다. MySQL 데이터베이스를 사용하며, JPA/Hibernate를 통해 객체-관계 매핑을 구현합니다. 또한 Kafka를 활용하여 다른 서비스와의 이벤트 기반 통신을 지원합니다.
역할: 공통 필드 정의
필드: id: 기본키 (AUTO_INCREMENT)
createdAt: 생성 시간 (자동 설정)
updatedAt: 수정 시간 (자동 설정) 어노테이션: @MappedSuperclass, @EntityListeners(AuditingEntityListener.class) 상속: BaseEntity 상속
역할: 가게 정보 저장
특징: 사용자별 가게 관리 (userId로 소유권 구분)
위치 정보 저장 (위도, 경도)
업종 분류 (Industry enum 사용)
사업자등록번호 선택적 저장 역할: 업종 분류 정의
구성: 22개 업종 + 기타
저장 방식: @Enumerated(EnumType.STRING)
public record StoreInfoRequestEvent( String requestId, // 요청 ID Long storeId // 가게 ID
) {}
public record StoreInfoResponseEvent( String requestId, // 요청 ID Long storeId, // 가게 ID String name, // 가게명 String address, // 주소 String phoneNumber, // 연락처 Double latitude, // 위도 Double longitude, // 경도 String industry // 업종
) {} 사용자 ID와 가게 정보로 CreateStoreCommand 생성
Store 엔티티 생성 및 저장
StoreResponse 반환 사용자 ID로 소유권 확인
가게 정보 조회 (findById 또는 findAllByUserId)
StoreResponse 변환하여 반환 사용자 ID로 소유권 확인
기존 가게 정보 조회
update() 메서드로 정보 수정
수정된 정보 저장 및 반환 사용자 ID로 소유권 확인
가게 정보 조회
가게 삭제 (delete) store.info.request 토픽에서 요청 수신
가게 ID로 정보 조회
StoreInfoResponseEvent 생성
store.info.response 토픽으로 응답 전송
]]></description><link>kt에이블/빅프/ai문서/설계/store_service_database_설계.html</link><guid isPermaLink="false">kt에이블/빅프/ai문서/설계/Store_Service_Database_설계.md</guid><pubDate>Wed, 13 Aug 2025 06:01:30 GMT</pubDate></item><item><title><![CDATA[Auth_Service_Database_설계]]></title><description><![CDATA[Auth Service는 사용자 인증, 회원가입, 로그인, OAuth2 연동을 담당하는 서비스입니다. MySQL 데이터베이스를 사용하며, JPA/Hibernate를 통해 객체-관계 매핑을 구현합니다. 또한 Redis를 활용하여 토큰 관리와 보안을 강화합니다.
역할: 공통 필드 정의
필드: id: 기본키 (AUTO_INCREMENT)
createdAt: 생성 시간 (자동 설정)
updatedAt: 수정 시간 (자동 설정) 어노테이션: @MappedSuperclass, @EntityListeners(AuditingEntityListener.class) 상속: BaseEntity 상속
역할: 사용자 정보 및 인증 데이터 저장
특징: 로컬 회원가입과 OAuth 로그인 모두 지원
로그인 실패 횟수 관리 및 계정 잠금 기능
이메일 중복 방지 (UNIQUE 제약조건) public enum OAuthProvider { KAKAO, GOOGLE;
} 목적: Refresh Token의 안전한 저장 및 관리
만료 시간: 14일
키 구조: refresh_token:{token}
값: userId 목적: 로그아웃된 토큰의 무효화
만료 시간: 토큰의 남은 만료 시간
키 구조: blacklist:{jti}
값: expiration_time 이메일 중복 확인 (existsByEmail)
비밀번호 정책 검증 (UserPasswordPolicy)
비밀번호 암호화 (PasswordEncoder)
User 엔티티 생성 및 저장
JWT 토큰 생성 및 Refresh Token Redis 저장 이메일로 사용자 조회 (findByEmail)
비밀번호 검증 (PasswordEncoder)
로그인 실패 횟수 관리 (increaseLoginFailCount)
계정 잠금 확인 (locked 필드)
JWT 토큰 생성 및 Refresh Token Redis 저장 OAuth 제공자별 사용자 정보 변환
기존 OAuth 사용자 조회 (findByProviderAndProviderId)
이메일 기반 기존 회원 연결 또는 새 사용자 생성
JWT 토큰 생성 및 Refresh Token Redis 저장 Refresh Token 유효성 검증 (Redis 조회)
기존 Access Token 블랙리스트 추가
새로운 JWT 토큰 생성
기존 Refresh Token 삭제 및 새 토큰 저장 Access Token 서명 검증
만료되지 않은 토큰을 블랙리스트에 추가
Refresh Token Redis에서 삭제
]]></description><link>kt에이블/빅프/ai문서/설계/auth_service_database_설계.html</link><guid isPermaLink="false">kt에이블/빅프/ai문서/설계/Auth_Service_Database_설계.md</guid><pubDate>Wed, 13 Aug 2025 06:01:30 GMT</pubDate></item><item><title><![CDATA[SNS_Service_Database_설계]]></title><description><![CDATA[SNS Service는 YouTube, Facebook, Instagram 등 다양한 SNS 플랫폼과 연동하여 콘텐츠 관리 및 분석을 제공하는 서비스입니다. MySQL 데이터베이스를 사용하며, JPA/Hibernate를 통해 객체-관계 매핑을 구현합니다.
데이터베이스: MySQL
호스트: mysql:3306
데이터베이스명: userstore
JPA 설정: hibernate.ddl-auto=update (자동 스키마 업데이트)
관련 테이블: post_tags관련 테이블: account_keywords
주 엔티티: 게시물 정보 저장
관계: @ElementCollection로 post_tags 테이블과 1:N 관계
userId로 사용자와 연결
snsType으로 SNS 플랫폼 구분 주 엔티티: SNS 계정 정보 저장
관계: @ElementCollection로 account_keywords 테이블과 1:N 관계
userId로 사용자와 연결
snsType으로 SNS 플랫폼 구분 주 엔티티: OAuth 토큰 정보 저장
관계: userId와 snsType으로 사용자와 SNS 플랫폼 연결
access_token, refresh_token을 LONGTEXT로 저장 OAuth2 인증 후 SnsToken 테이블에 토큰 저장
YouTube API로 채널 정보 조회 후 SnsAccount 테이블에 저장
기존 동영상 목록 조회 후 PostEntity 테이블에 저장 YouTube API로 동영상 업로드
업로드 성공 시 PostEntity 테이블에 동영상 정보 저장
태그 정보는 post_tags 테이블에 별도 저장 YouTube Analytics API로 메트릭 데이터 수집
YoutubeAnalyticsResponse 객체로 분석 결과 처리
필요시 AI 서버로 추가 분석 요청
]]></description><link>kt에이블/빅프/ai문서/설계/sns_service_database_설계.html</link><guid isPermaLink="false">kt에이블/빅프/ai문서/설계/SNS_Service_Database_설계.md</guid><pubDate>Wed, 13 Aug 2025 06:01:30 GMT</pubDate></item><item><title><![CDATA[핵사고날아키택처]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://xxeol.tistory.com/27" target="_self">https://xxeol.tistory.com/27</a>]]></description><link>kt에이블/빅프/핵사고날아키택처.html</link><guid isPermaLink="false">kt에이블/빅프/핵사고날아키택처.md</guid><pubDate>Wed, 13 Aug 2025 01:39:23 GMT</pubDate></item><item><title><![CDATA[command event]]></title><description><![CDATA[// Command: 사용자가 직접 요청POST /api/analytics/collect-metrics{
"userId": "user123",
"snsType": "youtube"
}// Event: 다른 서비스에서 자동 발행{
"userId": "user123",
"snsType": "youtube",
"accessToken": "ya29.a0...
}
결론:&nbsp;Command는&nbsp;"해라", Event는 "일어났다"의 차이야!]]></description><link>kt에이블/빅프/command-event.html</link><guid isPermaLink="false">kt에이블/빅프/command event.md</guid><pubDate>Tue, 12 Aug 2025 06:07:49 GMT</pubDate></item><item><title><![CDATA[jpa사용법]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@minju0426/JPARepository%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90%EC%82%AC%EC%9A%A9%EB%B2%95-Method" target="_self">https://velog.io/@minju0426/JPARepository%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90%EC%82%AC%EC%9A%A9%EB%B2%95-Method</a>]]></description><link>kt에이블/빅프/jpa사용법.html</link><guid isPermaLink="false">kt에이블/빅프/jpa사용법.md</guid><pubDate>Tue, 12 Aug 2025 05:32:04 GMT</pubDate></item><item><title><![CDATA[카프카  기본설정]]></title><description><![CDATA[<img alt="카프카 기본설정-1754975621685.png" src="kt에이블/빅프/assets/카프카-기본설정-1754975621685.png" target="_self">]]></description><link>kt에이블/빅프/카프카-기본설정.html</link><guid isPermaLink="false">kt에이블/빅프/카프카  기본설정.md</guid><pubDate>Tue, 12 Aug 2025 05:13:44 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[카프카  기본설정-1754975621685]]></title><description><![CDATA[<img src="kt에이블/빅프/assets/카프카-기본설정-1754975621685.png" target="_self">]]></description><link>kt에이블/빅프/assets/카프카-기본설정-1754975621685.html</link><guid isPermaLink="false">kt에이블/빅프/assets/카프카  기본설정-1754975621685.png</guid><pubDate>Tue, 12 Aug 2025 05:13:41 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Untitled]]></title><link>cloud/untitled.html</link><guid isPermaLink="false">cloud/Untitled.md</guid><pubDate>Tue, 12 Aug 2025 05:13:11 GMT</pubDate></item><item><title><![CDATA[nodejs nginx vite tomcat]]></title><description><![CDATA[ Nginx가 들어온 요청을 Node.js 서버로 전달(프록시)하는 구조이지,
Nginx가 Node.js 위에서 돌아가는 것은 아닙니다 따라서 nginx는 독립적으로 실행 가능함 정적 파일 서비스에는nginx으로만으로도 충분함 정적 웹사이트: Nginx만으로 충분히 서버를 띄우고 서비스할 수 있습니다. 동적 웹사이트: Nginx는 프록시 또는 로드밸런서 역할을 하고, 실제 동적 처리는 별도의 백엔드 서버가 담당합니다. 프론트엔드 개발 서버: 개발 중에 빠른 HMR(Hot Module Replacement)과 모듈 제공을 위해 Node.js 기반의 개발 서버를 띄웁니다.
번들러: 프로덕션(배포) 시에는 소스 코드를 최적화된 정적 파일로 번들링합니다.
Node.js 필요: Vite 자체는 Node.js 환경에서 실행되므로, Vite를 사용하려면 시스템에 Node.js가 설치되어 있어야 합니다<a data-tooltip-position="top" aria-label="https://josephine10.hashnode.dev/difference-between-vite-nodejs-and-solidjs" rel="noopener nofollow" class="external-link is-unresolved" href="https://josephine10.hashnode.dev/difference-between-vite-nodejs-and-solidjs" target="_self">2</a><a data-tooltip-position="top" aria-label="https://vite.dev/guide/features" rel="noopener nofollow" class="external-link is-unresolved" href="https://vite.dev/guide/features" target="_self">4</a>.
<br>Vite는 개발 서버를 내장하고 있으며, 개발 중에 소스 파일을 브라우저에 바로 제공하고, 코드 변경 시 실시간으로 반영하는(HMR) 기능을 제공합니다<a data-tooltip-position="top" aria-label="https://ko.vite.dev/guide/" rel="noopener nofollow" class="external-link is-unresolved" href="https://ko.vite.dev/guide/" target="_self">1</a><a data-tooltip-position="top" aria-label="https://bo5mi.tistory.com/265" rel="noopener nofollow" class="external-link is-unresolved" href="https://bo5mi.tistory.com/265" target="_self">2</a><a data-tooltip-position="top" aria-label="https://1ilsang.dev/posts/vite-dev-server" rel="noopener nofollow" class="external-link is-unresolved" href="https://1ilsang.dev/posts/vite-dev-server" target="_self">3</a><a data-tooltip-position="top" aria-label="https://velog.io/@joeyoungmin/vite" rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@joeyoungmin/vite" target="_self">4</a><a data-tooltip-position="top" aria-label="https://js-web.tistory.com/29" rel="noopener nofollow" class="external-link is-unresolved" href="https://js-web.tistory.com/29" target="_self">5</a><a data-tooltip-position="top" aria-label="https://blog.naver.com/eirene100999/223529479819?recommendTrackingCode=2" rel="noopener nofollow" class="external-link is-unresolved" href="https://blog.naver.com/eirene100999/223529479819?recommendTrackingCode=2" target="_self">8</a><a data-tooltip-position="top" aria-label="https://blog.hectodata.co.kr/bonjour-vite/" rel="noopener nofollow" class="external-link is-unresolved" href="https://blog.hectodata.co.kr/bonjour-vite/" target="_self">9</a>. <br>공식 문서와 여러 자료에서 Vite의 주요 기능으로&nbsp;"개발 서버" 제공을 명확히 언급하고 있습니다. "Vite(프랑스어로 '빠르다')는 빠르고 간결한 모던 웹 프로젝트 개발 경험에 초점을 맞춰 탄생한 빌드 툴입니다. 크게 두 가지 부분으로 구성되어 있습니다: 네이티브 ES 모듈을 통해 소스 파일을 제공하는 개발서버...<a data-tooltip-position="top" aria-label="https://ko.vite.dev/guide/" rel="noopener nofollow" class="external-link is-unresolved" href="https://ko.vite.dev/guide/" target="_self">1</a> <br>Vite를 실행하면 Node.js 기반의 HTTP 서버가 실제로 뜨고, 이 서버가 개발 중에 클라이언트(브라우저)와 통신합니다<a data-tooltip-position="top" aria-label="https://1ilsang.dev/posts/vite-dev-server" rel="noopener nofollow" class="external-link is-unresolved" href="https://1ilsang.dev/posts/vite-dev-server" target="_self">3</a><a data-tooltip-position="top" aria-label="https://js-web.tistory.com/29" rel="noopener nofollow" class="external-link is-unresolved" href="https://js-web.tistory.com/29" target="_self">5</a><a data-tooltip-position="top" aria-label="https://blog.naver.com/eirene100999/223529479819?recommendTrackingCode=2" rel="noopener nofollow" class="external-link is-unresolved" href="https://blog.naver.com/eirene100999/223529479819?recommendTrackingCode=2" target="_self">8</a><a data-tooltip-position="top" aria-label="https://blog.hectodata.co.kr/bonjour-vite/" rel="noopener nofollow" class="external-link is-unresolved" href="https://blog.hectodata.co.kr/bonjour-vite/" target="_self">9</a>. Tomcat은 자바 기반 웹 애플리케이션을 실행하는&nbsp;서블릿 컨테이너(Java Servlet Container)입니다.
주로&nbsp;Java Servlet과 JSP(JavaServer Pages)를 실행하며, Java로 작성된 동적 웹 애플리케이션을 구동합니다.
Tomcat은 HTTP 요청을 받아 Java 코드를 실행하고, 그 결과를 웹 브라우저에 응답합니다.
<br>즉, Tomcat은&nbsp;동적 웹 컨텐츠(예: 로그인, 데이터베이스 연동 등) 처리가 주 목적입니다<a data-tooltip-position="top" aria-label="https://www.logicmonitor.com/blog/what-is-apache-tomcat-server-and-how-does-it-work" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.logicmonitor.com/blog/what-is-apache-tomcat-server-and-how-does-it-work" target="_self">1</a><a data-tooltip-position="top" aria-label="https://www.simplilearn.com/what-is-tomcat-article" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.simplilearn.com/what-is-tomcat-article" target="_self">5</a>.
<br>WAS 내부에서&nbsp;서블릿과 JSP의 생명주기 관리, 요청/응답 처리, 보안, 스레드 관리 등을 담당하는 핵심 컴포넌트입니다<a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Web_container" rel="noopener nofollow" class="external-link is-unresolved" href="https://en.wikipedia.org/wiki/Web_container" target="_self">2</a><a data-tooltip-position="top" aria-label="https://velog.io/@mooh2jj/WAS%EB%8A%94-%EC%84%9C%EB%B8%94%EB%A6%BF-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%ED%8C%8C%ED%97%A4%EC%B9%98%EA%B8%B0" rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@mooh2jj/WAS%EB%8A%94-%EC%84%9C%EB%B8%94%EB%A6%BF-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%ED%8C%8C%ED%97%A4%EC%B9%98%EA%B8%B0" target="_self">3</a><a data-tooltip-position="top" aria-label="https://bny9164.tistory.com/56" rel="noopener nofollow" class="external-link is-unresolved" href="https://bny9164.tistory.com/56" target="_self">4</a><a data-tooltip-position="top" aria-label="https://m42-orion.tistory.com/157" rel="noopener nofollow" class="external-link is-unresolved" href="https://m42-orion.tistory.com/157" target="_self">5</a>. 즉,&nbsp;Java Servlet/JSP 등 웹 컴포넌트의 실행 환경을 제공하는 부분입니다.
WAS는 서블릿 컨테이너를 반드시 포함하고 있습니다.
]]></description><link>web/nodejs-nginx-vite-tomcat.html</link><guid isPermaLink="false">web/nodejs nginx vite tomcat.md</guid><pubDate>Tue, 12 Aug 2025 03:44:45 GMT</pubDate></item><item><title><![CDATA[성과분석계획]]></title><description><![CDATA[ 기본 로그인 &amp; 계정 연동 플랫폼 자체 회원가입/로그인(JWT 등)
YouTube 계정 OAuth2 연동 (다계정 허용)
access_token, refresh_token, expires_at 저장 데이터 수집 YouTube Data API v3, YouTube Analytics API를 이용해 영상·채널 메트릭 조회
스케줄러(@Scheduled)로 매일 자정 자동 실행
토큰 만료 시 refresh token을 사용해 자동 갱신 성과 분석 &amp; AI 연동 수집 데이터 기반으로 AI 서버에 감성 분석, 트렌드 분석, 최적 게시 시간 분석 요청
분석 결과 DB 저장 및 리포트 생성 관리 &amp; 조회 성과 지표, 리포트 이력 조회 다운로드 기능 (CSV/Excel) 필수 API YouTube Data API v3 /videos?part=statistics /channels?part=statistics /commentThreads?part=snippet YouTube Analytics API /reports?metrics=views,likes,comments,... Spring Boot 구현 포인트 Google API Java Client Library 또는 RestTemplate/WebClient로 REST 호출 OAuth2 인증 처리 토큰 만료 시 자동 refresh 로직 구현 textuser ├─ id, email, password, ... youtube_account ├─ id, user_id(FK), channel_id, access_token, refresh_token, expires_at video ├─ id, youtube_account_id(FK), video_id, title, description, published_at video_metric ├─ id, video_id(FK), date, view_count, like_count, comment_count analysis_result ├─ id, video_id(FK), type, period, score, summary report ├─ id, youtube_account_id(FK), period, file_path, created_at관계:textuser 1 ─ N youtube_account 1 ─ N video 1 ─ N video_metric │ └─ N analysis_result
Spring Scheduler java @Scheduled(cron = "0 0 0 * * *") // 매일 자정 public void collectYouTubeMetrics() { ... } 작업 흐름: 모든 연동 계정 조회
토큰 만료 확인 → refresh token으로 갱신
API 호출로 최신 영상/조회수/좋아요/댓글 갱신
video_metric 테이블 업데이트
필요 시 AI 분석 요청 및 결과 저장 사용자 로그인 → 계정 연동(OAuth2)
스케줄러 또는 사용자 요청 시 API 호출 → YouTube API에서 데이터 수집
AI 서버 분석 요청 → 감정 분석, 인사이트, 추천 결과
분석/리포트 DB 저장
프론트엔드 대시보드/리포트 제공 및 다운로드
💡 이렇게 구성하면
데이터 수집(A), 분석(B), 관리(C) 구조가 명확하게 구분 YouTube API 활용, OAuth2 토큰 관리, AI 서버 연동, DB 설계, 스케줄링까지 포함된 완전한 Spring Boot 기반 아키텍처 완성 원하시면 제가 이걸 아키텍처 다이어그램까지 그려서 시각적으로 정리해 드릴 수도 있어요.
그렇게 해드릴까요? 그러면 백엔드-DB-AI 서버 흐름이 한눈에 보입니다.]]></description><link>kt에이블/빅프/성과분석계획.html</link><guid isPermaLink="false">kt에이블/빅프/성과분석계획.md</guid><pubDate>Mon, 11 Aug 2025 02:37:07 GMT</pubDate></item><item><title><![CDATA[agentica]]></title><description><![CDATA[ 핵심 영향 요소들:
@example - 매우 중요 ⭐⭐⭐
LLM이 함수를 이해하고 올바른 파라미터를 전달하는데 도움
Agentica는 이 예시들을 보고 함수 사용법을 학습
실제 사용 사례를 제공해서 더 정확한 함수 선택 가능
@param - 중요 ⭐⭐
파라미터 설명이 LLM의 이해도를 높임
타입 정보와 함께 설명이 있으면 더 정확한 호출 가능
@returns - 중요 ⭐⭐
반환값 설명으로 LLM이 결과를 예측 가능
함수 선택 시 기대 결과를 고려할 수 있음
@minimum, @maximum - 유효성 검증 ⭐⭐⭐
Agentica가 자동으로 파라미터 유효성 검증
잘못된 값 입력 시 자동으로 피드백 제공111111유저 요청 → ReportsService → ReportsFunctionProvider →
MiraeAssetScraperService (다운로드) →
PerplexityPdfConverterService (MD변환) →
요약 생성 → 유저 응답아! 유저 플로우를 이해했습니다. 현재 구조를 이 플로우에 맞게 수정해야겠네요.
유저 요청: "최근 주식시장 정보 알려줘" / "증권보고서 달라"
내부 처리: 보고서 다운로드 → PDF → MD 변환 → 요약
유저 응답: 요약본 + MD 파일 제공
타입 에러를 수정하겠습니다:이제 두 번째 메서드의 타입 에러도 수정하겠습니다:// 유저 요청
const result = await reportsService.getRecentStockMarketInfo({ limit: 3
}); // 응답
{ message: "최근 주식시장 정보를 3개의 보고서에서 수집했습니다.", summary: "총 3개의 보고서를 수집했습니다.\n\n주식시장: 3개", reports: [ { title: "2024년 주식시장 전망", date: "2024-01-15", author: "김분석", markdownContent: "# 주식시장 전망...", markdownFileName: "stock_market_2024.md", summary: "## 주요 포인트\n- 상승 전망\n- 기술주 강세", success: true } ]
}
// 유저 요청
const result = await reportsService.getSecuritiesReports({ limit: 5
}); // 응답
{ message: "증권보고서 5개를 수집했습니다.", summary: "총 5개의 보고서를 수집했습니다.\n\n실적분석: 2개, 시장분석: 2개, 주식분석: 1개", reports: [ { title: "삼성전자 실적 분석", category: "실적분석", summary: "## 주요 실적\n- 매출 증가\n- 영업이익 개선", markdownContent: "# 삼성전자 실적...", markdownFileName: "samsung_earnings.md" } ]
} 자동 다운로드: 보고서 자동 검색 및 다운로드
MD 변환: PDF → Markdown 변환
요약 생성: 각 보고서별 요약 생성
카테고리 분류: 보고서 유형별 분류
전체 요약: 전체 보고서 요약 제공
유저 요청 → ReportsService → ReportsFunctionProvider → MiraeAssetScraperService (다운로드) → PerplexityPdfConverterService (MD변환) → 요약 생성 → 유저 응답
이제 유저가 "최근 주식시장 정보 알려줘" 또는 "증권보고서 달라"라고 요청하면 자동으로 보고서를 다운로드하고 MD로 변환한 후 요약해서 제공합니다! 🎯222222222
네! /reports 폴더의 Provider/Service 구조를 기반으로 /controllers 폴더를 다시 만들어보겠습니다.먼저 현재 controllers 구조를 확인하고, reports 패턴을 다른 controllers에도 적용하겠습니다.Ran tool
Ran tool
Ran tool
Read file: server/src/controllers/chat/ChatController.ts
Read file: server/src/controllers/bbs/BbsArticlesController.ts
이제 reports 패턴을 기반으로 다른 controllers를 재구성하겠습니다. 먼저 chat controller를 reports 패턴에 맞게 수정하겠습니다:ChatService가 없으니 생성하겠습니다:이제 ChatModule을 업데이트하겠습니다:이제 BBS controller를 reports 패턴에 맞게 수정하겠습니다. 먼저 BBS Service를 생성하겠습니다:BbsArticleProvider가 없으니 생성하겠습니다:IPage 인터페이스를 확인해서 올바른 구조로 수정하겠습니다:Read file: server/src/api/structures/common/IPage.ts
이제 올바른 IPage 구조로 수정하겠습니다:이제 BbsService의 오류도 수정하겠습니다:Read file: server/src/providers/bbs/BbsService.ts
이제 BbsArticlesController를 Service 기반으로 수정하겠습니다:이제 BbsArticleModule을 업데이트하겠습니다:
ChatController - WebSocket 연결 관리, Agentica 서비스 제공
ChatService - 채팅 기능 Service (JSDoc 포함)
ChatModule - 모듈 설정 BbsArticlesController - 게시글 API 엔드포인트
BbsService - 게시글 기능 Service (JSDoc 포함)
BbsArticleProvider - 게시글 기능 Provider (내부 로직)
BbsArticleModule - 모듈 설정 ReportsController - 보고서 API 엔드포인트
ReportsService - 보고서 기능 Service (JSDoc 포함)
ReportsFunctionProvider - 보고서 기능 Provider (내부 로직)
MiraeAssetScraperProvider - 스크래핑 Provider
PerplexityPdfConverterProvider - PDF 변환 Provider
ReportsModule - 모듈 설정
Controllers → Services → Providers Chat 관련: ChatController.ts - Service 기반으로 변경
ChatService.ts - 새로 생성
ChatModule.ts - Service 등록 BBS 관련: BbsArticlesController.ts - Service 기반으로 변경
BbsService.ts - 새로 생성
BbsArticleProvider.ts - 새로 생성
BbsArticleModule.ts - Service/Provider 등록 Reports 관련 (기존): 모든 파일이 이미 올바른 구조로 설정됨 Controller: REST API 엔드포인트 제공
Service: AI 호출용, JSDoc 포함, Provider만 참조
Provider: 내부 로직, JSDoc 없음, 다른 Provider 참조 가능
이제 모든 Controllers가 reports 패턴을 따르는 일관된 구조를 가지게 되었습니다! 🎯]]></description><link>kt에이블/agentica.html</link><guid isPermaLink="false">kt에이블/agentica.md</guid><pubDate>Wed, 06 Aug 2025 16:40:21 GMT</pubDate></item><item><title><![CDATA[어뎁터와서비스]]></title><description><![CDATA[어댑터와 서비스의 차이를 명확하게 정리해줄게!@Component
public class OAuthAdapter implements OAuthPort { // 1. 외부 시스템(Spring Security OAuth2)을 도메인 모델로 변환 public OAuthUserInfo convertFromSpringOAuth2User(OAuth2User oauth2User, OAuthProvider provider) { // Spring Security OAuth2User → 도메인 OAuthUserInfo 변환 Map&lt;String, Object&gt; attributes = oauth2User.getAttributes(); String name = oauth2User.getName(); return switch (provider) { case KAKAO -&gt; convertFromKakaoAttributes(attributes, name); case GOOGLE -&gt; convertFromGoogleAttributes(attributes, name); }; } // 2. 도메인 포트 구현 (도메인 로직 처리) @Override public User processOAuthUser(OAuthUserInfo oauthUserInfo) { // 기존 사용자 조회 또는 새 사용자 생성 Optional&lt;User&gt; existingUser = userRepositoryPort.findByProviderAndProviderId( oauthUserInfo.getProvider(), oauthUserInfo.getProviderId()); if (existingUser.isPresent()) { return existingUser.get(); } else { return createNewOAuthUser(oauthUserInfo); } }
} 변환 역할: 외부 형식 ↔ 도메인 형식
구체적 구현: 실제 외부 시스템과 연동
도메인 포트 구현: 도메인이 정의한 인터페이스 구현
외부 의존성 처리: Spring Security, HTTP 클라이언트 등
@Service
public class OAuthService implements OAuthUseCase { private final OAuthAdapter oAuthAdapter; private final JwtUtils jwtUtils; private final RefreshTokenRepositoryPort refreshTokenRepositoryPort; @Override public AuthResponse oauthLogin(OAuth2User oauth2User, OAuthProvider provider) { // 1. 어댑터를 통한 변환 var oauthUserInfo = oAuthAdapter.convertFromSpringOAuth2User(oauth2User, provider); // 2. 도메인 로직 처리 User user = oAuthAdapter.processOAuthUser(oauthUserInfo); // 3. JWT 토큰 생성 (비즈니스 로직) AuthResponse authResponse = generateAuthResponse(user.getId()); return authResponse; } @Override public void oauthLogout(String accessToken, String refreshToken) { // 1. JWT 토큰 블랙리스트 처리 io.jsonwebtoken.Claims claims = jwtUtils.parseClaimsAllowExpired(accessToken); blacklistIfNotExpired(claims); // 2. Refresh 토큰 삭제 refreshTokenRepositoryPort.delete(refreshToken); }
} 조율 역할: 여러 컴포넌트를 조합해서 전체 플로우 관리
비즈니스 로직: JWT 토큰 생성, 로그아웃 처리 등
트랜잭션 관리: @Transactional 등
에러 처리: 비즈니스 예외 처리
OAuth 로그인 요청 ↓
OAuthService.oauthLogin() ↓
1. OAuthAdapter.convertFromSpringOAuth2User() ← 변환 ↓
2. OAuthAdapter.processOAuthUser() ← 도메인 로직 ↓
3. OAuthService.generateAuthResponse() ← 비즈니스 로직 ↓
JWT 토큰 응답 어댑터: 번역기 (외국어 ↔ 한국어)
서비스: 여행 가이드 (전체 여행 계획 및 관리)
어댑터는 외부 시스템의 데이터를 도메인이 이해할 수 있는 형태로 변환하고, 서비스는 여러 어댑터와 도메인 로직을 조합해서 전체 비즈니스 플로우를 관리해!]]></description><link>kt에이블/빅프/어뎁터와서비스.html</link><guid isPermaLink="false">kt에이블/빅프/어뎁터와서비스.md</guid><pubDate>Fri, 01 Aug 2025 18:23:56 GMT</pubDate></item><item><title><![CDATA[authentication(핸들러에잇는)]]></title><description><![CDATA[authentication
├── principal (OAuth2User)
│ ├── attributes (Map&lt;String, Object&gt;)
│ │ ├── email
│ │ ├── name
│ │ └── picture
│ └── name (String)
└── credentials (OAuth2AccessToken)
├── accessToken
├── refreshToken
└── tokenTypeOAuth 로그인 요청
↓
OAuthService.oauthLogin()
↓
OAuthAdapter.convertFromSpringOAuth2User() ← 변환
↓
OAuthAdapter.processOAuthUser() ← 도메인 로직
↓
OAuthService.generateAuthResponse() ← 비즈니스 로직
↓
JWT 토큰 응답
]]></description><link>kt에이블/빅프/authentication(핸들러에잇는).html</link><guid isPermaLink="false">kt에이블/빅프/authentication(핸들러에잇는).md</guid><pubDate>Fri, 01 Aug 2025 18:22:36 GMT</pubDate></item><item><title><![CDATA[cicd]]></title><description><![CDATA[<img alt="cicd-1753945873829.png" src="kt에이블/빅프/assets/cicd-1753945873829.png" target="_self">]]></description><link>kt에이블/빅프/cicd.html</link><guid isPermaLink="false">kt에이블/빅프/cicd.md</guid><pubDate>Thu, 31 Jul 2025 07:11:15 GMT</pubDate><enclosure url="kt에이블/빅프/assets/cicd-1753945873829.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="kt에이블/빅프/assets/cicd-1753945873829.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[webflux mvc]]></title><description><![CDATA[ auth-service: JPA&nbsp;+ 전통적인 Spring MVC (동기) gateway: WebFlux + 리액티브 스트림&nbsp;(비동기) 다른점]]></description><link>kt에이블/빅프/webflux-mvc.html</link><guid isPermaLink="false">kt에이블/빅프/webflux mvc.md</guid><pubDate>Tue, 29 Jul 2025 15:25:58 GMT</pubDate></item><item><title><![CDATA[usememousecallback]]></title><description><![CDATA[내기억으로 useCallback애는
useCallback과 useMemo의 차이점과 각각의 이득을 자세히 설명해드릴게요!<a rel="noopener nofollow" class="external-link is-unresolved" href="https://opendeveloper.tistory.com/entry/React-useCallback-%EC%82%AC%EC%9A%A9%EB%B2%95-%EC%A0%95%EB%A6%AC" target="_self">https://opendeveloper.tistory.com/entry/React-useCallback-%EC%82%AC%EC%9A%A9%EB%B2%95-%EC%A0%95%EB%A6%AC</a>const expensiveValue = useMemo(() =&gt; { return heavyCalculation(a, b, c)
}, [a, b, c])
const expensiveFunction = useCallback(() =&gt; { return heavyCalculation(a, b, c)
}, [a, b, c])
const UserProfile = ({ user }) =&gt; { // 복잡한 계산 결과를 메모이제이션 const userStats = useMemo(() =&gt; { return { totalPosts: user.posts.length, averageLikes: user.posts.reduce((sum, post) =&gt; sum + post.likes, 0) / user.posts.length, engagementRate: calculateEngagement(user.posts) } }, [user.posts]) return &lt;div&gt;{userStats.totalPosts}&lt;/div&gt;
}
const UserProfile = ({ user, onUserUpdate }) =&gt; { // 함수를 메모이제이션 const handleUserUpdate = useCallback((newData) =&gt; { onUserUpdate({ ...user, ...newData }) }, [user, onUserUpdate]) return &lt;button onClick={handleUserUpdate}&gt;Update&lt;/button&gt;
} 복잡한 계산 비용 절약
// ❌ 매 렌더링마다 계산
const expensiveValue = heavyCalculation(data) // ✅ 의존성이 변경될 때만 계산
const expensiveValue = useMemo(() =&gt; { return heavyCalculation(data)
}, [data]) 객체/배열 참조 안정화
// ❌ 매번 새로운 객체 생성
const config = { theme: 'dark', language: 'ko' } // ✅ 같은 참조 유지
const config = useMemo(() =&gt; ({ theme: 'dark', language: 'ko'
}), []) 자식 컴포넌트 리렌더링 방지
// ❌ 매번 새로운 함수 생성
const handleClick = () =&gt; console.log('clicked') // ✅ 같은 함수 참조 유지
const handleClick = useCallback(() =&gt; { console.log('clicked')
}, []) // 자식 컴포넌트가 React.memo로 최적화되어 있다면
// 함수 참조가 같으면 리렌더링 안함 useEffect 의존성 안정화
// ❌ 매번 새로운 함수로 useEffect 재실행
const fetchData = () =&gt; { /* ... */ }
useEffect(() =&gt; { fetchData()
}, [fetchData]) // fetchData가 매번 새로 생성되어 useEffect 계속 실행 // ✅ 함수 참조가 안정화되어 useEffect 한 번만 실행
const fetchData = useCallback(() =&gt; { /* ... */ }, [])
useEffect(() =&gt; { fetchData()
}, [fetchData])
// useMemo가 적합
const expensiveResult = useMemo(() =&gt; { return data.filter(item =&gt; item.active) .map(item =&gt; transform(item)) .reduce((acc, item) =&gt; acc + item.value, 0)
}, [data])
// useCallback이 적합
const handleSubmit = useCallback((formData) =&gt; { submitToAPI(formData)
}, [])
// useCallback이 적합 (useEffect 의존성 때문)
const fetchUserData = useCallback(async () =&gt; { const response = await api.getUser(userId) setUserData(response.data)
}, [userId]) useEffect(() =&gt; { fetchUserData()
}, [fetchUserData]) // fetchUserData 참조가 안정화되어야 함
// ❌ 단순한 계산은 오히려 성능 저하
const fullName = useMemo(() =&gt; { return firstName + ' ' + lastName
}, [firstName, lastName]) // ✅ 그냥 계산하는 게 나음
const fullName = firstName + ' ' + lastName
// ❌ 단순한 함수는 오히려 성능 저하
const handleClick = useCallback(() =&gt; { console.log('clicked')
}, []) // ✅ 그냥 함수 선언하는 게 나음
const handleClick = () =&gt; console.log('clicked')
// ✅ useCallback이 적합한 이유:
const handleOAuthCallback = useCallback(() =&gt; { // ... OAuth 처리 로직
}, [dispatch, location.search, isAuthenticated]) // useEffect의 의존성 배열에 포함되어 있어서
// 함수 참조가 안정화되어야 불필요한 재실행 방지
useEffect(() =&gt; { if (hasOAuthParams) { handleOAuthCallback() }
}, [hasOAuthParams, handleOAuthCallback])
핵심:
useMemo: 값을 메모이제이션 (복잡한 계산, 객체 참조)
useCallback: 함수를 메모이제이션 (이벤트 핸들러, useEffect 의존성)
]]></description><link>kt에이블/빅프/usememousecallback.html</link><guid isPermaLink="false">kt에이블/빅프/usememousecallback.md</guid><pubDate>Tue, 29 Jul 2025 06:04:11 GMT</pubDate></item><item><title><![CDATA[프론트 useauth개선]]></title><description><![CDATA[import { useEffect, useState } from 'react'
import { useDispatch } from 'react-redux'
import { useLocation } from 'react-router-dom'
import { authApi } from '../api/auth'
import { login, logout, updateToken } from '../store/authSlice' export const useAuth = () =&gt; { const dispatch = useDispatch() const [isLoading, setIsLoading] = useState(true) const location = useLocation() const checkLogin = async () =&gt; { const refreshToken = localStorage.getItem('refreshToken') if (!refreshToken) { setIsLoading(false) return } try { const response = await authApi.refresh(refreshToken) console.log(response) if (response.data?.result?.accessToken) { dispatch(updateToken({ accessToken: response.data.result.accessToken })) } else { dispatch(logout()) } } catch (error) { // 리프레시 실패는 일반적인 상황일 수 있으므로 콘솔 에러는 출력하지 않음 } finally { setIsLoading(false) } } const handleOAuthCallback = () =&gt; { const urlParams = new URLSearchParams(location.search) console.log(urlParams) const accessToken = urlParams.get('accessToken') const refreshToken = urlParams.get('refreshToken') const error = urlParams.get('error') if (error) { console.error('OAuth 인증 실패:', error) return } console.log(accessToken, refreshToken) if (accessToken &amp;&amp; refreshToken) { // OAuth 토큰으로 로그인 처리 dispatch(login({ accessToken, refreshToken })) // URL에서 토큰 파라미터 제거 const newUrl = window.location.pathname window.history.replaceState({}, document.title, newUrl) } } useEffect(() =&gt; { checkLogin() handleOAuthCallback() }, []) return { isLoading }
} import { useCallback, useEffect, useMemo, useState } from 'react'
import { useDispatch } from 'react-redux'
import { useLocation } from 'react-router-dom'
import { authApi } from '../api/auth'
import { login, logout, updateToken } from '../store/authSlice' export const useAuth = () =&gt; { const dispatch = useDispatch() const [isLoading, setIsLoading] = useState(true) const location = useLocation() const checkLogin = useCallback(async () =&gt; { const refreshToken = localStorage.getItem('refreshToken') if (!refreshToken) { setIsLoading(false) return } try { const response = await authApi.refresh(refreshToken) if (response.data?.result?.accessToken) { dispatch(updateToken({ accessToken: response.data.result.accessToken })) } else { dispatch(logout()) } } catch (error) { // 리프레시 실패는 일반적인 상황일 수 있으므로 콘솔 에러는 출력하지 않음 dispatch(logout()) } finally { setIsLoading(false) } }, [dispatch]) const handleOAuthCallback = useCallback(() =&gt; { const urlParams = new URLSearchParams(location.search) const accessToken = urlParams.get('accessToken') const refreshToken = urlParams.get('refreshToken') const error = urlParams.get('error') if (error) { console.error('OAuth 인증 실패:', error) return } if (accessToken &amp;&amp; refreshToken) { dispatch(login({ accessToken, refreshToken })) // URL에서 토큰 파라미터 제거 const newUrl = window.location.pathname window.history.replaceState({}, document.title, newUrl) } }, [dispatch, location.search]) // URL 파라미터가 있을 때만 OAuth 콜백 처리 const hasOAuthParams = useMemo(() =&gt; { const urlParams = new URLSearchParams(location.search) return urlParams.get('accessToken') &amp;&amp; urlParams.get('refreshToken') }, [location.search]) useEffect(() =&gt; { checkLogin() }, [checkLogin]) useEffect(() =&gt; { if (hasOAuthParams) { handleOAuthCallback() } }, [hasOAuthParams, handleOAuthCallback]) return { isLoading }
} useMemo와 useCallback을 사용한 자세한 이유를 설명해드릴게요:const checkLogin = useCallback(async () =&gt; { // ... 함수 내용
}, [dispatch])
이유:
dispatch는 Redux에서 제공하는 안정적인 참조 (변경되지 않음)
하지만 useCallback 없이 매번 렌더링마다 새로운 함수가 생성됨
useEffect의 의존성 배열에 checkLogin을 넣었기 때문에, 함수가 변경되면 useEffect가 불필요하게 재실행됨
useCallback으로 함수를 메모이제이션하면 dispatch가 변경되지 않는 한 같은 함수 참조 유지
const handleOAuthCallback = useCallback(() =&gt; { // ... 함수 내용
}, [dispatch, location.search])
이유:
location.search가 변경될 때만 함수가 재생성되어야 함
useEffect의 의존성 배열에 포함되어 있어서, 함수 참조가 변경되면 불필요한 재실행 방지
URL 파라미터가 실제로 변경될 때만 OAuth 처리가 실행됨
const hasOAuthParams = useMemo(() =&gt; { const urlParams = new URLSearchParams(location.search) return urlParams.get('accessToken') &amp;&amp; urlParams.get('refreshToken')
}, [location.search])
이유:
location.search가 변경되지 않는 한 같은 결과값 유지
useEffect에서 조건부 실행을 위해 사용
매번 렌더링마다 URLSearchParams 객체를 생성하고 파싱하는 비용 절약
불필요한 계산 방지
// 매 렌더링마다 새로운 함수 생성
const checkLogin = async () =&gt; { ... } useEffect(() =&gt; { checkLogin() // 함수 참조가 매번 달라져서 useEffect가 계속 재실행됨
}, [checkLogin]) // checkLogin이 매번 새로운 함수라서 의존성이 계속 변경됨
// dispatch가 변경되지 않는 한 같은 함수 참조 유지
const checkLogin = useCallback(async () =&gt; { ... }, [dispatch]) useEffect(() =&gt; { checkLogin() // dispatch가 변경되지 않는 한 useEffect가 재실행되지 않음
}, [checkLogin]) 컴포넌트 리렌더링 시: 부모 컴포넌트가 리렌더링되어도 함수들이 불필요하게 재생성되지 않음 의존성 체인: useEffect → checkLogin → authApi.refresh() 호출이 불필요하게 반복되지 않음 메모리 효율성: 함수 객체가 매번 새로 생성되지 않아 가비지 컬렉션 부담 감소 예측 가능한 동작: 의존성이 명확하게 정의되어 언제 함수가 재생성되는지 예측 가능 단순한 계산이나 객체 생성
자주 변경되는 값에 의존하는 경우
성능에 민감하지 않은 컴포넌트
의존성 배열이 복잡해지는 경우
이 경우에는 인증 로직이 앱의 핵심 기능이고, 불필요한 API 호출을 방지하는 것이 중요하기 때문에 useCallback과 useMemo를 사용한 것이 적절해요.]]></description><link>kt에이블/프론트-useauth개선.html</link><guid isPermaLink="false">kt에이블/프론트 useauth개선.md</guid><pubDate>Tue, 29 Jul 2025 05:48:06 GMT</pubDate></item><item><title><![CDATA[spring2 oauth자동로그인]]></title><description><![CDATA[장점:
✅ 보안성 높음 - Spring Security가 모든 보안 검증 처리
✅ 표준 방식 - Spring Boot 공식 권장 방식
✅ 자동 세션 관리 - 로그인 상태 자동 관리
✅ CSRF 보호 - 자동 CSRF 토큰 처리
✅ 에러 핸들링 - OAuth 에러 자동 처리
✅ 확장성 - 다른 OAuth 제공자 추가 쉬움
단점:
❌ 복잡한 설정 - SecurityConfig 복잡해짐
❌ 커스터마이징 제한 - Spring Security 프레임워크 제약
❌ JWT 토큰 처리 복잡 - 세션 기반에서 JWT로 전환 시 추가 작업
장점:
✅ 완전한 제어 - 모든 로직 직접 구현 가능
✅ JWT 친화적 - JWT 토큰 발급/관리 쉬움
✅ 단순한 구조 - 컨트롤러에서 직접 처리
✅ 커스터마이징 자유 - 원하는 대로 리다이렉트/응답 처리
단점:
❌ 보안 위험 - 수동으로 보안 검증해야 함
❌ 표준 아님 - Spring Security 표준 방식 아님
❌ 에러 처리 복잡 - OAuth 에러 직접 처리
❌ 유지보수 부담 - OAuth 관련 모든 로직 직접 관리
이유:
보안이 최우선 - OAuth는 보안이 핵심
현재 JWT 기반이라면 JWT + OAuth 조합도 가능
장기적 유지보수 관점에서 표준 방식이 유리
다른 OAuth 제공자 (GitHub, Facebook 등) 추가 시 쉬움
현재 상황에서는 Spring Security OAuth2로 전환하는 것이 더 좋습니다.
기존: 수동 OAuth 처리 (OAuth2Service)
현재: Spring Security OAuth2 자동 로그인 (CustomOAuth2UserService) 기존: /api/auth/oauth2/google, /api/auth/oauth2/callback 엔드포인트
현재: /oauth2/authorization/google (Spring Security 자동 처리) Spring Security의 표준 OAuth2 처리 사용
자동 CSRF 보호, 에러 핸들링
보안 검증 자동화 3단계 사용자 처리 로직은 동일하게 유지
JWT + RefreshToken 발급 방식도 동일 새로운 플로우 다이어그램
Spring Security OAuth2 설정 방법
사용 방법 및 테스트 방법 추가
이제 Spring Security OAuth2 자동 로그인을 사용하면서도 JWT 토큰을 발급받는 안전하고 표준적인 OAuth 구현이 완료되었습니다!]]></description><link>kt에이블/빅프/spring2-oauth자동로그인.html</link><guid isPermaLink="false">kt에이블/빅프/spring2 oauth자동로그인.md</guid><pubDate>Mon, 28 Jul 2025 18:32:51 GMT</pubDate></item><item><title><![CDATA[securityconfig]]></title><description><![CDATA[@Bean public SecurityFilterChain filterChain(HttpSecurity http, CustomOAuth2UserService customOAuth2UserService) throws Exception { http .csrf(csrf -&gt; csrf.disable()) .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) .authorizeHttpRequests(authz -&gt; authz .requestMatchers(EXCLUDE_PATHS.toArray(new String[0])).permitAll() .anyRequest().authenticated() ) .oauth2Login(oauth2 -&gt; oauth2 .userInfoEndpoint(userInfo -&gt; userInfo .userService(customOAuth2UserService) ) .successHandler((request, response, authentication) -&gt; { try { customOAuth2UserService.handleOAuth2Success(request, response, authentication); } catch (Exception e) { throw new RuntimeException(e); } }) .failureHandler((request, response, exception) -&gt; { // OAuth2 로그인 실패 시 처리 response.sendRedirect("http://localhost:3000/auth/error?message=" + java.net.URLEncoder.encode(exception.getMessage(), java.nio.charset.StandardCharsets.UTF_8)); }) ); return http.build(); } 사용자가 /oauth2/authorization/google 접근
↓
Google 로그인 페이지로 리다이렉트
↓
사용자가 Google에서 로그인
↓
Google이 /login/oauth2/code/google로 코드 전송
↓
CustomOAuth2UserService.loadUser() 실행
↓
사용자 정보 DB 저장/조회
↓
successHandler 실행
↓
JWT 토큰 생성 및 프론트엔드로 리다이렉트
]]></description><link>kt에이블/빅프/securityconfig.html</link><guid isPermaLink="false">kt에이블/빅프/securityconfig.md</guid><pubDate>Mon, 28 Jul 2025 18:03:54 GMT</pubDate></item><item><title><![CDATA[필터에 반영전후]]></title><link>kt에이블/빅프/필터에-반영전후.html</link><guid isPermaLink="false">kt에이블/빅프/필터에 반영전후.md</guid><pubDate>Mon, 28 Jul 2025 16:49:01 GMT</pubDate></item><item><title><![CDATA[제안]]></title><description><![CDATA[동료의 말이 맞는지, 그리고 현재 구현 상태를 확인해보겠습니다!Search files...
Read file: common/src/main/java/kt/aivle/common/jwt/JwtUtils.java
Read file: auth-service/src/main/java/kt/aivle/auth/application/service/OAuth2Service.java동료가 말한 내용이 완벽하게 구현되어 있어요! ��
"auth-service 부분에서 oauth 개발하시고 소셜로그인 인증되면 common 모듈에서 jwt, auth-service 모듈에서 refreshToken 발급 받으시면 될 것 같아요"
// OAuth2Service.java - OAuth2 인증 처리
@Transactional
public AuthResponse processOAuth2Callback(String code) { // 1. Authorization Code를 Access Token으로 교환 String accessToken = oAuth2Port.exchangeCodeForToken(code); // 2. Access Token으로 사용자 정보 조회 GoogleUserInfo userInfo = oAuth2Port.getUserInfo(accessToken); // 3. 사용자 처리 및 JWT 발급 return processOAuth2User("google", userInfo.getSub(), userInfo.getEmail(), userInfo.getName());
}
// OAuth2Service.java에서 common 모듈의 JwtUtils 사용
private AuthResponse generateAuthResponse(Long userId) { // common 모듈의 JwtUtils 사용 ⭐ JwtDto jwt = jwtUtils.generateAccessToken(userId, user.getEmail()); // auth-service 모듈에서 refreshToken 발급 ⭐ String refreshToken = UUID.randomUUID().toString(); refreshTokenRepositoryPort.save(userId, refreshToken, REFRESH_TOKEN_EXPIRE_MS); return AuthResponse.builder() .type("Bearer") .accessToken(jwt.accessToken()) // common 모듈에서 JWT .refreshToken(refreshToken) // auth-service 모듈에서 refreshToken .build();
}
// RefreshTokenRedisRepository.java - Redis에 저장
@Override
public void save(Long userId, String refreshToken, long expiresInMillis) { String key = PREFIX + refreshToken; redisTemplate.opsForValue().set(key, String.valueOf(userId), expiresInMillis, TimeUnit.MILLISECONDS);
}
📦 common 모듈
├── JwtUtils.java # JWT 토큰 생성/검증
├── JwtProperties.java # JWT 설정
└── JwtDto.java # JWT 데이터 전송 객체 �� auth-service 모듈 ├── OAuth2Service.java # OAuth2 인증 처리
├── RefreshTokenRedisRepository.java # RefreshToken 저장/관리
└── AuthController.java # OAuth2 엔드포인트
1. 사용자 OAuth2 로그인 ↓
2. auth-service에서 OAuth2 인증 처리 ↓
3. common 모듈의 JwtUtils로 JWT 발급 ↓
4. auth-service 모듈에서 RefreshToken 발급 ↓
5. 두 토큰 모두 클라이언트에 반환 common 모듈: JWT 관련 공통 기능
auth-service 모듈: OAuth2 + RefreshToken 관리 JWT는 다른 서비스에서도 사용 가능
RefreshToken은 auth-service에서만 관리 JWT와 RefreshToken 분리로 보안 강화
Redis를 통한 RefreshToken 관리 다른 OAuth2 제공자 추가 시에도 동일한 구조 사용 가능
동료의 제안이 정확하고, 이미 완벽하게 구현되어 있습니다!
✅ OAuth2 개발: auth-service에서 완료
✅ JWT 발급: common 모듈에서 완료 ✅ RefreshToken 발급: auth-service 모듈에서 완료
✅ 모듈 분리: 책임이 명확하게 분리됨
✅ 아키텍처: Hexagonal Architecture 원칙 준수
현재 구현이 동료의 제안과 정확히 일치하고, 아키텍처적으로도 매우 잘 설계되어 있어요! 🚀]]></description><link>kt에이블/빅프/제안.html</link><guid isPermaLink="false">kt에이블/빅프/제안.md</guid><pubDate>Mon, 28 Jul 2025 16:06:21 GMT</pubDate></item><item><title><![CDATA[로그]]></title><description><![CDATA[ERROR (가장 높음)↓WARN↓INFO↓DEBUG↓TRACE (가장 낮음)]]></description><link>kt에이블/빅프/로그.html</link><guid isPermaLink="false">kt에이블/빅프/로그.md</guid><pubDate>Mon, 28 Jul 2025 14:57:17 GMT</pubDate></item><item><title><![CDATA[principal패턴]]></title><description><![CDATA[좋은 질문이에요! Principal 패턴에 대해 자세히 설명해드릴게요.// Principal = "주체" 또는 "주인공"
// → 인증된 사용자(로그인한 사람)를 나타내는 객체
// Spring Security는 인증된 사용자를 Principal로 관리
Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
Object principal = authentication.getPrincipal(); // 인증된 사용자 정보
// Spring Security의 기본 Principal 타입들
UserDetails principal; // 일반 로그인 사용자
OAuth2User principal; // OAuth2 로그인 사용자
String principal; // 간단한 사용자명
// 일반 로그인 시
User user = userRepository.findByEmail("user@example.com");
UserDetails userDetails = new UserDetails(user); // Principal // OAuth2 로그인 시 User user = userRepository.findByProviderAndProviderId("google", "123");
OAuth2UserPrincipal principal = new OAuth2UserPrincipal(user, attributes, nameKey); // Principal
// Spring Security는 다양한 인증 방식을 Principal로 통일
public interface Authentication { Object getPrincipal(); // 인증된 사용자 (Principal) Object getCredentials(); // 인증 정보 (비밀번호, 토큰 등) Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); // 권한
}
// 1. 일반 로그인
UserDetails principal = authentication.getPrincipal(); // 2. OAuth2 로그인 OAuth2User principal = authentication.getPrincipal(); // 3. JWT 토큰
String principal = authentication.getPrincipal(); // 사용자 ID // 4. 커스텀 Principal
OAuth2UserPrincipal principal = authentication.getPrincipal();
// 어떤 인증 방식을 사용하든 동일한 방식으로 사용자 정보 접근
Authentication auth = SecurityContextHolder.getContext().getAuthentication();
Object principal = auth.getPrincipal(); if (principal instanceof OAuth2UserPrincipal) { OAuth2UserPrincipal oauthPrincipal = (OAuth2UserPrincipal) principal; User user = oauthPrincipal.getUser(); String email = oauthPrincipal.getEmail();
}
// 새로운 인증 방식 추가 시에도 Principal 패턴 사용
public class KakaoOAuth2UserPrincipal implements OAuth2User { private final User user; // ... 구현
} public class NaverOAuth2UserPrincipal implements OAuth2User { private final User user; // ... 구현
}
// 테스트에서 Principal 모킹이 쉬움
@Test
public void testWithOAuth2Principal() { User testUser = new User("google", "123", "test@example.com", "Test User"); OAuth2UserPrincipal principal = new OAuth2UserPrincipal(testUser, attributes, "sub"); // Principal을 사용한 테스트
}
@GetMapping("/profile")
public ResponseEntity&lt;UserProfile&gt; getProfile(@AuthenticationPrincipal OAuth2UserPrincipal principal) { User user = principal.getUser(); return ResponseEntity.ok(new UserProfile(user));
}
@Service
public class UserService { public User getCurrentUser() { Authentication auth = SecurityContextHolder.getContext().getAuthentication(); OAuth2UserPrincipal principal = (OAuth2UserPrincipal) auth.getPrincipal(); return principal.getUser(); }
}
@Component
public class CustomFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) { Authentication auth = SecurityContextHolder.getContext().getAuthentication(); if (auth != null &amp;&amp; auth.getPrincipal() instanceof OAuth2UserPrincipal) { OAuth2UserPrincipal principal = (OAuth2UserPrincipal) auth.getPrincipal(); User user = principal.getUser(); // 사용자별 로직 처리 } chain.doFilter(request, response); }
}
// 도메인 계층
User user = userRepository.findById(1L); // 인증 계층 (Spring Security)
OAuth2UserPrincipal principal = new OAuth2UserPrincipal(user, attributes, nameKey); // 프레젠테이션 계층
@GetMapping("/api/user")
public ResponseEntity&lt;UserDto&gt; getUser(@AuthenticationPrincipal OAuth2UserPrincipal principal) { User user = principal.getUser(); // 도메인 객체 접근 return ResponseEntity.ok(UserDto.from(user));
}
// 도메인 모델 (User)은 Spring Security에 의존하지 않음
public class User { // Spring Security 관련 코드 없음
} // Principal이 도메인 모델을 래핑해서 Spring Security와 연결
public class OAuth2UserPrincipal implements OAuth2User { private final User user; // 도메인 모델 의존
}
Principal 패턴은:
인증된 사용자를 나타내는 객체
Spring Security의 표준 패턴
다양한 인증 방식을 통일된 방식으로 처리 일관성: 모든 인증 방식에서 동일한 접근
확장성: 새로운 인증 방식 추가 용이
테스트 용이성: Principal 모킹으로 테스트 간편
아키텍처 분리: 도메인과 인증 계층 분리 OAuth2UserPrincipal: OAuth2 인증된 사용자의 주체 정보
User: 도메인 모델 (비즈니스 로직)
Principal 패턴: 두 계층을 연결하는 어댑터 역할
이것이 Principal 패턴의 핵심이에요! 🚀]]></description><link>kt에이블/빅프/principal패턴.html</link><guid isPermaLink="false">kt에이블/빅프/principal패턴.md</guid><pubDate>Mon, 28 Jul 2025 14:46:00 GMT</pubDate></item><item><title><![CDATA[Adapter vs Port의 차이점]]></title><description><![CDATA[
정의: 인터페이스 (추상화된 계약)
역할: 애플리케이션이 외부와 어떻게 소통할지 정의
위치: application.port.in / application.port.out 정의: 구현체 (실제 구현)
역할: Port 인터페이스를 실제 외부 시스템으로 변환
위치: adapter.in / adapter.out
// application.port.in.AuthUseCase
public interface AuthUseCase { AuthResponse signUp(SignUpCommand command); AuthResponse login(LoginCommand command); AuthResponse refresh(TokenCommand command); void logout(TokenCommand command);
}
// adapter.in.web.AuthController
@RestController
public class AuthController { private final AuthUseCase authUseCase; // IN Port 사용 @PostMapping("/login") public ResponseEntity&lt;ApiResponse&lt;AuthResponse&gt;&gt; login(@RequestBody LoginRequest request) { LoginCommand command = request.toCommand(); AuthResponse response = authUseCase.login(command); // IN Port 호출 return responseUtils.build(OK, response); }
}
// application.port.out.UserRepositoryPort
public interface UserRepositoryPort { User save(User user); Optional&lt;User&gt; findByEmail(String email); Optional&lt;User&gt; findByProviderAndProviderId(String provider, String providerId);
}
// adapter.out.persistence.UserPersistenceAdapter
@Component
public class UserPersistenceAdapter implements UserRepositoryPort { private final JpaUserRepository userRepository; // 실제 JPA 구현체 @Override public User save(User user) { return userRepository.save(user); // MySQL에 실제 저장 } @Override public Optional&lt;User&gt; findByEmail(String email) { return userRepository.findByEmail(email); // MySQL에서 실제 조회 }
}
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│ IN Adapter │───▶│ IN Port │───▶│ Application │
│ (Controller) │ │ (UseCase) │ │ Service │
└─────────────────┘ └─────────────────┘ └─────────────────┘ │
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│ OUT Adapter │◀───│ OUT Port │◀───│ Application │
│ (Repository) │ │ (Repository) │ │ Service │
└─────────────────┘ └─────────────────┘ └─────────────────┘
1. Client → AuthController (IN Adapter) ↓
2. AuthController → AuthUseCase (IN Port) ↓
3. AuthService (Application) → UserRepositoryPort (OUT Port) ↓
4. UserRepositoryPort → UserPersistenceAdapter (OUT Adapter) ↓
5. UserPersistenceAdapter → MySQL Database 애플리케이션이 외부 시스템에 의존하지 않음
Port 인터페이스에만 의존
// 테스트 시 Mock 객체 사용 가능
@MockBean
private UserRepositoryPort userRepositoryPort; // Port 인터페이스 Mock @Test
void login_성공() { when(userRepositoryPort.findByEmail("test@test.com")) .thenReturn(Optional.of(user)); // 실제 DB 없이도 테스트 가능
} MySQL → MongoDB로 변경 시: Adapter만 수정
REST API → GraphQL로 변경 시: IN Adapter만 수정
애플리케이션 로직은 전혀 변경 안됨 Port: "무엇을 할지" 정의 (인터페이스)
Adapter: "어떻게 할지" 구현 (구현체)
이렇게 분리하면 외부 시스템이 바뀌어도 핵심 비즈니스 로직은 그대로 유지할 수 있어요!AuthController → OAuth2Service → OAuth2Port (인터페이스)
↓
GoogleOAuth2Adapter (구현체)
↓
외부 Google API]]></description><link>kt에이블/빅프/adapter-vs-port의-차이점.html</link><guid isPermaLink="false">kt에이블/빅프/Adapter vs Port의 차이점.md</guid><pubDate>Mon, 28 Jul 2025 14:39:06 GMT</pubDate></item><item><title><![CDATA[config 파일]]></title><description><![CDATA[좋은 질문이에요! config 패키지가 정확히 뭘 하는지, 그리고 왜 필요한지 자세히 설명해드릴게요.Read file: auth-service/src/main/java/kt/aivle/auth/config/SecurityConfig.java
Read file: auth-service/src/main/java/kt/aivle/auth/config/OAuth2Config.java
Read file: auth-service/src/main/java/kt/aivle/auth/config/OAuth2Properties.java
Read file: auth-service/src/main/java/kt/aivle/auth/config/CustomOAuth2UserService.java
이제 config 패키지가 정확히 뭘 하는지, 그리고 왜 필요한지 자세히 설명해드릴게요!Spring Framework가 어떤 객체를 어떻게 만들어서 관리할지를 정의하는 곳이에요.@Configuration // "이 클래스는 설정 클래스야!"
public class SecurityConfig { @Bean // "이 메서드가 만드는 객체를 Spring이 관리해줘!" public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); // 비밀번호 암호화 도구 }
}
application.yml의 설정값을 Java 객체로 변환해주는 역할이에요.# application.yml
spring: security: oauth2: client: registration: google: client-id: "your-google-client-id" client-secret: "your-google-client-secret"
// OAuth2Properties.java
@ConfigurationProperties(prefix = "spring.security.oauth2.client")
public class OAuth2Properties { private Map&lt;String, Registration&gt; registration; // yml의 값이 여기로 바인딩됨 public Registration getGoogle() { return registration.get("google"); // google 설정값 반환 }
}
Spring은 "의존성 주입(DI)"을 사용해서 객체들을 관리해요.// 이렇게 하면 안 됨 (Spring이 모르는 객체)
@Service
public class AuthService { private PasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); // ❌
} // 이렇게 해야 함 (Spring이 관리하는 객체)
@Service
public class AuthService { private final PasswordEncoder passwordEncoder; // Spring이 주입해줌 ✅ public AuthService(PasswordEncoder passwordEncoder) { this.passwordEncoder = passwordEncoder; }
}
// Config 없이 직접 사용하려면
@Service
public class AuthService { private PasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); private OAuth2UserService oAuth2UserService = new CustomOAuth2UserService(); // 매번 new로 객체 생성 → 메모리 낭비, 테스트 어려움
}
// Config에서 Bean 정의
@Configuration
public class SecurityConfig { @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); }
} // Spring이 자동으로 주입
@Service
public class AuthService { private final PasswordEncoder passwordEncoder; // Spring이 자동 주입 public AuthService(PasswordEncoder passwordEncoder) { this.passwordEncoder = passwordEncoder; }
}
@Configuration
public class SecurityConfig { @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); // 비밀번호 암호화 도구 }
}
역할: 보안 관련 객체들을 Spring Bean으로 등록@Configuration
@EnableConfigurationProperties(OAuth2Properties.class)
public class OAuth2Config { @Bean public OAuth2UserService&lt;OAuth2UserRequest, OAuth2User&gt; oAuth2UserService( CustomOAuth2UserService customOAuth2UserService) { return customOAuth2UserService; // OAuth2 사용자 서비스를 Bean으로 등록 }
}
역할: OAuth2 관련 설정과 Bean 등록@ConfigurationProperties(prefix = "spring.security.oauth2.client")
public class OAuth2Properties { private Map&lt;String, Registration&gt; registration; // yml 설정값 바인딩
}
역할: application.yml의 OAuth2 설정값을 Java 객체로 변환@Service // 이건 실제로는 service 패키지에 있어야 함!
public class CustomOAuth2UserService extends DefaultOAuth2UserService { // OAuth2 로그인 처리 로직
}
역할: OAuth2 로그인 시 사용자 정보 처리 (실제로는 service 패키지에 있어야 함)<a data-tooltip-position="top" aria-label="https://github.com/TalhaRizwan093/Springboot-Security-Starter-OAuth-JWT/blob/master/Backend/src/main/java/com/spring/OAuthSecurity/config/SecurityConfig.java" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/TalhaRizwan093/Springboot-Security-Starter-OAuth-JWT/blob/master/Backend/src/main/java/com/spring/OAuthSecurity/config/SecurityConfig.java" target="_self">참고한 GitHub 예시</a>를 보면:@Configuration
@EnableWebSecurity
public class SecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { // Spring Security 설정 return http.build(); } @Bean public OAuth2UserService&lt;OAuth2UserRequest, OAuth2User&gt; oAuth2UserService() { return new CustomOAuth2UserService(); // 직접 생성 }
}
차이점:
GitHub 예시: SecurityConfig에서 모든 보안 설정을 한 곳에서 관리
우리 프로젝트: OAuth2 관련 설정을 별도 클래스로 분리 (더 깔끔함)
Config 패키지는 Spring Framework가 "어떤 객체를 어떻게 만들어서 관리할지"를 정의하는 곳이에요.
Bean 등록: Spring이 관리할 객체들을 정의
설정 바인딩: 외부 설정값을 Java 객체로 변환
의존성 주입: 다른 클래스들이 필요한 객체들을 자동으로 주입받을 수 있게 함
이렇게 하면 메모리 효율성, 테스트 용이성, 유지보수성이 크게 향상돼요!]]></description><link>kt에이블/빅프/config-파일.html</link><guid isPermaLink="false">kt에이블/빅프/config 파일.md</guid><pubDate>Mon, 28 Jul 2025 14:25:41 GMT</pubDate></item><item><title><![CDATA[내가구현flow]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.devyummi.com/page?id=669365e370d4f58bd7cbed16" target="_self">https://www.devyummi.com/page?id=669365e370d4f58bd7cbed16</a>
Authorization Code Flow
graph TD
A[프론트엔드] --&gt; B[GET /api/auth/oauth2/google]
B --&gt; C[Google OAuth URL 반환]
C --&gt; D[사용자 Google 로그인]
D --&gt; E[GET /api/auth/oauth2/callback?code=xxx]
E --&gt; F[OAuth2Service.processOAuth2User]
F --&gt; G[사용자 조회/생성]
G --&gt; H[common.JwtUtils로 JWT 생성]
H --&gt; I[auth-service에서 refreshToken 생성]
I --&gt; J[프론트엔드로 토큰과 함께 리다이렉트]
<br><img alt="내가구현flow-1753685474352.png" src="kt에이블/빅프/assets/내가구현flow-1753685474352.png" target="_self"> Implicit Flow
graph TD
A[프론트엔드] --&gt; B[Google OAuth URL 생성]
B —&gt; C[사용자 Google 로그인]
C —&gt; D[Google이 프론트엔드로 access_token 직접 반환]
D —&gt; E[프론트엔드가 access_token으로 사용자 정보 조회]
E —&gt; F[백엔드에 사용자 정보 + access_token 전달]
F —&gt; G[백엔드에서 JWT 발급]<br>
<img alt="내가구현flow-1753685663910.png" src="kt에이블/빅프/assets/내가구현flow-1753685663910.png" target="_self"> <br>
&nbsp;Authorization Code Flow with PKCE&nbsp;(SPA용, 권장) <img alt="내가구현flow-1753685778274.png" src="kt에이블/빅프/assets/내가구현flow-1753685778274.png" target="_self">
|구분|일반 Authorization Code|PKCE&nbsp;적용|
|---|---|---|
|Client&nbsp;Secret|필요&nbsp;(서버에 저장)|불필요|
|보안성|🟡 중간&nbsp;(code 탈취 위험)|🟢&nbsp;높음 (code 탈취해도 무용)|
|적용 환경|서버 사이드 앱|SPA, 모바일&nbsp;앱|
|구현 복잡도|🟢 간단|🟡&nbsp;약간 복잡| ]]></description><link>kt에이블/빅프/내가구현flow.html</link><guid isPermaLink="false">kt에이블/빅프/내가구현flow.md</guid><pubDate>Mon, 28 Jul 2025 06:59:00 GMT</pubDate><enclosure url="kt에이블/빅프/assets/내가구현flow-1753685474352.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="kt에이블/빅프/assets/내가구현flow-1753685474352.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[빅프백]]></title><description><![CDATA[watch -n 2 './check-services.sh'당연히 가능해! DataGrip은 MySQL 서버 전체에 연결되니까 모든 DB를 다 볼 수 있어.
설정할 때:
Database 필드를 비워두거나 또는
아무 DB나 하나 지정해도 (예: userstore)
연결 후에는:
🗂️ 모든 데이터베이스가 다 보임
userstore (우리가 만든 DB)
mysql (시스템 DB)
information_schema (메타데이터)
performance_schema (성능 정보)
sys (시스템 뷰)
확인 방법:
DataGrip 좌측 Database Explorer에서
연결한 MySQL 서버 확장하면
📁 schemas 또는 databases 폴더 아래
모든 DB 목록이 트리 구조로 나타남
만약 하나만 보인다면:
연결 설정에서 "Show all schemas" 옵션 체크
또는 Advanced 탭에서 스키마 필터 확인
즉, localhost:3306에 있는 MySQL 서버의 모든 데이터베이스를 다 탐색 가능해! 🎯
현재 몇 개 DB가 보여?]]></description><link>kt에이블/빅프/빅프백.html</link><guid isPermaLink="false">kt에이블/빅프/빅프백.md</guid><pubDate>Mon, 28 Jul 2025 05:02:42 GMT</pubDate></item><item><title><![CDATA[oauth 주요 로직]]></title><description><![CDATA[OAuth2의 4가지 인증 플로우(Grant Types)에 대해 각 방식별로 구조, 특징, 시나리오를 차례로 자세히 설명합니다.
흐름: 사용자가 클라이언트(웹앱/서버)에서 로그인을 요청 → 인증 서버가 사용자 인증(로그인 화면 제공) → 인증이 성공하면 일회성 '인가 코드(authorization code)'를 클라이언트에 리디렉션 URL로 전달 → 클라이언트는 이 코드를 인증 서버에 보내 실제 '액세스 토큰(access token)'을 발급받음 장점: 토큰이 브라우저에 노출되지 않고, 서버-서버 통신을 통해 토큰 발급이 이루어져 가장 안전한 방식입니다. 주 용도: 전통적인 웹 애플리케이션, 서버 기반 클라이언트, 모바일 앱 등 추가: PKCE(Proof Key for Code Exchange)와 결합해 보안을 강화할 수 있습니다. 흐름: 사용자가 로그인 요청 → 인증 서버가 사용자 인증 → 인증이 성공하면 인가 코드 없이 곧바로 '액세스 토큰'을 브라우저(리디렉션 URL 해시)에 노출 장점: 서버를 거치지 않고 클라이언트(브라우저)에서 즉시 토큰을 획득 가능. 백엔드가 없는 SPA(Single Page Application) 또는 자바스크립트 앱 등에서 사용이 가능했습니다. 단점: 토큰이 브라우저 주소창에 노출되고, 서버 검증 단계가 없어서 보안에 취약. 현재는 권장되지 않음 (OAuth2.1에선 제거 예정) 주 용도: 과거 SPA, JavaScript 단독 실행 앱(백엔드 서버 부재) 흐름: 사용자가 자신의 아이디/비밀번호를 클라이언트(앱 등)에 직접 입력 → 해당 정보로 인증 서버에 바로 요청해 '액세스 토큰' 발급 장점: 구현이 간편하고, 별도의 브라우저 리디렉션 없이 인증 가능 단점: 사용자의 비밀번호를 애플리케이션이 알아야 하므로 보안상 매우 위험, 권장되지 않음 (내부, 신뢰할 수 있는 앱에서만 사용) 주 용도: 신뢰할 수 있는 1st-party 클라이언트(예: 기업 내부 시스템, 자신이 직접 운영하는 앱 등) 흐름: 클라이언트(앱이나 서버 등)가 자신의 client_id/client_secret(애플리케이션 고유 정보)로 인증 서버에 토큰을 요청 → 곧바로 '액세스 토큰' 발급(사용자 인증 단계 없음) 장점: 사용자 개입 없이 시스템 간 백엔드-to-백엔드 통신 등에 적합 주 용도: 기계 간(서버-서버) API 호출, 마이크로서비스 아키텍처 내 서비스 간 인증, 백엔드 작업 자동화 이 4가지 플로우는 각기 보안 수준, 사용 목적, 구현 난이도 등이 다르므로, 서비스 성격에 맞게 올바른 방식을 선정하는 것이 중요합니다.]]></description><link>kt에이블/빅프/oauth-주요-로직.html</link><guid isPermaLink="false">kt에이블/빅프/oauth 주요 로직.md</guid><pubDate>Mon, 28 Jul 2025 05:02:18 GMT</pubDate></item><item><title><![CDATA[시ㄹ행과정]]></title><description><![CDATA[docker-compose up -d
여러 컨테이너를 각각의 이미지로 만들고,
한 번의 명령으로 모두 실행 및 관리할 수 있다는 뜻이 맞습니다.
docker-compose stop
정지
authidentity/src/main/java/aivle/
├── domain/ # 도메인 계층
│ ├── entity/ # 엔티티
│ ├── repository/ # 리포지토리
│ ├── command/ # 커맨드
│ ├── event/ # 이벤트
│ └── valueobject/ # 값 객체
└── infra/ # 인프라 계층 ├── controller/ # 컨트롤러 ├── processor/ # 프로세서 ├── event/ # 이벤트 └── policy/ # 정
docker exec kafka kafka-console-consumer --bootstrap-server localhost:9092 --topic aivle --from-beginningkafka-topics.sh --delete --zookeeper zookeeper:2181 --topic aivledocker exec kafka kafka-topics --bootstrap-server localhost:9092 --delete --topic aivledocker exec kafka kafka-topics --create --bootstrap-server localhost:9092 --topic aivle --partitions 1 --replication-factor 1카프카컨테이너에 들어가기
도커아이디확인
docker ps
docker exec -it 40cb1c7184b2 /bin/bash
kafka라는 이름의 Docker 컨테이너 안에서, kafka-console-consumer 명령을 실행하여 localhost:9092에 있는 Kafka 클러스터의 aivle 토픽에 저장된 메시지를 처음부터 모두 읽어서 출력하라.
cd infra
docker-compose up -d
각 서비스별로 개별 실행하거나, 전체를 한번에 실행:개별 실행:# 각 서비스 디렉토리에서
cd admintask
mvn spring-boot:run cd ../monthlysubscriptionmanagement mvn spring-boot:run # ... 나머지 서비스들도 동일
전체 한번에 실행:docker-compose -f build-docker-compose.yml up
cd gateway
mvn spring-boot:run
cd frontend
npm install
npm run serve Gateway: 8088
각 마이크로서비스: 8082~8091
Kafka: 9092
프론트엔드: 8080 (기본)
정의된 곳:
README.md - 전체 실행 가이드
infra/docker-compose.yml - Kafka 설정
build-docker-compose.yml - 전체 서비스 Docker 실행 설정
init.sh - 초기 설정 스크립트
가장 간단한 방법은 build-docker-compose.yml로 전체 실행하는 거야.공통 패턴: repository().saveAndFlush(this)&nbsp;- 저장과 동시에 flush 저장된 엔티티를 변수에 할당 (id가 설정된 객체) 저장된 엔티티로 이벤트 생성 이렇게 하면 모든 엔티티에서&nbsp;id가 제대로 설정된 후에 이벤트가 생성되어&nbsp;JSON에 모든 필드가 포함됩니다.flush전에 실행해서<a rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@codren/JPA-save-%EC%99%80-saveAndFlush-%EC%9D%98-%EC%B0%A8%EC%9D%B4" target="_self">https://velog.io/@codren/JPA-save-%EC%99%80-saveAndFlush-%EC%9D%98-%EC%B0%A8%EC%9D%B4</a>애네 pubsub구현을 내가아는 pubsub패턴으로구현하는ㄴ지 찾아봐야겟다이 saveandflush가 디폴트가되어야하지않냐롬복지우고다시실행하면됨ㅋ왜? 실화임??말안되네그냥 X-는&nbsp;비표준 헤더를 나타내는 표준 RFC 6648에서 정의된 관례 표준 HTTP 헤더와 구분하기 위함 보통 Gateway의 config 부분에서는 이런 것들을 설정해:// JWT 설정
@Value("${jwt.secret}")
private String jwtSecret; @Value("${jwt.expiration}")
private Long jwtExpiration; // 보안 경로 설정
@Value("${security.protected-paths}")
private List&lt;String&gt; protectedPaths; // CORS 설정
@Value("${cors.allowed-origins}")
private List&lt;String&gt; allowedOrigins;
// 서비스 디스커버리 설정
@Value("${eureka.client.service-url.defaultZone}")
private String eurekaUrl; // 로드밸런서 설정
@Value("${ribbon.ConnectTimeout}")
private Integer connectTimeout;
// 로그 레벨
@Value("${logging.level.gateway}")
private String logLevel; // 메트릭 설정
@Value("${management.endpoints.web.exposure.include}")
private String metricsEndpoints;
// 타임아웃 설정
@Value("${spring.cloud.gateway.httpclient.connect-timeout}")
private Integer connectTimeout; @Value("${spring.cloud.gateway.httpclient.response-timeout}")
private Integer responseTimeout;
// 필터 순서
@Value("${gateway.filter.order}")
private Integer filterOrder; // 필터 활성화 여부
@Value("${gateway.filter.enabled}")
private Boolean filterEnabled;
// 환경 구분
@Value("${spring.profiles.active}")
private String activeProfile; // 환경별 서비스 URL
@Value("${service.url.${spring.profiles.active}}")
private String serviceUrl;
// SSL/TLS 설정
@Value("${server.ssl.enabled}")
private Boolean sslEnabled; // 헤더 설정
@Value("${gateway.headers.allowed}")
private List&lt;String&gt; allowedHeaders;
// 캐시 설정
@Value("${gateway.cache.enabled}")
private Boolean cacheEnabled; @Value("${gateway.cache.ttl}")
private Integer cacheTtl;
// 레이트 리미터 설정
@Value("${gateway.rate-limit.enabled}")
private Boolean rateLimitEnabled; @Value("${gateway.rate-limit.requests-per-second}")
private Integer requestsPerSecond;
// 서킷브레이커 설정
@Value("${resilience4j.circuitbreaker.enabled}")
private Boolean circuitBreakerEnabled; @Value("${resilience4j.circuitbreaker.failure-rate-threshold}")
private Integer failureRateThreshold;
// 현재 JWT 관련
@Value("${jwt.secret}")
private String jwtSecret; @Value("${security.protected-paths}")
private List&lt;String&gt; protectedPaths; // 추가하면 좋을 것들
@Value("${gateway.timeout.connect:5000}")
private Integer connectTimeout; @Value("${gateway.timeout.read:10000}")
private Integer readTimeout; @Value("${gateway.cors.enabled:true}")
private Boolean corsEnabled; @Value("${gateway.logging.enabled:true}")
private Boolean loggingEnabled;
이런 설정들을 yml 파일에서 관리하면 환경별로 다른 설정을 쉽게 적용할 수 있어!]]></description><link>ktaivle_back/시ㄹ행과정.html</link><guid isPermaLink="false">ktaivle_back/시ㄹ행과정.md</guid><pubDate>Mon, 28 Jul 2025 01:42:56 GMT</pubDate></item><item><title><![CDATA[result]]></title><description><![CDATA[릿지, xgbm
feature , 앙상블기준선택feature : features = ['bid_qty', 'volume', 'buy_qty', 'sell_qty','ask_qty','X598', 'X344','X363', 'X405', 'X321', 'X175', 'X179', 'X197', 'X22', 'X181', 'X28', 'X169', 'X198', 'X173', 'X338', 'X587', 'X450', 'X97', 'X52', 'X444', 'X297', 'X138', 'X572', 'X343', 'X438', 'X459', 'X758', 'X25']전체다 &amp; 평균
R2: 0.5544
RMSE: 0.6757
피어슨 상관계수: 0.8200선택 &amp; 평균
R2: 0.4379
RMSE: 0.7589
피어슨 상관계수: 0.7980전체다 &amp; 평균 &amp; 시간순 split선택 &amp; 평균 &amp; 시간순 split]]></description><link>데이터분석,ai/캐글/result.html</link><guid isPermaLink="false">데이터분석,ai/캐글/result.md</guid><pubDate>Wed, 23 Jul 2025 12:53:47 GMT</pubDate></item><item><title><![CDATA[주식,코인 시계열 데이터 분석에서 Ridge, XGBoost 추천 옵션 및 전략]]></title><description><![CDATA[주식이나 코인 등 시계열(financial time series) 데이터 분석에 Ridge 회귀와 XGBoost, 그리고 이 두 모델의 앙상블을 사용할 때 유용한 옵션과 실전 팁을 정리합니다.
특징 생성 과거 값(lag), 이동평균, 변화율 등 시계열 특성 반영 피처 생성이 중요함. 예: lag_1, lag_7, rolling_mean_5 등 정규화/표준화 Ridge는 가중치 페널티 특성상 표준화(StandardScaler) 필수<a data-tooltip-position="top" aria-label="https://wire.insiderfinance.io/adaptive-time-series-forecasting-with-rolling-ridge-regression-a82f4a718471" rel="noopener nofollow" class="external-link is-unresolved" href="https://wire.insiderfinance.io/adaptive-time-series-forecasting-with-rolling-ridge-regression-a82f4a718471" target="_self">1</a><a data-tooltip-position="top" aria-label="https://abouttrading.substack.com/p/lets-use-ridge-regression-to-predict" rel="noopener nofollow" class="external-link is-unresolved" href="https://abouttrading.substack.com/p/lets-use-ridge-regression-to-predict" target="_self">2</a>. 윈도우 학습(rolling/expanding window) <br>일정 기간의 과거 데이터만으로 반복 학습(rolling window) 권장<a data-tooltip-position="top" aria-label="https://wire.insiderfinance.io/adaptive-time-series-forecasting-with-rolling-ridge-regression-a82f4a718471" rel="noopener nofollow" class="external-link is-unresolved" href="https://wire.insiderfinance.io/adaptive-time-series-forecasting-with-rolling-ridge-regression-a82f4a718471" target="_self">1</a>. 데이터가 시간 흐름에 따라 변화한다면 "online/rolling fitting" 추천. 타깃(종속변수) 분포 주가/코인 수익률(returns)로 예측하는 것이 일반적. 시계열 교차검증 순서 지키는 TimeSeriesSplit 지원. 옵션 예시
alpha(정규화 강도): 옵티마이즈(Tuning) 필요 fit_intercept=True (기본값) solver='auto' 피처 엔지니어링 <br>시계열 데이터를 Supervised Learning 형태(슬라이딩 윈도우, lag, 이동평균 등)로 변환해야 함<a data-tooltip-position="top" aria-label="https://www.machinelearningmastery.com/xgboost-for-time-series-forecasting/" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.machinelearningmastery.com/xgboost-for-time-series-forecasting/" target="_self">3</a><a data-tooltip-position="top" aria-label="https://machinelearningmastery.com/xgboost-for-time-series-forecasting/" rel="noopener nofollow" class="external-link is-unresolved" href="https://machinelearningmastery.com/xgboost-for-time-series-forecasting/" target="_self">4</a><a data-tooltip-position="top" aria-label="https://www.kdnuggets.com/2023/08/leveraging-xgboost-timeseries-forecasting.html" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.kdnuggets.com/2023/08/leveraging-xgboost-timeseries-forecasting.html" target="_self">5</a>. <br>기술적 지표(예: EMA, MACD, RSI 등) 활용 효과적<a data-tooltip-position="top" aria-label="https://arxiv.org/html/2407.11786v1" rel="noopener nofollow" class="external-link is-unresolved" href="https://arxiv.org/html/2407.11786v1" target="_self">6</a>. Objective objective='reg:squarederror' (회귀용, 평균제곱오차 최소화) 시간순서 준수 훈련·검증 데이터 분할시 미래 데이터로 예측하지 않게 순서를 지킬 것 Validation 방식 <br>KFold보다 Walk-Forward Validation(rolling forecast origin) 권장<a data-tooltip-position="top" aria-label="https://machinelearningmastery.com/xgboost-for-time-series-forecasting/" rel="noopener nofollow" class="external-link is-unresolved" href="https://machinelearningmastery.com/xgboost-for-time-series-forecasting/" target="_self">4</a>. 중요 하이퍼파라미터 n_estimators, max_depth, learning_rate, subsample, colsample_bytree, gamma, lambda, alpha 등 과적합 방지 early_stopping_rounds 사용 <br>Regularization(lambda, alpha) 조정<a data-tooltip-position="top" aria-label="https://arxiv.org/html/2407.11786v1" rel="noopener nofollow" class="external-link is-unresolved" href="https://arxiv.org/html/2407.11786v1" target="_self">6</a> Ridge와 XGBoost의 출력 스케일이 다르면 표준화 필요 (Ridge는 표준화된 입력 권장, XGBoost는 중요하지 않지만 맞춰주면 해로울 것 없음) 두 모델 예측값 단순 평균(soft voting) 혹은 가중 평균 동일 특징 파생(같은 피처 엔지니어링 중요) 시간누적 예측 등에서는 첫출력 → 다음 입력 반복 방식(autoregressive)도 고려 <br>Ridge: 경향성(Trend)·선형 특성 추출에 강점<a data-tooltip-position="top" aria-label="https://wire.insiderfinance.io/adaptive-time-series-forecasting-with-rolling-ridge-regression-a82f4a718471" rel="noopener nofollow" class="external-link is-unresolved" href="https://wire.insiderfinance.io/adaptive-time-series-forecasting-with-rolling-ridge-regression-a82f4a718471" target="_self">1</a><a data-tooltip-position="top" aria-label="https://abouttrading.substack.com/p/lets-use-ridge-regression-to-predict" rel="noopener nofollow" class="external-link is-unresolved" href="https://abouttrading.substack.com/p/lets-use-ridge-regression-to-predict" target="_self">2</a> XGBoost: 복잡/비선형 구조·급격한 변동(Spike)에 대응 가능 <br>둘의 앙상블: 장기 트렌드와 단기 변동성을 모두 반영할 수 있어 금융 시계열에 적합<a data-tooltip-position="top" aria-label="https://arxiv.org/html/2506.22055v1" rel="noopener nofollow" class="external-link is-unresolved" href="https://arxiv.org/html/2506.22055v1" target="_self">7</a> <br>검증 방법은 반드시 시간 순서를 지키는 방식(Walk-Forward, Expanding Window) 사용해야 예측 성능이 실제에 가깝게 평가됨<a data-tooltip-position="top" aria-label="https://machinelearningmastery.com/xgboost-for-time-series-forecasting/" rel="noopener nofollow" class="external-link is-unresolved" href="https://machinelearningmastery.com/xgboost-for-time-series-forecasting/" target="_self">4</a>. <br>다양한 기술적 지표 및 외부 요인(뉴스, 거래량 등) 추가 시 성능 향상 가능<a data-tooltip-position="top" aria-label="https://arxiv.org/html/2407.11786v1" rel="noopener nofollow" class="external-link is-unresolved" href="https://arxiv.org/html/2407.11786v1" target="_self">6</a><a data-tooltip-position="top" aria-label="https://dl.acm.org/doi/fullHtml/10.1145/3605423.3605462" rel="noopener nofollow" class="external-link is-unresolved" href="https://dl.acm.org/doi/fullHtml/10.1145/3605423.3605462" target="_self">8</a>. 주가/코인 같이 예측의 난이도가 높은 시계열에서는 feature engineering, 하이퍼파라미터 튜닝, 선형+비선형 모델 앙상블이 모두 중요합니다. <br>XGBoost + LSTM 등 하이브리드 모델, explainable AI 적용 사례도 최근 연구에서 많이 활용되고 있습니다<a data-tooltip-position="top" aria-label="https://arxiv.org/html/2506.22055v1" rel="noopener nofollow" class="external-link is-unresolved" href="https://arxiv.org/html/2506.22055v1" target="_self">7</a>. <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://wire.insiderfinance.io/adaptive-time-series-forecasting-with-rolling-ridge-regression-a82f4a718471" target="_self">https://wire.insiderfinance.io/adaptive-time-series-forecasting-with-rolling-ridge-regression-a82f4a718471</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://abouttrading.substack.com/p/lets-use-ridge-regression-to-predict" target="_self">https://abouttrading.substack.com/p/lets-use-ridge-regression-to-predict</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.machinelearningmastery.com/xgboost-for-time-series-forecasting/" target="_self">https://www.machinelearningmastery.com/xgboost-for-time-series-forecasting/</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://machinelearningmastery.com/xgboost-for-time-series-forecasting/" target="_self">https://machinelearningmastery.com/xgboost-for-time-series-forecasting/</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.kdnuggets.com/2023/08/leveraging-xgboost-timeseries-forecasting.html" target="_self">https://www.kdnuggets.com/2023/08/leveraging-xgboost-timeseries-forecasting.html</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://arxiv.org/html/2407.11786v1" target="_self">https://arxiv.org/html/2407.11786v1</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://arxiv.org/html/2506.22055v1" target="_self">https://arxiv.org/html/2506.22055v1</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://dl.acm.org/doi/fullHtml/10.1145/3605423.3605462" target="_self">https://dl.acm.org/doi/fullHtml/10.1145/3605423.3605462</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://arxiv.org/html/2411.18339v1" target="_self">https://arxiv.org/html/2411.18339v1</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.sciencedirect.com/science/article/pii/S1568494625006544" target="_self">https://www.sciencedirect.com/science/article/pii/S1568494625006544</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/MunjPatel/Adaptive-Time-Series-Forecasting-with-Rolling-Ridge-Regression" target="_self">https://github.com/MunjPatel/Adaptive-Time-Series-Forecasting-with-Rolling-Ridge-Regression</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://elib.bsu.by/bitstream/123456789/306226/1/176-179.pdf" target="_self">https://elib.bsu.by/bitstream/123456789/306226/1/176-179.pdf</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.linkedin.com/posts/sofienkaabar_lets-use-ridge-regression-to-predict-time-activity-7170908443690680320-8ZaC" target="_self">https://www.linkedin.com/posts/sofienkaabar_lets-use-ridge-regression-to-predict-time-activity-7170908443690680320-8ZaC</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.astesj.com/v06/i02/p80/" target="_self">https://www.astesj.com/v06/i02/p80/</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Ridge.html" target="_self">https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Ridge.html</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://cienciadedatos.net/documentos/py56-forecasting-time-series-with-xgboost" target="_self">https://cienciadedatos.net/documentos/py56-forecasting-time-series-with-xgboost</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.ibm.com/think/topics/ridge-regression" target="_self">https://www.ibm.com/think/topics/ridge-regression</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.reddit.com/r/MachineLearning/comments/1aoo7gc/d_how_does_xgboost_work_with_time_series/" target="_self">https://www.reddit.com/r/MachineLearning/comments/1aoo7gc/d_how_does_xgboost_work_with_time_series/</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.mdpi.com/1911-8074/18/2/52" target="_self">https://www.mdpi.com/1911-8074/18/2/52</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://otexts.com/fpp2/regression.html" target="_self">https://otexts.com/fpp2/regression.html</a>
]]></description><link>데이터분석,ai/캐글/주식,코인-시계열-데이터-분석에서-ridge,-xgboost-추천-옵션-및-전략.html</link><guid isPermaLink="false">데이터분석,ai/캐글/주식,코인 시계열 데이터 분석에서 Ridge, XGBoost 추천 옵션 및 전략.md</guid><pubDate>Wed, 23 Jul 2025 12:31:56 GMT</pubDate></item><item><title><![CDATA[Untitled 1]]></title><description><![CDATA[아래 코드는 주어진 X, Y 데이터(넘파이 배열 혹은 판다스 데이터프레임을 가정)에 대해 릿지(Ridge) 회귀와 XGBoost 회귀(XGBRegressor)를 각각 학습시키고, 두 모델의 예측값 평균을 앙상블하여 R2, RMSE, 피어슨 상관계수를 출력하는 가장 기본적인 예제입니다.pythonimport numpy as np from sklearn.linear_model import Ridge from xgboost import XGBRegressor from sklearn.metrics import r2_score, mean_squared_error from scipy.stats import pearsonr # X, Y 데이터 준비 (여기에 실제 데이터 입력) np.random.seed(42) X = np.random.rand(100, 5) Y = np.random.rand(100) # 모델 정의 및 학습 ridge = Ridge() xgb = XGBRegressor(objective='reg:squarederror', random_state=42) ridge.fit(X, Y) xgb.fit(X, Y) # 예측 ridge_pred = ridge.predict(X) xgb_pred = xgb.predict(X) # 앙상블(평균) ensemble_pred = (ridge_pred + xgb_pred) / 2 # 성능 평가 r2 = r2_score(Y, ensemble_pred) rmse = mean_squared_error(Y, ensemble_pred) ** 0.5 pearson_corr, _ = pearsonr(Y, ensemble_pred) print(f'R2: {r2:.4f}') print(f'RMSE: {rmse:.4f}') print(f'피어슨 상관계수: {pearson_corr:.4f}')
실제 캐글 대회에서는 train/test 분할, 교차검증 등도 반드시 진행하세요. XGBoost 설치가 필요할 수 있습니다: pip install xgboost Ridge, XGBoost에 대한 앙상블과 대표적 평가지표 활용법은 여러 캐글 및 블로그, 공식 문서에서 확인할 수 있습니다<a data-tooltip-position="top" aria-label="https://www.kaggle.com/code/bashkeel/eda-to-ensemble-model-lasso-ridge-xgboost" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.kaggle.com/code/bashkeel/eda-to-ensemble-model-lasso-ridge-xgboost" target="_self">1</a><a data-tooltip-position="top" aria-label="https://velog.io/@kupulau/Regression-model-%EC%BD%94%EB%93%9C" rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@kupulau/Regression-model-%EC%BD%94%EB%93%9C" target="_self">2</a>. <br>성능 개선을 원한다면 그리드 서치, 스태킹 등 다양한 앙상블 기법도 활용해보세요<a data-tooltip-position="top" aria-label="https://www.kaggle.com/code/bashkeel/eda-to-ensemble-model-lasso-ridge-xgboost" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.kaggle.com/code/bashkeel/eda-to-ensemble-model-lasso-ridge-xgboost" target="_self">1</a><a data-tooltip-position="top" aria-label="https://www.kaggle.com/code/abhishek1aa/stacking-ensemble-roberta-xgboost-ridge" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.kaggle.com/code/abhishek1aa/stacking-ensemble-roberta-xgboost-ridge" target="_self">3</a>. 이 코드는 앙상블과 성능 평가의 가장 기본적인 골격을 보여줍니다. 데이터셋 특성에 따라 하이퍼파라미터 튜닝, 교차검증, 예측값 후처리 등을 추가해 실전에 맞게 최적화해주세요.
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.kaggle.com/code/bashkeel/eda-to-ensemble-model-lasso-ridge-xgboost" target="_self">https://www.kaggle.com/code/bashkeel/eda-to-ensemble-model-lasso-ridge-xgboost</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@kupulau/Regression-model-%EC%BD%94%EB%93%9C" target="_self">https://velog.io/@kupulau/Regression-model-%EC%BD%94%EB%93%9C</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.kaggle.com/code/abhishek1aa/stacking-ensemble-roberta-xgboost-ridge" target="_self">https://www.kaggle.com/code/abhishek1aa/stacking-ensemble-roberta-xgboost-ridge</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://riverzayden.tistory.com/17" target="_self">https://riverzayden.tistory.com/17</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://scikit-learn.org/stable/modules/ensemble.html" target="_self">https://scikit-learn.org/stable/modules/ensemble.html</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.kaggle.com/code/theintegratedguy/ensemble-regression" target="_self">https://www.kaggle.com/code/theintegratedguy/ensemble-regression</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://blog.csdn.net/weixin_39889597/article/details/110776483" target="_self">https://blog.csdn.net/weixin_39889597/article/details/110776483</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://xgboosting.com/xgboost-stable-predictions-via-ensemble-of-final-models/" target="_self">https://xgboosting.com/xgboost-stable-predictions-via-ensemble-of-final-models/</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.machinelearningmastery.com/xgboost-for-regression/" target="_self">https://www.machinelearningmastery.com/xgboost-for-regression/</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://stackoverflow.com/questions/20115272/calculate-coefficient-of-determination-r2-and-root-mean-square-error-rmse-fo/20115859" target="_self">https://stackoverflow.com/questions/20115272/calculate-coefficient-of-determination-r2-and-root-mean-square-error-rmse-fo/20115859</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://jaylala.tistory.com/entry/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D-with-Python-%EC%95%99%EC%83%81%EB%B8%94Ensemble-%ED%95%99%EC%8A%B5-4-XGBoost" target="_self">https://jaylala.tistory.com/entry/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D-with-Python-%EC%95%99%EC%83%81%EB%B8%94Ensemble-%ED%95%99%EC%8A%B5-4-XGBoost</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.geeksforgeeks.org/machine-learning/ensemble-methods-in-python/" target="_self">https://www.geeksforgeeks.org/machine-learning/ensemble-methods-in-python/</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.datatechnotes.com/2019/10/accuracy-check-in-python-mae-mse-rmse-r.html" target="_self">https://www.datatechnotes.com/2019/10/accuracy-check-in-python-mae-mse-rmse-r.html</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.youtube.com/watch?v=ujKt3JdI2B8" target="_self">https://www.youtube.com/watch?v=ujKt3JdI2B8</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.datacamp.com/tutorial/rmse" target="_self">https://www.datacamp.com/tutorial/rmse</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.mdpi.com/2079-8954/12/7/254" target="_self">https://www.mdpi.com/2079-8954/12/7/254</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://tyami.github.io/machine%20learning/ensemble-6-boosting-XGBoost-regression/" target="_self">https://tyami.github.io/machine%20learning/ensemble-6-boosting-XGBoost-regression/</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://stackoverflow.com/questions/893657/how-do-i-calculate-r-squared-using-python-and-numpy" target="_self">https://stackoverflow.com/questions/893657/how-do-i-calculate-r-squared-using-python-and-numpy</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.sciencedirect.com/science/article/abs/pii/S0306261922003555" target="_self">https://www.sciencedirect.com/science/article/abs/pii/S0306261922003555</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://cloud.google.com/python/docs/reference/bigframes/latest/bigframes.ml.ensemble.XGBRegressor" target="_self">https://cloud.google.com/python/docs/reference/bigframes/latest/bigframes.ml.ensemble.XGBRegressor</a>
]]></description><link>데이터분석,ai/캐글/untitled-1.html</link><guid isPermaLink="false">데이터분석,ai/캐글/Untitled 1.md</guid><pubDate>Wed, 23 Jul 2025 11:59:31 GMT</pubDate></item><item><title><![CDATA[interceptor]]></title><description><![CDATA[ npm test -- --testPathPatterns=auth.integration --verboseimport axios from 'axios'
import { logout, updateToken } from '../store/authSlice'
import { store } from '../store/store'
import { authApi } from './auth' const api = axios.create({ baseURL: '/api', headers: { 'Content-Type': 'application/json' }
}) // 토큰 갱신 중인지 확인하는 플래그
let isRefreshing = false
// 대기 중인 요청들을 저장하는 배열
let failedQueue = [] const processQueue = (error, token = null) =&gt; { failedQueue.forEach(({ resolve, reject }) =&gt; { if (error) { reject(error) } else { resolve(token) } }) failedQueue = []
} // 요청 인터셉터
api.interceptors.request.use((config) =&gt; { const token = localStorage.getItem('token') if (token) { config.headers.Authorization = `Bearer ${token}` } return config
}, (error) =&gt; { return Promise.reject(error)
}) // 응답 인터셉터
api.interceptors.response.use( (response) =&gt; response, async (error) =&gt; { const originalRequest = error.config // 401 에러이고 아직 재시도하지 않은 요청인 경우 if (error.response?.status === 401 &amp;&amp; !originalRequest._retry) { // 이미 토큰 갱신 중인 경우, 대기열에 추가 if (isRefreshing) { return new Promise((resolve, reject) =&gt; { failedQueue.push({ resolve, reject }) }).then(token =&gt; { originalRequest.headers.Authorization = `Bearer ${token}` return api(originalRequest) }).catch(err =&gt; { console.log(err) return Promise.reject(err) }) } originalRequest._retry = true isRefreshing = true try { const refreshToken = localStorage.getItem('refreshToken') if (!refreshToken) { throw new Error('No refresh token') } // refreshToken으로 새로운 accessToken 발급 const response = await authApi.refresh() const { token } = response.data // 새로운 token 저장 store.dispatch(updateToken({ token })) // 대기 중인 요청들 처리 processQueue(null, token) // 원래 요청 재시도 originalRequest.headers.Authorization = `Bearer ${token}` return api(originalRequest) } catch (refreshError) { // refreshToken도 만료된 경우 로그아웃 processQueue(refreshError, null) store.dispatch(logout()) window.location.href = '/login' return Promise.reject(refreshError) } finally { isRefreshing = false } } return Promise.reject(error) }
) export default api 요청 → accessToken 유효 → 응답 성공 ✅
요청1 (401 에러) → isRefreshing = false → 토큰 갱신 시작
요청2 (401 에러) → isRefreshing = true → failedQueue에 대기
요청3 (401 에러) → isRefreshing = true → failedQueue에 대기
refreshToken으로 새 accessToken 발급 → store에 새 토큰 저장 → processQueue()로 대기 중인 모든 요청에 새 토큰 적용 → 모든 요청 재시도
refreshToken도 만료 → processQueue()로 모든 대기 요청 실패 처리 → 로그아웃 → 로그인 페이지로 리다이렉트
if (error.response?.status === 401 &amp;&amp; !originalRequest._retry) { originalRequest._retry = true // 이 요청은 더 이상 재시도 안함
}
if (isRefreshing) { // 이미 갱신 중이면 대기열에 추가만 하고 갱신은 안함
}
시나리오: 사용자가 페이지 로드 시 여러 API 호출1. 사용자 정보 요청 (401) → 토큰 갱신 시작
2. 게시글 목록 요청 (401) → 대기열에 추가
3. 알림 목록 요청 (401) → 대기열에 추가 토큰 갱신 성공 후:
- 모든 요청에 새 토큰 적용
- 각각 재시도
만약 토큰 갱신 실패:- 모든 대기 중인 요청 실패 처리
- 로그아웃
- 로그인 페이지로 이동
이렇게 하면 무한 루프 없이 안전하게 토큰을 갱신할 수 있어요!]]></description><link>kt에이블/빅프/interceptor.html</link><guid isPermaLink="false">kt에이블/빅프/interceptor.md</guid><pubDate>Wed, 23 Jul 2025 08:30:25 GMT</pubDate></item><item><title><![CDATA[Untitled]]></title><description><![CDATA[
설명:&nbsp;L2 정규화 강도를 조절하는 하이퍼파라미터. 역할:&nbsp;값을 높일수록 계수를 더 많이 패널티하여 모델이 단순해짐(과적합 방지). 값이 너무 크면 과소적합 위험. 기본값:&nbsp;1.0 설명:&nbsp;절편(Intercept)을 학습할지 정하는 옵션. 값:&nbsp;True(기본값, 절편 포함), False(절편 미포함) 설명:&nbsp;입력 데이터 피처를 정규화(평균0, 분산1)할지 여부(구버전). 주의:&nbsp;최근 버전에서는 사용 중단됨.&nbsp;StandardScaler&nbsp;사용 권장. 설명:&nbsp;최적화에 사용할 알고리즘 종류 선택. 값 예시:&nbsp;‘auto’, ‘svd’, ‘cholesky’, ‘lsqr’, ‘sparse_cg’, ‘sag’, ‘saga’, ‘lbfgs’ 특징:&nbsp;데이터 크기, 희소성 등에 따라 최적 solver가 다를 수 있음. 설명:&nbsp;반복 최적화 알고리즘의 최대 반복 횟수. 기본값:&nbsp;None(알고리즘마다 다름), 필요하면 명시적으로 설정.
]]></description><link>데이터분석,ai/캐글/untitled.html</link><guid isPermaLink="false">데이터분석,ai/캐글/Untitled.md</guid><pubDate>Tue, 22 Jul 2025 11:36:22 GMT</pubDate></item><item><title><![CDATA[youtubeapi]]></title><description><![CDATA[YouTube Analytics API
YouTube Reporting API
YouTube Data API v3공식문서왈
YouTube Reporting API는 채널 또는 콘텐츠 소유자의 포괄적인 YouTube 분석 데이터 세트가 포함된 사전 정의된 보고서를 지원합니다. 이러한 보고서를 사용하면&nbsp;<a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/analytics/v1?hl=ko" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/analytics/v1?hl=ko" target="_self">YouTube 분석 API</a>&nbsp;또는 YouTube 스튜디오의&nbsp;<a data-tooltip-position="top" aria-label="https://www.youtube.com/analytics?hl=ko" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.youtube.com/analytics?hl=ko" target="_self">분석</a>&nbsp;섹션에서 쿼리할 수 있는 대량 데이터 세트를 다운로드할 수 있습니다.<br>또한 API는 자동으로 생성되고 시스템에서 관리하는 보고서 모음을 지원합니다. 이 보고서는&nbsp;<a data-tooltip-position="top" aria-label="https://support.google.com/youtube/answer/7648605?hl=ko" rel="noopener nofollow" class="external-link is-unresolved" href="https://support.google.com/youtube/answer/7648605?hl=ko" target="_self">보고서 메뉴</a>에서 해당 보고서에 액세스할 수 있는 콘텐츠 소유자가 사용할 수 있습니다. 이러한 보고서에는 광고 수익 데이터와 YouTube Premium 구독 수익 데이터가 포함됩니다. 자세한 내용은&nbsp;<a data-tooltip-position="top" aria-label="https://developers.google.com/youtube/reporting/v1/reports/system_managed?hl=ko" rel="noopener nofollow" class="external-link is-unresolved" href="https://developers.google.com/youtube/reporting/v1/reports/system_managed?hl=ko" target="_self">시스템 관리 보고서</a>&nbsp;문서를 참고하세요.]]></description><link>kt에이블/빅프/youtubeapi.html</link><guid isPermaLink="false">kt에이블/빅프/youtubeapi.md</guid><pubDate>Mon, 21 Jul 2025 05:07:16 GMT</pubDate></item><item><title><![CDATA[eda]]></title><description><![CDATA[target : 'label'
Train columns: ['bid_qty', 'ask_qty', 'buy_qty', 'sell_qty', 'volume', 'X1', 'X2', 'X3', 'X4', 'X5', 'X6', 'X7', 'X8', 'X9', 'X10', 'X11', 'X12', 'X13', 'X14', 'X15', 'X16', 'X17', 'X18', 'X19', 'X20', 'X21', 'X22', 'X23', 'X24', 'X25', 'X26', 'X27', 'X28', 'X29', 'X30', 'X31', 'X32', 'X33', 'X34', 'X35', 'X36', 'X37', 'X38', 'X39', 'X40', 'X41', 'X42', 'X43', 'X44', 'X45', 'X46', 'X47', 'X48', 'X49', 'X50', 'X51', 'X52', 'X53', 'X54', 'X55', 'X56', 'X57', 'X58', 'X59', 'X60', 'X61', 'X62', 'X63', 'X64', 'X65', 'X66', 'X67', 'X68', 'X69', 'X70', 'X71', 'X72', 'X73', 'X74', 'X75', 'X76', 'X77', 'X78', 'X79', 'X80', 'X81', 'X82', 'X83', 'X84', 'X85', 'X86', 'X87', 'X88', 'X89', 'X90', 'X91', 'X92', 'X93', 'X94', 'X95', 'X96', 'X97', 'X98', 'X99', 'X100', 'X101', 'X102', 'X103', 'X104', 'X105', 'X106', 'X107', 'X108', 'X109', 'X110', 'X111', 'X112', 'X113', 'X114', 'X115', 'X116', 'X117', 'X118', 'X119', 'X120', 'X121', 'X122', 'X123', 'X124', 'X125', 'X126', 'X127', 'X128', 'X129', 'X130', 'X131', 'X132', 'X133', 'X134', 'X135', 'X136', 'X137', 'X138', 'X139', 'X140', 'X141', 'X142', 'X143', 'X144', 'X145', 'X146', 'X147', 'X148', 'X149', 'X150', 'X151', 'X152', 'X153', 'X154', 'X155', 'X156', 'X157', 'X158', 'X159', 'X160', 'X161', 'X162', 'X163', 'X164', 'X165', 'X166', 'X167', 'X168', 'X169', 'X170', 'X171', 'X172', 'X173', 'X174', 'X175', 'X176', 'X177', 'X178', 'X179', 'X180', 'X181', 'X182', 'X183', 'X184', 'X185', 'X186', 'X187', 'X188', 'X189', 'X190', 'X191', 'X192', 'X193', 'X194', 'X195', 'X196', 'X197', 'X198', 'X199', 'X200', 'X201', 'X202', 'X203', 'X204', 'X205', 'X206', 'X207', 'X208', 'X209', 'X210', 'X211', 'X212', 'X213', 'X214', 'X215', 'X216', 'X217', 'X218', 'X219', 'X220', 'X221', 'X222', 'X223', 'X224', 'X225', 'X226', 'X227', 'X228', 'X229', 'X230', 'X231', 'X232', 'X233', 'X234', 'X235', 'X236', 'X237', 'X238', 'X239', 'X240', 'X241', 'X242', 'X243', 'X244', 'X245', 'X246', 'X247', 'X248', 'X249', 'X250', 'X251', 'X252', 'X253', 'X254', 'X255', 'X256', 'X257', 'X258', 'X259', 'X260', 'X261', 'X262', 'X263', 'X264', 'X265', 'X266', 'X267', 'X268', 'X269', 'X270', 'X271', 'X272', 'X273', 'X274', 'X275', 'X276', 'X277', 'X278', 'X279', 'X280', 'X281', 'X282', 'X283', 'X284', 'X285', 'X286', 'X287', 'X288', 'X289', 'X290', 'X291', 'X292', 'X293', 'X294', 'X295', 'X296', 'X297', 'X298', 'X299', 'X300', 'X301', 'X302', 'X303', 'X304', 'X305', 'X306', 'X307', 'X308', 'X309', 'X310', 'X311', 'X312', 'X313', 'X314', 'X315', 'X316', 'X317', 'X318', 'X319', 'X320', 'X321', 'X322', 'X323', 'X324', 'X325', 'X326', 'X327', 'X328', 'X329', 'X330', 'X331', 'X332', 'X333', 'X334', 'X335', 'X336', 'X337', 'X338', 'X339', 'X340', 'X341', 'X342', 'X343', 'X344', 'X345', 'X346', 'X347', 'X348', 'X349', 'X350', 'X351', 'X352', 'X353', 'X354', 'X355', 'X356', 'X357', 'X358', 'X359', 'X360', 'X361', 'X362', 'X363', 'X364', 'X365', 'X366', 'X367', 'X368', 'X369', 'X370', 'X371', 'X372', 'X373', 'X374', 'X375', 'X376', 'X377', 'X378', 'X379', 'X380', 'X381', 'X382', 'X383', 'X384', 'X385', 'X386', 'X387', 'X388', 'X389', 'X390', 'X391', 'X392', 'X393', 'X394', 'X395', 'X396', 'X397', 'X398', 'X399', 'X400', 'X401', 'X402', 'X403', 'X404', 'X405', 'X406', 'X407', 'X408', 'X409', 'X410', 'X411', 'X412', 'X413', 'X414', 'X415', 'X416', 'X417', 'X418', 'X419', 'X420', 'X421', 'X422', 'X423', 'X424', 'X425', 'X426', 'X427', 'X428', 'X429', 'X430', 'X431', 'X432', 'X433', 'X434', 'X435', 'X436', 'X437', 'X438', 'X439', 'X440', 'X441', 'X442', 'X443', 'X444', 'X445', 'X446', 'X447', 'X448', 'X449', 'X450', 'X451', 'X452', 'X453', 'X454', 'X455', 'X456', 'X457', 'X458', 'X459', 'X460', 'X461', 'X462', 'X463', 'X464', 'X465', 'X466', 'X467', 'X468', 'X469', 'X470', 'X471', 'X472', 'X473', 'X474', 'X475', 'X476', 'X477', 'X478', 'X479', 'X480', 'X481', 'X482', 'X483', 'X484', 'X485', 'X486', 'X487', 'X488', 'X489', 'X490', 'X491', 'X492', 'X493', 'X494', 'X495', 'X496', 'X497', 'X498', 'X499', 'X500', 'X501', 'X502', 'X503', 'X504', 'X505', 'X506', 'X507', 'X508', 'X509', 'X510', 'X511', 'X512', 'X513', 'X514', 'X515', 'X516', 'X517', 'X518', 'X519', 'X520', 'X521', 'X522', 'X523', 'X524', 'X525', 'X526', 'X527', 'X528', 'X529', 'X530', 'X531', 'X532', 'X533', 'X534', 'X535', 'X536', 'X537', 'X538', 'X539', 'X540', 'X541', 'X542', 'X543', 'X544', 'X545', 'X546', 'X547', 'X548', 'X549', 'X550', 'X551', 'X552', 'X553', 'X554', 'X555', 'X556', 'X557', 'X558', 'X559', 'X560', 'X561', 'X562', 'X563', 'X564', 'X565', 'X566', 'X567', 'X568', 'X569', 'X570', 'X571', 'X572', 'X573', 'X574', 'X575', 'X576', 'X577', 'X578', 'X579', 'X580', 'X581', 'X582', 'X583', 'X584', 'X585', 'X586', 'X587', 'X588', 'X589', 'X590', 'X591', 'X592', 'X593', 'X594', 'X595', 'X596', 'X597', 'X598', 'X599', 'X600', 'X601', 'X602', 'X603', 'X604', 'X605', 'X606', 'X607', 'X608', 'X609', 'X610', 'X611', 'X612', 'X613', 'X614', 'X615', 'X616', 'X617', 'X618', 'X619', 'X620', 'X621', 'X622', 'X623', 'X624', 'X625', 'X626', 'X627', 'X628', 'X629', 'X630', 'X631', 'X632', 'X633', 'X634', 'X635', 'X636', 'X637', 'X638', 'X639', 'X640', 'X641', 'X642', 'X643', 'X644', 'X645', 'X646', 'X647', 'X648', 'X649', 'X650', 'X651', 'X652', 'X653', 'X654', 'X655', 'X656', 'X657', 'X658', 'X659', 'X660', 'X661', 'X662', 'X663', 'X664', 'X665', 'X666', 'X667', 'X668', 'X669', 'X670', 'X671', 'X672', 'X673', 'X674', 'X675', 'X676', 'X677', 'X678', 'X679', 'X680', 'X681', 'X682', 'X683', 'X684', 'X685', 'X686', 'X687', 'X688', 'X689', 'X690', 'X691', 'X692', 'X693', 'X694', 'X695', 'X696', 'X697', 'X698', 'X699', 'X700', 'X701', 'X702', 'X703', 'X704', 'X705', 'X706', 'X707', 'X708', 'X709', 'X710', 'X711', 'X712', 'X713', 'X714', 'X715', 'X716', 'X717', 'X718', 'X719', 'X720', 'X721', 'X722', 'X723', 'X724', 'X725', 'X726', 'X727', 'X728', 'X729', 'X730', 'X731', 'X732', 'X733', 'X734', 'X735', 'X736', 'X737', 'X738', 'X739', 'X740', 'X741', 'X742', 'X743', 'X744', 'X745', 'X746', 'X747', 'X748', 'X749', 'X750', 'X751', 'X752', 'X753', 'X754', 'X755', 'X756', 'X757', 'X758', 'X759', 'X760', 'X761', 'X762', 'X763', 'X764', 'X765', 'X766', 'X767', 'X768', 'X769', 'X770', 'X771', 'X772', 'X773', 'X774', 'X775', 'X776', 'X777', 'X778', 'X779', 'X780', 'label']
주요 선생님들이 셀랙한 feature main feature 'bid_qty', 'volume', 'buy_qty', 'sell_qty'
'ask_qty'
'X598', 'X344'
X363, X405, X321, X175, X179, X197, X22, X181, X28, X169, X198, X173, X338, X587, X450, X97, X52, X444, X297, X138, X572, X343, X438, X459, X758, X25 <a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.kaggle.com/code/johndoe2011/anyone-can-win-on-public-lb" target="_self">https://www.kaggle.com/code/johndoe2011/anyone-can-win-on-public-lb</a> [ 'X363', 'X405', 'X321', 'X175', 'X179', 'X137', 'X197', 'X22', 'X40', 'X181', 'X28', 'X169', 'X198', 'X173', 'X338', 'X288', 'X385', 'X344', 'X427', 'X587', 'X450', 'X97', 'X52', 'X444', 'X598', 'X379', 'X696', 'X297', 'X138', 'X572', 'X343', 'X586', 'X466', 'X438', 'X452', 'X459', 'X435', 'X386', 'X55', 'X341', 'X683', 'X428', 'X605', 'X445', 'X272', 'X180', 'X593', 'X680', 'X686', 'X692', 'X695', "X603", "X674", "X421", "X333", "X415", "X345", "X174", "X302", "X178", "X168", "X612", "buy_qty", "sell_qty", "volume", "bid_qty", "ask_qty", ] 기억안나시는누군가
""" 상호작용 및 기본 관계 지표
거래활성도랑, 실제로 내놨을때 얼마나팔렷나를 평가하는 척도들
"""
# 매수/매도 호가 수량의 곱. 주문서 유동성의 쌍방향 규모 예상
df['bid_ask_interaction'] = df['bid_qty'] * df['ask_qty'] # 매수 호가수량 × 실제 매수 체결량. 호가잔량과 실제 매수간 상호작용 지표
df['bid_buy_interaction'] = df['bid_qty'] * df['buy_qty']
# 매수 호가수량 × 실제 매도 체결량. 미체결 매수와 매도 거래간 연결도
df['bid_sell_interaction'] = df['bid_qty'] * df['sell_qty']
# 매도 호가수량 × 실제 매수 체결량. 미체결 매도와 매수 거래간 연결도
df['ask_buy_interaction'] = df['ask_qty'] * df['buy_qty']
# 매도 호가수량 × 실제 매도 체결량. 호가잔량과 실제 매도간 상호작용 지표
df['ask_sell_interaction'] = df['ask_qty'] * df['sell_qty']
# 실제 매수·매도 체결량의 곱. 거래 활성도의 상대 척도
df['buy_sell_interaction'] = df['buy_qty'] * df['sell_qty']
# (매도호가수량-매수호가수량)/(양 호가잔량 누적)로 유동성 불균형 지표
df['spread_indicator'] = (df['ask_qty'] - df['bid_qty']) / (df['ask_qty'] + df['bid_qty'] + 1e-8)
# 실시간 매수 체결량/매도 체결량 비율
df['buy_sell_ratio'] = df['buy_qty'] / (df['sell_qty'] + 1e-8)
# 매수호가잔량/매도호가잔량 비율
df['bid_ask_ratio'] = df['bid_qty'] / (df['ask_qty'] + 1e-8)
# 유동성
df['total_liquidity'] = df['bid_qty'] + df['ask_qty'] # 유동성 불균형도
df['liquidity_imbalance'] = (df['bid_qty'] - df['ask_qty']) / (df['total_liquidity'] + 1e-8)
# 매수 체결량/매수호가. 매수세가 호가잔량 대비 얼마나 큰지
df['normalized_buy_volume'] = df['buy_qty'] / (df['bid_qty'] + 1e-8)
# 매도 체결량/매도호가. 매도세가 호가잔량 대비 얼마나 큰지
df['normalized_sell_volume'] = df['sell_qty'] / (df['ask_qty'] + 1e-8) """
거래강도를 포함한 지표
각 매수매도의 힘과 전체 시장의 방향성과 힘이 얼마인지를 확인할 수 있음
"""
# 매도호가수량-매수호가수량)/총거래량. 유동성 대비 스프레드 지표
df['relative_spread'] = (df['ask_qty'] - df['bid_qty']) / (df['volume'] + 1e-8)
df['volume_weighted_buy'] = df['buy_qty'] * df['volume']
df['volume_weighted_sell'] = df['sell_qty'] * df['volume']
df['volume_weighted_bid'] = df['bid_qty'] * df['volume']
df['volume_weighted_ask'] = df['ask_qty'] * df['volume']
# 실시간 매수·매도 힘 균형(
df['order_flow_imbalance'] = (df['buy_qty'] - df['sell_qty']) / (df['volume'] + 1e-8)
# 볼륨을 반영한 유동성 불균형도인듯?
df['liquidity_adjusted_imbalance'] = df['order_flow_imbalance'] * df['depth_ratio']
# 매수매도 하려는 힘
df['buying_pressure'] = df['buy_qty'] / (df['volume'] + 1e-8)
df['selling_pressure'] = df['sell_qty'] / (df['volume'] + 1e-8)
# 전체 체결횟수/총거래량. 시장의 거래 활성 수준
df['trade_intensity'] = (df['buy_qty'] + df['sell_qty']) / (df['volume'] + 1e-8)
# 평균 체결 단위. 한 번 거래당 평균 체결량
df['avg_trade_size'] = df['volume'] / (df['buy_qty'] + df['sell_qty'] + 1e-8)
# 실질 순매수/매도 흐름. (매수-매도)/(매수+매도)
df['net_trade_flow'] = (df['buy_qty'] - df['sell_qty']) / (df['buy_qty'] + df['sell_qty'] + 1e-8)
# 총유동성/총거래량. 시장 유동성 깊이 척도
df['depth_ratio'] = df['total_liquidity'] / (df['volume'] + 1e-8)
df['volume_participation'] = (df['buy_qty'] + df['sell_qty']) / (df['total_liquidity'] + 1e-8)
# 시장활성지표 주문서-실제 거래의 복합 지표
df['market_activity'] = df['volume'] * df['total_liquidity'] # 체결량 차이/거래량. 시장 실효적 스프레드 근사치 df['effective_spread_proxy'] = np.abs(df['buy_qty'] - df['sell_qty']) / (df['volume'] + 1e-8)
df['realized_volatility_proxy'] = np.abs(df['order_flow_imbalance']) * df['volume'] # 매수압력 × 스프레드 지표. 매수세와 유동성 스프레드의 복합 움직임
df['pressure_spread_interaction'] = df['buying_pressure'] * df['spread_indicator'] <br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.kaggle.com/code/rosswade/drw-crypto-market-submission" target="_self">https://www.kaggle.com/code/rosswade/drw-crypto-market-submission</a> FEATURES = [ "X863", "X856", "X344", "X598", "X862", "X385", "X852", "X603", "X860", "X674", "X415", "X345", "X137", "X855", "X174", "X302", "X178", "X532", "X168", "X612", "bid_qty", "ask_qty", "buy_qty", "sell_qty", "volume","X888", "X421", "X333"
] # === NEW FEATURES ===
# 기억안나시는 누군가파트에서 다한 부분임
df['volume_weighted_sell'] = df['sell_qty'] * df['volume']
df['buy_sell_ratio'] = df['buy_qty'] / (df['sell_qty'] + 1e-8)
df['selling_pressure'] = df['sell_qty'] / (df['volume'] + 1e-8)
df['effective_spread_proxy'] = np.abs(df['buy_qty'] - df['sell_qty']) / (df['volume'] + 1e-8)
df['log_volume'] = np.log1p(df['volume'])
df['bid_ask_imbalance'] = (df['bid_qty'] - df['ask_qty']) / (df['bid_qty'] + df['ask_qty'] + 1e-8)
df['order_flow_imbalance'] = (df['buy_qty'] - df['sell_qty']) / (df['buy_qty'] + df['sell_qty'] + 1e-8)
df['liquidity_ratio'] = (df['bid_qty'] + df['ask_qty']) / (df['volume'] + 1e-8) <br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.kaggle.com/code/taylorsamarel/xgb-deep-learning-ensemble" target="_self">https://www.kaggle.com/code/taylorsamarel/xgb-deep-learning-ensemble</a> core_features = [ 'X363', 'X405', 'X321', 'X175', 'X179', 'X197', 'X22', 'X181', 'X28', 'X169', 'X198', 'X173', 'X338', 'X344', 'X587', 'X450', 'X97', 'X52', 'X444', 'X598', 'X297', 'X138', 'X572', 'X343', 'X438', 'X459', 'X758', 'X25', 'buy_qty', 'sell_qty', 'volume', 'bid_qty' ] <br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.kaggle.com/code/vishalpainjane/drw-ensemble-0-72837" target="_self">https://www.kaggle.com/code/vishalpainjane/drw-ensemble-0-72837</a> cols = [ 'X363', 'X405', 'X321', 'X175', 'X179', 'X137', 'X197', 'X22', 'X40', 'X181', 'X28', 'X169', 'X198', 'X173', 'X338', 'X288', 'X385', 'X344', 'X427', 'X587', 'X450', 'X97', 'X52', 'X444', 'X598', 'X379', 'X696', 'X297', 'X138', 'X572', 'X343', 'X586', 'X466', 'X438', 'X452', 'X459', 'X435', 'X386', 'X55', 'X341', 'X683', 'X428', 'X605', 'X445', 'X272', 'X180', 'X593', 'X680', 'X686', 'X692', 'X695', "X603", "X674", "X421", "X333", "X415", "X345", "X174", "X302", "X178", "X168", "X612", 'X298', 'X45', 'X46', 'X39', 'X752', 'X759', 'X41', 'X42', "buy_qty", "sell_qty", "volume", "bid_qty", "ask_qty", ] # Add new top important features new_features = [ 'X758', 'X296', 'X611', 'X780', 'X451', 'X25', 'X591', ] <br>
리지모델 : <a rel="noopener nofollow" class="external-link is-unresolved" href="https://wikidocs.net/152833" target="_self">https://wikidocs.net/152833</a> ]]></description><link>데이터분석,ai/캐글/eda.html</link><guid isPermaLink="false">데이터분석,ai/캐글/eda.md</guid><pubDate>Sun, 20 Jul 2025 06:25:47 GMT</pubDate></item><item><title><![CDATA[주성분분석 pca]]></title><description><![CDATA[PCA가 뽑은 12개의 주성분은 '특정 칼럼' 자체가 아니라, 원본 칼럼들의 선형 결합(조합)으로 만들어진 새로운 좌표축(축, 벡터)입니다.from sklearn.decomposition import PCA<a rel="noopener nofollow" class="external-link is-unresolved" href="https://blog.naver.com/prayer2k/222624821291" target="_self">https://blog.naver.com/prayer2k/222624821291</a>그래프는 일종의 상관관계
x,y상관관계는그래프로나타낼수잇음
공분산의 분산이 가장작은걸 찾는거임corr이것도 공분산을 표준화 한거<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://lets-start-data.tistory.com/entry/%EB%AA%A8%EB%8D%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%B0%A8%EC%9B%90-%EC%B6%95%EC%86%8C-PCA-%EB%9E%9C%EB%8D%A4-PCA-%EC%A0%90%EC%A7%84%EC%A0%81-PCA" target="_self">https://lets-start-data.tistory.com/entry/%EB%AA%A8%EB%8D%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%B0%A8%EC%9B%90-%EC%B6%95%EC%86%8C-PCA-%EB%9E%9C%EB%8D%A4-PCA-%EC%A0%90%EC%A7%84%EC%A0%81-PCA</a>pca와 randomforest의 변수중요도<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://hongl.tistory.com/129" target="_self">https://hongl.tistory.com/129</a>gini pca r개수로 찾기n_components_list = [10, 20, 50, 100]
pca_results = {}for n_components in n_components_list:
if n_components &lt;= X_scaled.shape[1]:
pca = PCA(n_components=n_components)
X_pca = pca.fit_transform(X_scaled) explained_variance_ratio = pca.explained_variance_ratio_.sum() pca_results[n_components] = { 'X_pca': X_pca, 'explained_variance_ratio': explained_variance_ratio, 'pca': pca } print(f"PCA {n_components} components: {explained_variance_ratio:.4f} variance explained")
n_components 0-1 사이면 분산의 빈율이 고
1이상이면 주성분 개수임print("\n3. PCA 적용…")
variancethresholds = [0.80, 0.85, 0.90, 0.95]
for threshold in variance_thresholds:
pca = PCA(threshold)
X_pca = pca.fit_transform(X_scaled)
print(f"{threshold*100}% 분산: {pca.n_components}개 주성분")<br>
<img alt="주성분분석 pca-1752345952529.png" src="kt에이블/assets/주성분분석-pca-1752345952529.png" target="_self">]]></description><link>kt에이블/주성분분석-pca.html</link><guid isPermaLink="false">kt에이블/주성분분석 pca.md</guid><pubDate>Sun, 20 Jul 2025 06:04:25 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[명세]]></title><description><![CDATA[아래에 제시된 요구정의명은 기존 내용을 포함하고, 사용자 업로드 및 콘텐츠 관리 기능 중심으로 수정 및 보완되었습니다. 각 요구정의명에 대한 상세 내용은 백엔드 개발에 직결되도록 파일 형식, validation, 응답 값 등을 포함하여 상세하게 기술했습니다.
인증 및 인가: 모든 API 호출에 대해 사용자 인증(로그인 여부 확인) 및 인가(해당 콘텐츠에 대한 권한 확인)가 필수적으로 적용되어야 합니다. JWT(JSON Web Token) 또는 OAuth2 등의 방식을 고려할 수 있습니다. 에러 처리: 각 요구사항별로 발생할 수 있는 오류(예: 파일 없음, 권한 없음, 유효하지 않은 파라미터)에 대한 명확한 에러 코드와 메시지를 정의해야 합니다. 로깅: 모든 중요한 작업(콘텐츠 생성, 수정, 삭제, 업로드 등)에 대한 로그를 기록하여 시스템 운영 및 문제 해결에 활용해야 합니다. 성능 최적화: 대용량 파일 처리 및 AI 모델 호출 시 비동기 처리, 큐(Queue) 시스템 도입, 캐싱 전략 등을 고려하여 성능을 최적화해야 합니다. 스토리지 관리: S3와 같은 클라우드 스토리지를 활용하여 안정적이고 확장 가능한 파일 저장을 구현해야 합니다. 데이터 모델링: 콘텐츠의 메타데이터(제목, 생성일, AI 생성 여부, 파일 경로 등)를 효율적으로 저장하고 관리할 수 있는 데이터베이스 스키마를 미리 정의해야 합니다. 콘텐츠 태그/카테고리: 콘텐츠를 효율적으로 분류하고 검색하기 위한 태그 또는 카테고리 관리 기능도 고려할 수 있습니다. 버전 관리: 편집된 콘텐츠를 저장할 때, 이전 버전을 보존할 것인지에 대한 버전 관리 정책을 수립하고 구현할 수 있습니다 (예: 특정 개수 또는 기간 동안 이전 버전 유지). 이 수정된 요구사항 정의서가 마케팅 AI 플랫폼 백엔드 개발에 도움이 되기를 바랍니다!]]></description><link>kt에이블/빅프/명세.html</link><guid isPermaLink="false">kt에이블/빅프/명세.md</guid><pubDate>Fri, 18 Jul 2025 05:50:22 GMT</pubDate></item><item><title><![CDATA[비ㄱ프때내가머햇음]]></title><description><![CDATA[도메인 정의 다시함단어정의함
콘텐츠 , 게시글
전민지꺼랑 만두꺼랑 어케바뀌엇는지 비교하면 내가한거적을수잇을듯]]></description><link>kt에이블/빅프/비ㄱ프때내가머햇음.html</link><guid isPermaLink="false">kt에이블/빅프/비ㄱ프때내가머햇음.md</guid><pubDate>Thu, 17 Jul 2025 08:53:02 GMT</pubDate></item><item><title><![CDATA[주성분분석 pca-1752345952529]]></title><description><![CDATA[<img src="kt에이블/assets/주성분분석-pca-1752345952529.png" target="_self">]]></description><link>kt에이블/assets/주성분분석-pca-1752345952529.html</link><guid isPermaLink="false">kt에이블/assets/주성분분석 pca-1752345952529.png</guid><pubDate>Sat, 12 Jul 2025 18:45:52 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[db 영속성과 저장]]></title><description><![CDATA[Client &lt;-&gt; Controller &lt;-&gt; Service &lt;-&gt; Mapper &lt;-&gt; DB<img alt="db 영속성과 저장-1751787526152.png" src="ktaivle_back/assets/db-영속성과-저장-1751787526152.png" target="_self">// 저장하고 flush하여 id 즉시 생성
AuthorAccount savedAccount = repository().saveAndFlush(this); // 저장된 엔티티로 이벤트 publish (id가 설정된 객체)
AuthorSignup authorSignup = new AuthorSignup(savedAccount);
authorSignup.publishAfterCommit();
my errorrepo().save(this)
해서 db에저장하고 id를 포함한 객체를 이벤트로 발행하는 로직이엇다but;;
저 saveAccount객체가 잘 넘어가지 않았다.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://velog.io/@codren/JPA-%EA%B0%9C%EB%85%90-%EB%B0%8F-%EC%9B%90%EB%A6%AC" target="_self">https://velog.io/@codren/JPA-%EA%B0%9C%EB%85%90-%EB%B0%8F-%EC%9B%90%EB%A6%AC</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://bnzn2426.tistory.com/145" target="_self">https://bnzn2426.tistory.com/145</a>]]></description><link>ktaivle_back/db-영속성과-저장.html</link><guid isPermaLink="false">ktaivle_back/db 영속성과 저장.md</guid><pubDate>Sun, 06 Jul 2025 07:39:33 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[db 영속성과 저장-1751787526152]]></title><description><![CDATA[<img src="ktaivle_back/assets/db-영속성과-저장-1751787526152.png" target="_self">]]></description><link>ktaivle_back/assets/db-영속성과-저장-1751787526152.html</link><guid isPermaLink="false">ktaivle_back/assets/db 영속성과 저장-1751787526152.png</guid><pubDate>Sun, 06 Jul 2025 07:38:46 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스프링 DB 접근]]></title><description><![CDATA[
자바에서 데이터베이스에 접근할 수 있도록 하는 자바 API
low level standard임
<img alt="스프링 DB 접근-1748788030972.png" src="ktaivle_back/assets/스프링-db-접근-1748788030972.png" target="_self">SQL 중심 기술임(직접작성해야한단소리임)
therefore DBMS에 종속속적임
아래 기술은 내부적으로 JDBC를 사용함(JPA는 대부분..)
JDBC Template JDBC를 쉽게 사용하기 위한 JDBC의 래퍼임 MyBatis SQL과 자바 객체간 매핑을 지원하는 프레임워크
개발자가 sql작성하면 mybatis가 jdbc의 부분을 처리 JPA java orm의 스텐다드임
sql안쓰고 객체중심으로 DB를 다룰 수 있게 해줌
DataNucleus JPA JDBC 사용 ㄴㄴ
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://stackoverflow.com/questions/11881548/jpa-or-jdbc-how-are-they-different" target="_self">https://stackoverflow.com/questions/11881548/jpa-or-jdbc-how-are-they-different</a> OOP &lt;-&gt; RDB 연결
객체지향과 관계형을 매핑한다
패러다임의 불일치가 존재함
RDB의 model을 entity형태로 투형함
관계를 지정하면 orm이 자동으로 sql을 생성함 dbms 종속이 적어짐 JPA의 대표 구현체 : Hibernate
장점 종속성적어짐
간단한거 구현 개쉬움
객체지향적 단점 모든 쿼리 대체불가
쿼리 괴랄하면 난이도 급상승
잘못 구현되면 속도랑 일관성이무너짐 java 의 orm 영속 : 객체 생성후 em.persist(entity)를 호출하여 영속성 컨텍스트에 들어감
비영속 : 객체생성후 영속성 컨텍스트와 관계 엄슴
준영속 : 영속성 컨텍스트에 저장되었다가 분리되어 나옴
삭제 : 객체를 삭제한 상태
persistence context<br>
<a class="internal-link" data-href="db 영속성과 저장.md" href="ktaivle_back/db-영속성과-저장.html" target="_self" rel="noopener nofollow">db 영속성과 저장</a>
어플리케이션과 DB사이서 객체를 보관하는 가상 DB 엔티티 매니저를 통해 엔티티를 저장,조회시 엔티티 매니저는 연속성 컨텍스트에 저장하고 관리함
내부에 캐시를 갖음(이를 1차 캐시라함) Map형식임
1차에 잇으면 DB까지 조회안함 쓰기 지연을 할수 있음 미리 변경사항을 갖고잇다가 트랜잭션이 커밋되면 한번에 쿼리 날릴수잇음
DB커넥션 수와 시간을 줄일 . 수있음 영속성 컨텍스트의 변경내용을 db에 반영하는 작업(일종의 동기화 작업)
영속성 컨텍스트에 저장된 엔티티의 변경사항이 실제 db에 전달
플러시가 발생해도 1차 캐시(영속성 컨텍스트)는 그대로 유지됨
동작과정 변경감지
수정된 엔티티 등록
sql db 전송 언제 발생? 트랜젝션 커밋
(Java Persistence Query Language)로 쿼리를 실행할 때 자동으로
직접 flush() 호출 모드 auto 트랜잭션 커밋이나 쿼리 실행 시 플러시가 자동으로 동작 commit 트랜잭션 커밋 시에만 플러시가 동작 ]]></description><link>ktaivle_back/스프링-db-접근.html</link><guid isPermaLink="false">ktaivle_back/스프링 DB 접근.md</guid><pubDate>Sun, 06 Jul 2025 07:36:52 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>